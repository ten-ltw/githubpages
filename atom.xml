<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[十]]></title>
  <link href="blog.2019919.top/atom.xml" rel="self"/>
  <link href="blog.2019919.top/"/>
  <updated>2021-01-15T07:26:33+08:00</updated>
  <id>blog.2019919.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[第 8 章 函数]]></title>
    <link href="blog.2019919.top/16106664265983.html"/>
    <updated>2021-01-15T07:20:26+08:00</updated>
    <id>blog.2019919.top/16106664265983.html</id>
    <content type="html"><![CDATA[
<p>本章介绍了 JavaScript 函数。函数是 JavaScript 程序的基本构建块，也是几乎所有编程语言的共同特性。你可能已经了解函数的概念，如子例程或过程。</p>

<p>函数是一个 JavaScript 代码块，只定义一次，但可以执行或调用任意次数。JavaScript 函数是参数化的：一个函数定义可以包含一个标识符列表，称为参数，作为函数体的局部变量。函数调用为函数的参数提供值或实参。函数通常使用它们的实参值来计算一个返回值，该返回值成为函数调用表达式的值。除了参数之外，每次调用都有另一个值——调用上下文——即 this 关键字的值。</p>

<p>如果函数挂载在一个对象上作为其属性，它就被称为方法。当该方法在对象中被调用或通过对象调用时，该对象就是该方法函数的调用上下文或 this 值。用于初始化新创建的对象的函数称为构造函数。构造函数在 §6.2 中有介绍，我们将在第9章中再次谈到它。</p>

<p>在 JavaScript 中，函数是对象，它们可以被程序操作。例如，JavaScript 可以将函数赋给变量，并将它们传递给其他函数。由于函数是对象，所以您可以给它们设置属性，甚至调用它们的方法。</p>

<p>JavaScript 函数可以嵌套在其他函数中定义，并且它们可以访问定义它们所处的作用域内任何变量。这意味着 JavaScript 函数是闭包，支持闭包是非常重要的，它是非常强大的编程技巧。</p>

<h2 id="toc_0">8.1 函数定义</h2>

<p>定义 JavaScript 函数最直接的方法是使用 function 关键字，它既可以用作声明又可以用作表达式。ES6 定义了一种不使用 function 关键字的重要新方法来定义的函数：“箭头函数”，它具有特别简洁语法，并且在将一个函数作为参数传递给另一个函数的场景中非常实用。接下来的小节将介绍这三种定义函数的方法。注意，关于函数定义语法包含的函数参数相关内容将在 §8.3 中介绍。</p>

<p>在对象字面量和类定义中，有一种方便的快捷语法来定义方法。这种简写语法在 §6.10.5 中有介绍，相当于通过对象字面量语法将函数定义表达式用最基本的属性名：属性值的方式赋值给对象的属性。在另一种特殊情况下，可以在对象字面量中使用关键字 get 和 set 来定义特殊的属性 getter 和 setter 方法。这个函数定义语法在 §6.10.6 中介绍过。</p>

<p>注意，函数也可以用 Function() 构造函数来定义，这是 §8.7.7 的主题。此外，JavaScript 还定义了一些特殊类型的函数。function* 定义函数生成器（见第12章）和 async function 定义异步函数（见第13章）。</p>

<h3 id="toc_1">8.1.1 函数声明</h3>

<p>函数声明由 function 关键字组成，后面跟着这些组件:</p>

<ul>
<li>函数名称标识符。名称是函数声明的必要部分:它用作变量的名称，并将新定义的函数对象赋值给该变量。</li>
<li>一对圆括号，其中包含由0个或者多个用逗号分隔的标识符组成的列表。这些标识符是函数的参数名，它们的行为类似于函数体中的局部变量。</li>
<li>一对花括号，其中包含由0条或者多条 JavaScript 语句。这些语句构成了函数体：每当函数调用时，就会执行这些语句。</li>
</ul>

<p>下面是一些函数声明的例子:</p>

<pre><code class="language-javascript">// Print the name and value of each property of o.  Return undefined.
function printprops(o) {
    for(let p in o) {
        console.log(`${p}: ${o[p]}\n`);
    }
}

// Compute the distance between Cartesian points (x1,y1) and (x2,y2).
function distance(x1, y1, x2, y2) {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return Math.sqrt(dx*dx + dy*dy);
}

// A recursive function (one that calls itself) that computes factorials
// Recall that x! is the product of x and all positive integers less than it.
function factorial(x) {
    if (x &lt;= 1) return 1;
    return x * factorial(x-1);
}
</code></pre>

<p>重中之重要理解函数声明是函数名变成一个变量，这个变量的值是函数本身。函数声明语句“被提前”到脚本、函数、块之前，因此这种方式定义的函数可以在它定义之前被调用。另一种说法是所有声明在 Javascript 代码块中的函数，在块内始终是有定义的，它们定义在 JavaScript 解释器开始解释执行块内任何语句之前。</p>

<p>distance() 和 factorial() 函数计算一个值，它们用 retrun 来将这个值返回给调用者。return 语句导致函数停止执行，并返回它的表达式的值（如果有的话）给调用者。如果 return 语句没有一个与之相关的表达式，则函数返回 undefined 值。</p>

<p>printprops() 函数不同：它负责输出对象属性的名称和值。没有返回值的必要，并且该函数也不包含一个 return 语句。 调用 printprops() 函数的返回值永远是 undefined。如果一个函数不包含一个 return 语句，它仅仅执行函数体内每一条语句直到结束，并返回 undefined 给调用者。</p>

<p>在 ES6 之前，函数只允许在 JavaScript 文件顶层或者其他函数中声明。然而一些实现违反规约，在循环体条件体或者其他块中定义函数。在 ES6 的严格模式下，函数允许在块内进行声明。一个定义在块内的函数只存在于该块内，块外是不可见的。</p>

<h3 id="toc_2">8.1.2 函数表达式</h3>

<p>函数表达式看起来很像函数声明，但是它出现在一个它的上层表达式或语句的上下文中，并且函数名称是可选项。</p>

<p>下面是一些函数表达式的例子：</p>

<pre><code class="language-javascript">// This function expression defines a function that squares its argument.
// Note that we assign it to a variable
const square = function(x) { return x*x; };

// Function expressions can include names, which is useful for recursion.
const f = function fact(x) { if (x &lt;= 1) return 1; else return x*fact(x-1); };

// Function expressions can also be used as arguments to other functions:
[3,2,1].sort(function(a,b) { return a-b; });

// Function expressions are sometimes defined and immediately invoked:
let tensquared = (function(x) {return x*x;}(10));
</code></pre>

<p>注意函数名称在函数表达式中是可选项，在大部分函数表达式中我们省略了它。函数声明实际上声明了一个变量并且将函数对象赋值给它。按照这个角度来看，函数表达式没有声明一个变量：可以根据它是否会多次调用由你自己决定是将新定义的函数对象赋值给一个常量还是变量。用 const 定义函数表达式是一个非常好的做法，你不会因为意外赋值而重写了你的函数。</p>

<p>可以给函数一个名称，就像 factorial 函数，它需要调用它自己。如果一个函数表达式包含一个名称，那这个函数的局部函数作用域内会包含一个属性名为该函数名的对象，其值绑定的是该函数。实际上，函数名变成这个函数的一个局部变量。大多数函数表达式不需要函数名称，这让它们的定义更简洁（但是并没有下面要讲的箭头函数简洁）。</p>

<p>在函数声明和函数表达式之间有一个非常重要的不同。当你用函数声明，该函数对象创建于该函数所在作用域的代码开始执行之前，也就是声明提前，所以你可以在函数定义之前调用他们。如果用函数表达式来定义一个函数，这样使用就是不对的：该函数不会存在，直到函数定义表达式真正被计算。因为，想要执行一个函数，你必须可以引用它，而一个函数表达式定义的函数一直到该函数赋值给一个变量后才能被引用，所以要使用函数表达式需要在函数被调用之前定义。</p>

<h3 id="toc_3">8.1.3 箭头函数</h3>

<p>在 ES6 之后，你可以用一个特别简洁的语法来定义函数，被称为“箭头函数”。这个语法联想到数学符号，用一个 =&gt; &quot;箭头&quot;来分隔函数的参数和函数体。function 关键字未使用，并且，由于箭头函数是表达式而不是声明语句，也不需要一个函数名称。一般箭头函数用圆括号包含一个逗号分隔的参数列表，接一个 =&gt; 箭头，后面是花括号包含的函数体。</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; { return x + y; };
</code></pre>

<p>但是箭头函数支持更加简洁的语法。如果函数体只有一个简单的 return 语句，你可以省略 return 关键字，分号和花括号都一起省略，将函数体写成一个计算返回值的表达式。</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; x + y;
</code></pre>

<p>而且，如果一个箭头函数只有一个参数，你可以省略参数列表的圆括号。</p>

<pre><code class="language-javascript">const polynomial = x =&gt; x*x + 2*x + 3;
</code></pre>

<p>注意，如果箭头函数没有参数，必须写一对空圆括号。</p>

<pre><code class="language-javascript">const constantFunc = () =&gt; 42;
</code></pre>

<p>注意，当写一个箭头函数时，函数参数和箭头之间不能换行。否则，可能会直接在赋值后中止，就像 <code>const polynomial = x</code>，因为它本身是一个语法上合法的赋值语句。</p>

<p>Also, if the body of your arrow function is a single return statement but the expression to be returned is an object literal, then you have to put the object literal inside parentheses to avoid syntactic ambiguity between the curly braces of a function body and the curly braces of an object literal:</p>

<blockquote>
<p>此外，如果箭头函数体是一个单一的 return 语句，而且他返回的是一个对象字面量，那必须将对象字面量用圆括号包起来，避免将对象字面量的大括号误解成函数体的大括号。</p>
</blockquote>

<pre><code class="language-javascript">const f = x =&gt; { return { value: x }; };  // Good: f() returns an object
const g = x =&gt; ({ value: x });            // Good: g() returns an object
const h = x =&gt; { value: x };              // Bad: h() returns nothing
const i = x =&gt; { v: x, w: x };            // Bad: Syntax Error
</code></pre>

<p>这段代码的第三行，函数 h() 就有歧义：这段代码原本返回对象字面量被转化为一个标签语句，所以一个返回 undefined 的函数被创建。第四行，结构更复杂的对象字面量不是一个合法的语句，这段代码会抛出一个语法异常。</p>

<p>简洁的箭头函数可以完美的传递一个函数给另外一个函数，比如一些数组的常规操作方法 map()，filter() 和 reduce()（见 §7.8.1），例如：</p>

<pre><code class="language-javascript">// Make a copy of an array with null elements removed.
let filtered = [1,null,2,3].filter(x =&gt; x !== null); // filtered == [1,2,3]
// Square some numbers:
let squares = [1,2,3,4].map(x =&gt; x*x);               // squares == [1,4,9,16]
</code></pre>

<p>箭头函数不同于用关键字定义的函数：箭头函数从定义它们的环境继承 this 关键字，而不是像其他定义方式那样定义自己的调用上下文。这是箭头函数一个重要且特别实用的特性，我们会在这一章的后面再次提到它。箭头函数也不同于其他函数，它们没有有原型属性。这意味着它不能被当作一个构造函数去创建一个类（见 §9.2）。</p>

<h3 id="toc_4">8.1.4 嵌套函数</h3>

<p>在 JavaScript 中，函数可以嵌套在其他函数内。例如：</p>

<pre><code class="language-javascript">function hypotenuse(a, b) {
    function square(x) { return x*x; }
    return Math.sqrt(square(a) + square(b));
}
</code></pre>

<p>嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。例如，在上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b。这些作用域规则对嵌套函数非常重要，我们会在 §8.6 再深入了解它们。</p>

<h2 id="toc_5">8.2 函数调用</h2>

<p>构成函数主体的 JavaScript 代码在定义之时并不会执行，只有调用该函数时，它们才会执行。JavaScript 函数可以以五种方式被调用。</p>

<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造函数</li>
<li>通过它们的 call() 和 apply() 方法间接调用</li>
<li>隐式调用，不同于普通函数调，通过 JavaScript 语言特性调用函数。</li>
</ul>

<h3 id="toc_6">8.2.1 函数调用</h3>

<p>函数或方法通过调用表达式（§4.5）被调用。调用表达式由以下部分组成，计算函数对象的函数表达式，一个开放圆括号，逗号分隔的零个或多个实参表达式列表，一个闭合圆括号。如果函数表达式是属性访问表达式（函数是一个对象的属性或者一个数组的元素）那么它是一个方法调用表达式。这种情况会通过下面的例子说明，接下来这个代码包含了一些常规的函数调用表达式：</p>

<pre><code class="language-javascript">printprops({x: 1});
let total = distance(0,0,2,1) + distance(2,1,3,5);
let probability = factorial(5)/factorial(13);
</code></pre>

<p>在调用中，每个实参表达式（圆括号内的）执行计算，返回值作为函数的实参。这些值传给函数定义的参数。在函数体内，参数的引用指向对应实参的值。</p>

<p>对于常规的函数调用，函数返回值变成函数调用表达式的值。如果因解释器执行到函数结尾而返回，返回值就是 undefined。如果函数返回是因为解释器执行一个 return 语句，那么返回值是 return 后面的表达式的计算结果，如果 return 语句没有值也返回 undefined。</p>

<h4 id="toc_7">条件调用</h4>

<p>在 ES2020 中你可以通过在函数表达式和圆括号之间插入 ?. 符号，使函数只有在不为 null 和 undefined 时候再调用。表达式 f?.(x) 等价（假设没有副作用）于：</p>

<pre><code class="language-javascript">(f !== null &amp;&amp; f !== undefined) ? f(x) : undefined
</code></pre>

<p>详细的条件执行语法描述在 §4.5.1。</p>

<p>函数调用在非严格模式下，调用上下文（ this ）是全局对象。然而在严格模式下，调用上下文是 undefined。注意箭头语法定义的函数行为是不同的：实际上它们总是继承它们定义位置的 this 值。</p>

<p>以函数形式调用的函数通常不使用 this 关键字。不过，this 关键字可以用来判断当前是否是严格模式。</p>

<pre><code class="language-javascript">// Define and invoke a function to determine if we&#39;re in strict mode.
const strict = (function() { return !this; }());
</code></pre>

<h4 id="toc_8">递归函数和栈</h4>

<p>递归函数就像本章开始的 factorial() 函数，它调用它自己。某些算法（如涉及基于树的数据结构）可以使用递归函数特别优雅地实现。在写递归函数时，考虑内存分配是很重要的。当函数 A 调用函数 B，然后函数 B 又调用函数 C 时，Javascript 编译器需要知道在哪里重新执行函数 B，当函数 B 执行完成后它需要知道在哪里执行函数 A。你可以将执行上下文想象成一个栈。当一个函数调用另外一个函数时，一个新的执行上下文被压入栈中。当被调用函数返回，它的执行上下文对象从栈中弹出。如果一个函数递归调用100次，那么会有100个对象被压入栈中，然后这100个对象再依次从栈中弹出。这种调用非常耗内存。以现代的硬件递归调用100次通常没什么问题。但是如果一个函数递归上千次，它可能会失败并报错“Maximum call-stack size exceeded.”。</p>

<h3 id="toc_9">8.2.2 方法调用</h3>

<p>方法只不过是对象属性函数。如果有一个函数 f 和一个对象 o，可以用下面的代码给对象 o 定义一个名为 m 的方法：</p>

<pre><code class="language-javascript">o.m = f;
</code></pre>

<p>给对象 o 定义了方法 m()，用这种方式调用它：</p>

<pre><code class="language-javascript">o.m();
</code></pre>

<p>或者 m() 需要两个实参，可以这样调用它：</p>

<pre><code class="language-javascript">o.m(x, y);
</code></pre>

<p>例子中的代码是一个调用表达式：它包含一个函数表达式 o.m 和两个实参表达式 x 和 y。函数表达式本身是一个属性访问表达式，这意味着该函数被当作一个方法调用，而不是一个普通的函数。</p>

<p>对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即：调用上下文。属性访问表达式由两部分组成：一个对象（本例中的 o）和属性名称（m）。在像这样的方法调用表达式里，对象 o 成为调用上下文，函数体可以使用关键字this引用该对象。下面是一个具体的例子：</p>

<pre><code class="language-javascript">let calculator = { // An object literal
    operand1: 1,
    operand2: 1,
    add() {        // We&#39;re using method shorthand syntax for this function
        // Note the use of the this keyword to refer to the containing object.
        this.result = this.operand1 + this.operand2;
    }
};
calculator.add();  // A method invocation to compute 1+1.
calculator.result  // =&gt; 2
</code></pre>

<p>大多数方法调用使用点符号来访问属性，使用方括号（属性访问表达式）也可以进行属性访问操作。下面两个例子都是函数调用：</p>

<pre><code class="language-javascript">o[&quot;m&quot;](x,y);   // Another way to write o.m(x,y).
a[0](z)        // Also a method invocation (assuming a[0] is a function).
</code></pre>

<p>方法调用可能包括更复杂的属性访问表达式：</p>

<pre><code class="language-javascript">customer.surname.toUpperCase(); // Invoke method on customer.surname
f().m();                        // Invoke method m() on return value of f()
</code></pre>

<p>方法和 this 关键字是面向对象编程范式的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参对象，就是调用这个方法对象本身。通常来讲，方法执行就是对象的某种操作，方法调用的语法也清晰的表达了它是操作对象的函数，比较下面两行代码：</p>

<pre><code class="language-javascript">rect.setSize(width, height);
setRectSize(rect, width, height);
</code></pre>

<p>我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象 rect。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是 rect 对象，函数中的所有操作都将基于这个对象。</p>

<h4 id="toc_10">方法链</h4>

<p>当方法返回一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（或“链”）每次的调用结果都是另外一个表达式的组成部分。比如，基于 Promise 的异步操作（参见第13章），我们常常会这样写代码：</p>

<pre><code class="language-javascript">// Run three asynchronous operations in sequence, handling errors.
doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);
</code></pre>

<p>当方法并不需要返回值时，最好直接返回 this。如果在设计的 API 中一直采用这种方式，使用 API 就可以用方法链 <sup>1</sup> 风格的编程，在这种编程风格中，只要指定一次要调用的对象即可，余下的方法都可以基于此进行调用：</p>

<pre><code class="language-javascript">new Square().x(100).y(100).size(50).outline(&quot;red&quot;).fill(&quot;blue&quot;).draw();
</code></pre>

<p>需要注意的是，this 是一个关键字，不是变量，也不是属性名。JavaScript 的语法不允许给 this 赋值。</p>

<p>关键字 this 没有变量作用域的限制，除了箭头函数，嵌套函数不会从包含它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套的函数作为函数调用（不包含箭头函数），其 this 值不是全局对象（非严格模式下）就是undefined（严格模式下）。很多人误以为在一个方法中的函数声明并以函数调用的方式去执行可以用 this 来获取方法的执行上下文。下面这个例子说明了这个问题：</p>

<pre><code class="language-javascript">let o = {                 // An object o.
    m: function() {       // Method m of the object.
        let self = this;  // Save the &quot;this&quot; value in a variable.
        this === o        // =&gt; true: &quot;this&quot; is the object o.
        f();              // Now call the helper function f().

        function f() {    // A nested function f
            this === o    // =&gt; false: &quot;this&quot; is global or undefined
            self === o    // =&gt; true: self is the outer &quot;this&quot; value.
        }
    }
};
o.m();                    // Invoke the method m on the object o.
</code></pre>

<p>嵌套函数 f() 中，this 关键之不等于对象 o。这被广泛的认为是 JavaScript 的一个缺陷，了解这一点是很是很重要的。上面的代码演示了一种常用的解决方案。在方法 m 中，将 this 值赋值给一个变量 self，在签到函数 f 中，可以用 self 代替 this 来引用包含它的对象。</p>

<p>在 ES6 之后，有另外一种解决方案来解决这个问题，将嵌套函数 f 转换成箭头函数，它会正确的继承 this 值：</p>

<pre><code class="language-javascript">const f = () =&gt; {
    this === o  // true, since arrow functions inherit this
};
</code></pre>

<p>函数表达式不像函数声明，声明提前，所以为了让这种解决方案定义的函数可以被调用，需要将 f 函数定义表达式放在方法 m 中，这样它才可以在它被调用时存在。</p>

<p>另外还可以用嵌套函数的 bind() 方法，在指定对象上隐式调用一个新的函数：</p>

<pre><code class="language-javascript">const f = (function() {
    this === o  // true, since we bound this function to the outer this
}).bind(this);
</code></pre>

<p>关于 bind() 方法将在 §8.7.5 中讲解。</p>

<h3 id="toc_11">8.2.3 构造函数调用</h3>

<p>如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用（构造函数调用在 §4.6 和 §6.2.2 节有简单介绍，第9章会对构造函数做更详细的讨论）。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。</p>

<p>如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，JavaScript 构造函数调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号，比如，下面这两行代码就是等价的：</p>

<pre><code class="language-javascript">o = new Object();
o = new Object;
</code></pre>

<p>构造函数调用创建一个新的空对象，这个对象继承自构造函数的 prototype 属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数内可以使用 this 关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式 new o.m() 中，调用上下文并不是 o。</p>

<p>构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会隐式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p>

<h3 id="toc_12">8.2.4 间接调用</h3>

<p>JavaScript 中的函数也是对象，和其他 JavaScript 对象没什么两样，函数对象也可以包含方法。其中的两个方法 call() 和 apply() 可以用来间接地调用函数。两个方法都允许显式指定调用所需的 this 值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。call() 方法使用它自有的实参列表作为函数的实参，apply() 方法则要求以数组的形式传入实参。§8.7.4 节会有关于 call() 和apply () 方法的详细讨论。</p>

<h3 id="toc_13">8.2.5 函数隐式调用</h3>

<p>有各种各样的 JavaScript 语言特性，它们看起来不像函数调用但是却能调用函数。额外小心编写函数时可能会隐式调用，因为在隐式函数调用中 bug、副作用和性能问题都比普通的函数更难诊断和修复。</p>

<p>可能引起函数隐式调用的语言特性包括：</p>

<p>如果一个对象定义了 getter 或者 setter 方法，获取或者设置它的属性值可能调用这些方法。见 §6.10.6 有更多相关描述。</p>

<p>当对象用作一个字符串文本时（例如对象和一个字符串连接），它的 toString() 方法会被调用。同样的，对象用作一个数值型文本时，它的 valueOf() 方法被调用。详见 §3.9.3。</p>

<p>当循环可迭代对象的元素时会产生很多方法调用。第12章介绍了迭代器在函数调用级别如何工作，并演示如何编写方法来定义自己的可迭代类型。</p>

<p>可以伪装在模板字面量中 。在 §14.5 中演示如何在模板字符串中调用函数。</p>

<p>Proxy 对象（在 §14.7 中描述）的行为完全由函数控制。它的任何一个操作都会导致函数调用。</p>

<h2 id="toc_14">8.3 函数的实参和形参</h2>

<p>JavaScript 中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JavaScript 函数调用甚至不检查传入形参的个数。下面几节将会讨论当调用函数时的实参个数和声明的形参个数不匹配时出现的状况，同样介绍了如何显式测试函数实参的类型，以避免非法的实参传入函数。</p>

<h3 id="toc_15">8.3.1 可选形参和默认值</h3>

<p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。所以一些参数设置成可选的是非常实用的。看下面这个例子：</p>

<pre><code class="language-javascript">// Append the names of the enumerable properties of object o to the
// array a, and return a.  If a is omitted, create and return a new array.
function getPropertyNames(o, a) {
    if (a === undefined) a = [];  // If undefined, use a new array
    for(let property in o) a.push(property);
    return a;
}

// getPropertyNames() can be invoked with one or two arguments:
let o = {x: 1}, p = {y: 2, z: 3};  // Two objects for testing
let a = getPropertyNames(o); // a == [&quot;x&quot;]; get o&#39;s properties in a new array
getPropertyNames(p, a);      // a == [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; add p&#39;s properties to it
</code></pre>

<p>第一行代码中可以使用 || 运算符来代替一个 if 语句，这是一种习惯用法：</p>

<pre><code class="language-javascript">a = a || [];
</code></pre>

<p>回忆一下，§4.10.2 介绍了“||”运算符，如果第一个实参是真值的话就返回第一个实参；否则返回第二个实参。在这个场景下，如果作为第二个实参传入任意对象，那么函数就会使用这个对象。如果省略掉第二个实参（或者传递 null 以及其他任何假值），那么就新创建一个空数组，并赋值给 a。</p>

<p>需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参，他们必须显地的将 undefined 传入作为第一个实参 。</p>

<p>在 ES6 之后，可以直接在函数的参数列表中为每个函数参数定义默认值。直接在参数名后面接一个等号再接一个默认值（用于没有实参提供给参数时参数的值）：</p>

<pre><code class="language-javascript">// Append the names of the enumerable properties of object o to the
// array a, and return a.  If a is omitted, create and return a new array.
function getPropertyNames(o, a = []) {
    for(let property in o) a.push(property);
    return a;
}
</code></pre>

<p>默认参数表达式只有在函数调用时进行计算，而不是在它定义时，所以每一次 getPropertyNames() 函数只传一个实参调用时，一个新的空数组被创建并传给参数。<sup>2</sup> 最容易理解的就是参数默认值是常量（或者字面量表达式 [] 和 {}）。但这并不是必须的：举个例子，你可以用变量或者函数调用，计算一个默认参数的值。一个很有趣的情况是，对于有多个参数的函数，可以用前面的参数值来定义后面的参数默认值。</p>

<pre><code class="language-javascript">// This function returns an object representing a rectangle&#39;s dimensions.
// If only width is supplied, make it twice as high as it is wide.
const rectangle = (width, height=width*2) =&gt; ({width, height});
rectangle(1)  // =&gt; { width: 1, height: 2 }
</code></pre>

<p>这段代码描述了箭头函数中的参数默认值。方法函数和其他形式的函数定义也是如此。</p>

<h3 id="toc_16">8.3.2 剩余参数和可变长实参列表</h3>

<p>调用函数时允许传入的实参比函数声明时指定的形参个数少。剩余参数允许相反的情况：它允许我们在调用函数时，传入比型参多任意个数的实参。下面是一个可以传入一个或多个数值型实参的例子，并且返回其中最大的数：</p>

<pre><code class="language-javascript">function max(first=-Infinity, ...rest) {
    let maxValue = first; // Start by assuming the first arg is biggest
    // Then loop through the rest of the arguments, looking for bigger
    for(let n of rest) {
        if (n &gt; maxValue) {
            maxValue = n;
        }
    }
    // Return the biggest
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6)  // =&gt; 1000
</code></pre>

<p>剩余参数由三个 . 开始，必须是函数声明的最后一个参数。调用有剩余参数的函数时，传递的实参先赋值给非剩余参数，然后其余所有的实参（也就是“剩余”实参）存储在一个数组中变成剩余参数的值，最后一点非常重要：在一个函数体中，剩余参数的值总是一个数组。这个数组可能是空的，但是剩余参数永远不会是 undefined。（因此，从不会给剩余参数设置默认值，并且这也是不合法的。）</p>

<p>类似这种函数可以接收任意个数的实参，这种函数也称为“不定实参函数”，这个术语源自古老的C语言。</p>

<p>不要混淆 ... 定义函数的剩余参数和 ... 展开运算符，将在 §8.3.4 描述展开运算符在函数调用中的应用。</p>

<h3 id="toc_17">8.3.3 实参对象</h3>

<p>剩余参数是在 ES6 中加入的概念。在这之前，不定实参函数是用 Arguments 对象实现的：在函数体中，标识符 Arguments 是指向实参对象的引用。Arguments 对象是一个类数组对象（参照 §7.9），这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。下面的 max() 函数就是以前用 Arguments 对象代替剩余参数的例子：</p>

<pre><code class="language-javascript">function max(x) {
    let maxValue = -Infinity;
    // Loop through the arguments, looking for, and remembering, the biggest.
    for(let i = 0; i &lt; arguments.length; i++) {
        if (arguments[i] &gt; maxValue) maxValue = arguments[i];
    }
    // Return the biggest
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6)  // =&gt; 1000
</code></pre>

<p>Arguments 对象可追溯到 JavaScript 的最早时代，并带有一些奇怪的历史包袱，这使得它效率低下且难以优化，尤其是不在严格模式下。可能还会遇到一些代码使用 Arguments 对象，但是在编写新代码时要避免使用，可以用 ... 剩余函数来替代。Arguments 对象还有部分令人遗憾的遗产，在严格模式下，arguments 被视为保留字，不能声明具有该名称的局部变量来定义函数的参数。</p>

<h3 id="toc_18">8.3.4 函数调用时的展开运算符</h3>

<p>当需要单个值时，... 展开运算符用来拆包，或者说将元素从数组（或者其他的任何和迭代对象，例如字符串）中“展开”到上下文。我们已经在 §7.1.2 见到了展开运算符在数组字面量上的使用。展开运算符可以在函数调用中以同样方式使用：</p>

<pre><code class="language-javascript">let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers)  // =&gt; -1
</code></pre>

<p>注意 ... 不是一个真正的运算符，因为它不能通过计算来提供一个值。它是一个可以用在数组字面量和函数调用中的特殊的 JavaScript 语法。</p>

<p>在函数定义和函数调用中使用相同的 ... 语法时，和展开运算符有着相仿的效果。在 §8.3.2 中我们看到函数定义使用 ... 将复数个函数实参合并到一个数组中。剩余参数和展开运算符经常一同使用，就像下面这个函数：</p>

<pre><code class="language-javascript">// This function takes a function and returns a wrapped version
function timed(f) {
    return function(...args) {  // Collect args into a rest parameter array
        console.log(`Entering function ${f.name}`);
        let startTime = Date.now();
        try {
            // Pass all of our arguments to the wrapped function
            return f(...args);  // Spread the args back out again
        }
        finally {
            // Before we return the wrapped return value, print elapsed time.
            console.log(`Exiting ${f.name} after ${Date.now()-startTime}ms`);
        }
    };
}

// Compute the sum of the numbers between 1 and n by brute force
function benchmark(n) {
    let sum = 0;
    for(let i = 1; i &lt;= n; i++) sum += i;
    return sum;
}

// Now invoke the timed version of that test function
timed(benchmark)(1000000) // =&gt; 500000500000; this is the sum of the numbers
</code></pre>

<h3 id="toc_19">8.3.5 实参解构到形参中</h3>

<p>用实参列表调用函数时，实参的值最终赋值给函数定义的参数。函数调用初始化阶段非常像变量赋值。所以我们不必惊讶于可以将解构赋值（见 §3.10.3）用于函数。</p>

<p>如果一个函数的参数带有方括号，就说明函数要给每一个方括号传一个数组。在一个调用进程中，数组实参会被拆包传递给对应的参数。例如，假设我们将 2D 矢量表示为两个数字的数组，其中第一个元素是 X 坐标，第二个元素是 Y 坐标。用这个简单的数据结构，编写下面这个函数计算两个矢量的和：</p>

<pre><code class="language-javascript">function vectorAdd(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
}
vectorAdd([1,2], [3,4])  // =&gt; [4,6]
</code></pre>

<p>如果下面这种方式解构这两个矢量实参，这段代码将更容易理解：</p>

<pre><code class="language-javascript">function vectorAdd([x1,y1], [x2,y2]) { // Unpack 2 arguments into 4 parameters
    return [x1 + x2, y1 + y2];
}
vectorAdd([1,2], [3,4])  // =&gt; [4,6]
</code></pre>

<p>同样，如果定义一个函数时需要对象实参，你能对这个对象进行参数解构。再次实用矢量的例子，这一次，我们用 x 和 y 参数包装成对象来描述矢量：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} by a scalar value
function vectorMultiply({x, y}, scalar) {
    return { x: x*scalar, y: y*scalar };
}
vectorMultiply({x: 1, y: 2}, 2)  // =&gt; {x: 2, y: 4}
</code></pre>

<p>这个例子将一个简单的对象实参解构成两个参数是很简单的，因为参数的名字和我们在对象中使用的属性名是匹配的。当您需要将同一个名称的属性解构为具有不同名称的参数时，语法更加冗长和难懂。下面是一个矢量加法的例子，基于对象矢量的实现：</p>

<pre><code class="language-javascript">function vectorAdd(
    {x: x1, y: y1}, // Unpack 1st object into x1 and y1 params
    {x: x2, y: y2}  // Unpack 2nd object into x2 and y2 params
)
{
    return { x: x1 + x2, y: y1 + y2 };
}
vectorAdd({x: 1, y: 2}, {x: 3, y: 4})  // =&gt; {x: 4, y: 6}
</code></pre>

<p>像 {x:x1, y:y1} 的解构语法棘手的是记住哪一个是属性名哪一个是参数名。牢记解构赋值和解构函数调用的规则，声明的变量或参数在对象字面量中的位置固定。属性名总是在冒号的左边，参数（或变量）名在右边。</p>

<p>可以使用解构参数定义参数默认值。下面是适用于 2D 或 3D 矢量的矢量乘法：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} or {x,y,z} by a scalar value
function vectorMultiply({x, y, z=0}, scalar) {
    return { x: x*scalar, y: y*scalar, z: z*scalar };
}
vectorMultiply({x: 1, y: 2}, 2)  // =&gt; {x: 2, y: 4, z: 0}
</code></pre>

<p>一些语言（像 Python）允许函数的调用者以 <code>name=value</code> 型式指定实参，这在有很多可选实参或者参数列表长到难以记住正确的顺序时是非常方便的。JavaScript 不允许直接这样做，但可以通过解构对象实参到函数参数中。构思一个函数将指定数量的元素从一个数组复制到另一个数组中，可以随意地为每个数组指定起始偏移量。如下有五个可传入参数，其中一些有默认值，并且调用者很难记住参数的顺序来传递实参，可以像这样定义和调用 arraycopy() 方法：</p>

<pre><code class="language-javascript">function arraycopy({from, to=from, n=from.length, fromIndex=0, toIndex=0}) {
    let valuesToCopy = from.slice(fromIndex, fromIndex + n);
    to.splice(toIndex, 0, ...valuesToCopy);
    return to;
}
let a = [1,2,3,4,5], b = [9,8,7,6,5];
arraycopy({from: a, n: 3, to: b, toIndex: 4}) // =&gt; [9,8,7,6,1,2,3,5]
</code></pre>

<p>当解构一个数组，在其被拆包时，可以定义一个剩余参数将其余值放在数组中。 在方括号中的剩余参数和真正的函数中的剩余参数是完全不同的：</p>

<pre><code class="language-javascript">// This function expects an array argument. The first two elements of that
// array are unpacked into the x and y parameters. Any remaining elements
// are stored in the coords array. And any arguments after the first array
// are packed into the rest array.
function f([x, y, ...coords], ...rest) {
    return [x+y, ...rest, ...coords];  // Note: spread operator here
}
f([1, 2, 3, 4], 5, 6)   // =&gt; [3, 5, 6, 3, 4]
</code></pre>

<p>在 ES2018，也可以用剩余参数解构对象。剩余参数是一个没有解构的属性的对象。对象剩余参数经常与对象展开运算符连用，这是 ES2018 的新特性：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} or {x,y,z} by a scalar value, retain other props
function vectorMultiply({x, y, z=0, ...props}, scalar) {
    return { x: x*scalar, y: y*scalar, z: z*scalar, ...props };
}
vectorMultiply({x: 1, y: 2, w: -1}, 2)  // =&gt; {x: 2, y: 4, z: 0, w: -1}
</code></pre>

<p>最后，请记住，除了可以解构实参对象和数组，也可以解构数组对象，对象有数组属性，并且对象还有对象的属性。构思一个将圆表示为具有 x、y、半径和颜色属性的对象的图形代码，颜色属性是一个数组由 RGB 组成。你可以定义一个函数，该函数希望将单个圆对象传递给它，但其解构为六个单独的参数：</p>

<pre><code class="language-javascript">function drawCircle({x, y, radius, color: [r, g, b]}) {
    // Not yet implemented
}
</code></pre>

<p>如果函数实参解构比这更复杂，代码会变得更难读，而不是更简单。有时，显示地对对象属性访问和数组索引会让代码更清晰。</p>

<h3 id="toc_20">8.3.6 实参类型</h3>

<p>JavaScript 方法的形参并未声明类型，在形参传入函数体之前也未做任何类型检查。可以采用语义化的单词来给函数实参命名，并在函数注释给每一个实参详细描述，以此使代码自文本化。</p>

<p>§3.9 已经提到，JavaScript 在必要时会进行类型转换。因此如果函数期 望接收一个字符串实参，而调用函数时传入其他类型的值，所传入的值会在函数体内将其用做字符串的地方转换为字符串类型。所有的原始类型都可以转换为字符串，所有的对象都包含 toString() 方法（尽管不一定有用），所以这种场景下是不会有任何错误的。</p>

<p>然而事情不总是这样，回头看一下刚才提到的 arraycopy() 方法。这个方法期望获得一个或两个实参，并且这些实参的类型错误会导致函数执行失败。除非所写的私有函数只会被附近的代码调用，你应当添加类似的实参类型检查逻辑。因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错，相比而言，逻辑执行时的报错消息不甚清晰且更难处理。下面这个例子中的函数就做了这种类型检查：</p>

<pre><code class="language-javascript">// Return the sum of the elements an iterable object a.
// The elements of a must all be numbers.
function sum(a) {
    let total = 0;
    for(let element of a) { // Throws TypeError if a is not iterable
        if (typeof element !== &quot;number&quot;) {
            throw new TypeError(&quot;sum(): elements must be numbers&quot;);
        }
        total += element;
    }
    return total;
}
sum([1,2,3])    // =&gt; 6
sum(1, 2, 3);   // !TypeError: 1 is not iterable
sum([1,2,&quot;3&quot;]); // !TypeError: element 2 is not a number
</code></pre>

<h2 id="toc_21">8.4 函数作为值</h2>

<p>函数可以定义，也可以调用，这是函数最重要的特性。函数定义和调用是  JavaScript 的词法特性，对于其他大多数编程语言来说亦是如此。然而在 JavaScript 中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。<sup>3</sup></p>

<p>To understand how functions can be JavaScript data as well as JavaScript syntax, consider this function definition:</p>

<blockquote>
<p>为了便于理解 JavaScript 中的函数是如何用做 Javascript 数据以及 JavaScript 语法的，来看一下这样一个函数定义：</p>
</blockquote>

<pre><code class="language-javascript">function square(x) { return x*x; }
</code></pre>

<p>这个定义创建一个新的函数对象，并将其赋值给变量 square。函数的名字实际上是无形的，它（square）仅仅是变量的名称，这个变量是函数对象的引用。函数还可以赋值给其他的变量，并且仍可以正常工作：</p>

<pre><code class="language-javascript">let s = square;  // Now s refers to the same function that square does
square(4)        // =&gt; 16
s(4)             // =&gt; 16
</code></pre>

<p>除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性。当函数作为对象的属性调用时，函数就称为“方法”：</p>

<pre><code class="language-javascript">let o = {square: function(x) { return x*x; }}; // An object literal
let y = o.square(16);                          // y == 256
</code></pre>

<p>函数甚至不需要带名字，就像把它们赋值给数组元素：</p>

<pre><code class="language-javascript">let a = [x =&gt; x*x, 20]; // An array literal
a[0](a[1])              // =&gt; 400
</code></pre>

<p>上面的例子看起来很奇怪，但的确是合法的函数调用表达式！</p>

<p>举一个例子来说明将函数当作值来对待的益处，考虑下 Array.sort() 方法。这个方法用来对数组元素进行排序。因为排序的规则有很多（基于数值大小、字母表顺序、日期大小、从小到大、从大到小等），sort() 方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单：对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。这个函数参数使得 Array.sort() 具有更完美的通用性和无限可扩展性，它可以对任何类型的数据进行任意排序。§7.8.6 有示例代码。</p>

<p>例 8-1 展示了将函数用做值时的一些例子，这段代码可能会难读一些，但注释解释了代码的具体含义：</p>

<p>例 8-1：用函数做值</p>

<pre><code class="language-javascript">// We define some simple functions here
function add(x,y) { return x + y; }
function subtract(x,y) { return x - y; }
function multiply(x,y) { return x * y; }
function divide(x,y) { return x / y; }

// Here&#39;s a function that takes one of the preceding functions
// as an argument and invokes it on two operands
function operate(operator, operand1, operand2) {
    return operator(operand1, operand2);
}

// We could invoke this function like this to compute the value (2+3) + (4*5):
let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));

// For the sake of the example, we implement the simple functions again,
// this time within an object literal;
const operators = {
    add:      (x,y) =&gt; x+y,
    subtract: (x,y) =&gt; x-y,
    multiply: (x,y) =&gt; x*y,
    divide:   (x,y) =&gt; x/y,
    pow:      Math.pow  // This works for predefined functions too
};

// This function takes the name of an operator, looks up that operator
// in the object, and then invokes it on the supplied operands. Note
// the syntax used to invoke the operator function.
function operate2(operation, operand1, operand2) {
    if (typeof operators[operation] === &quot;function&quot;) {
        return operators[operation](operand1, operand2);
    }
    else throw &quot;unknown operator&quot;;
}

operate2(&quot;add&quot;, &quot;hello&quot;, operate2(&quot;add&quot;, &quot; &quot;, &quot;world&quot;)) // =&gt; &quot;hello world&quot;
operate2(&quot;pow&quot;, 10, 2)  // =&gt; 100
</code></pre>

<h3 id="toc_22">8.4.1 自定义函数属性</h3>

<p>JavaScript 中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。比如，假设你想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，为了做到这一点，函数必须能够跟踪它每次返回的值，而且这些值的信息需要在不同的函数调过程中持久化。可以将这些信息存放到全局变量中，但这并不是必需的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中，下面这个例子就实现了这样一个函数，每次调用函数都会返回一个唯一的整数：</p>

<pre><code class="language-javascript">// Initialize the counter property of the function object.
// Function declarations are hoisted so we really can
// do this assignment before the function declaration.
uniqueInteger.counter = 0;

// This function returns a different integer each time it is called.
// It uses a property of itself to remember the next value to be returned.
function uniqueInteger() {
    return uniqueInteger.counter++;  // Return and increment counter property
}
uniqueInteger()  // =&gt; 0
uniqueInteger()  // =&gt; 1
</code></pre>

<p>来看另外一个例子，下面这个函数 factorial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：</p>

<pre><code class="language-javascript">// Compute factorials and cache results as properties of the function itself.
function factorial(n) {
    if (Number.isInteger(n) &amp;&amp; n &gt; 0) {           // Positive integers only
        if (!(n in factorial)) {                  // If no cached result
            factorial[n] = n * factorial(n-1);    // Compute and cache it
        }
        return factorial[n];                      // Return the cached result
    } else {
        return NaN;                               // If input was bad
    }
}
factorial[1] = 1;  // Initialize the cache to hold this base case.
factorial(6)  // =&gt; 720
factorial[5]  // =&gt; 120; the call above caches this value
</code></pre>

<h2 id="toc_23">8.5 函数作为命名空间</h2>

<p>变量声明在函数内对于函数体外是不可见的。因此，有时定义函数作为临时命名空间非常有用，您可以在其中定义变量而不弄乱全局命名空间。</p>

<p>比如，假设你写了一段 JavaScript 模块代码，这段代码将要用在不同的 JavaScript 程序中（对于客户端 JavaScript 来讲通常是用在各种各样的网页中）。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量：</p>

<pre><code class="language-javascript">function chunkNamespace() {
    // Chunk of code goes here
    // Any variables defined in the chunk are local to this function
    // instead of cluttering up the global namespace.
}
chunkNamespace();  // But don&#39;t forget to invoke the function!
</code></pre>

<p>这段代码仅仅定义了一个单独的全局变量：名为 chunkNamespace 的函数。如果还是太麻烦，可以用一个单独的表达式定义一个匿名函数并调用它：</p>

<pre><code class="language-javascript">(function() {  // chunkNamespace() function rewritten as an unnamed expression.
    // Chunk of code goes here
}());          // End the function literal and invoke it now.
</code></pre>

<p>这种定义匿名函数并立即在单个表达式中调用它的写法非常常见，并给它起了个名字“匿名调用函数表达式”。注意上面代码的圆括号的用法，function 之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript 解释器会试图将关键字 function 解析为函数声明语句。使用圆括号 JavaScript 解释器才会正确地将其解析为函数定义表达式。使用前导括号也有助于人类阅读时区分函数定义是立即执行还是供以后使用。</p>

<p>函数用作命名空间很常用，在命名空间函数中定义一个或多个函数使用其中的变量，然后将他们作为函数命名空间的返回值。这样的函数称为闭包，它们是下一节的主题。</p>

<h2 id="toc_24">8.6 闭包</h2>

<p>和其他大多数现代编程语言一样，JavaScript 也采用词法作用域。也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须包括对函数定义出现的作用域的引用。将函数对象可和作用域相互关联起来（一对变量的绑定），函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p>

<p>从技术的角度讲，所有的 JavaScript 函数都是闭包，但是大多数函数调用和定义在同一个作用域内，通常不会注意这里有涉及到闭包。当调用函数不和其定义处于同一作用域内时，事情就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在 JavaScript 中非常常见。当你第一次碰到闭包时可能会觉得非常让人费解，一旦你理解掌握了闭包之后，就能非常自如地使用它了，了解这一点至关重要。</p>

<p>理解闭包首先要了解嵌套函数的词法作用域规则。看一下这段代码：</p>

<pre><code class="language-javascript">let scope = &quot;global scope&quot;;          // A global variable
function checkscope() {
    let scope = &quot;local scope&quot;;       // A local variable
    function f() { return scope; }   // Return the value in scope here
    return f();
}
checkscope()                         // =&gt; &quot;local scope&quot;
</code></pre>

<p>checkscope() 函数声明了一个局部变量，然后定义并执行了一个函数 f() ，函数 f() 返回了这个变量的值，最后将函数 f() 的执行结果返回。你应当非常清楚为什么调用 checkscope() 会返回 local scope。现在我们对这段代码做一点改动。你知道这段代码返回什么吗？</p>

<pre><code class="language-javascript">let scope = &quot;global scope&quot;;          // A global variable
function checkscope() {
    let scope = &quot;local scope&quot;;       // A local variable
    function f() { return scope; }   // Return the value in scope here
    return f;
}
let s = checkscope()();              // What does this return?
</code></pre>

<p>在这段代码中，我们将函数内的一对圆括号移动到了 checkscope() 之后。checkscope() 现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？</p>

<p>回想一下词法作用域的基本规则：JavaScript 函数的执行用到了作用域，这个作用域是函数定义的时候创建的。嵌套的函数 f() 定义在变量 scope 绑定的值是“local scope”的作用域里，这个绑定无论 f 函数在何处调用都依然有效。因此最后一行代码返回“local scope”，而不是“global scope”。简言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到它们的外部函数所绑定的局部变量（和参数）。</p>

<p>在 §8.4.1 中定义了 uniqueInteger() 函数，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致 uniquenterger() 函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用做私有状态。下面是如何用立即调用函数表达式重写 uniqueInteger() 来定义命名空间和闭包来保持其状态私有化：</p>

<pre><code class="language-javascript">let uniqueInteger = (function() {  // Define and invoke
    let counter = 0;               // Private state of function below
    return function() { return counter++; };
}());
uniqueInteger()  // =&gt; 0
uniqueInteger()  // =&gt; 1
</code></pre>

<p>你需要仔细阅读这段代码才能理解其含义。粗略来看，第一行代码看起来像将函数赋值给一个变量 uniqueInteger，实际上，这段代码定义了一个立即调用的函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量 uniqueInteger。现在，我们来看函数体，这个函数的返回值是另外一个函数。这是一个嵌套的函数，我们将它赋值给变量 uniqueInteger。嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的 counter 变量。当外部函数返回之后，其他任何代码都无法访问 counter 变量：只有内部的函数才能访问到它。</p>

<p>像 counter 一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域，看一下这段代码：</p>

<pre><code class="language-javascript">function counter() {
    let n = 0;
    return {
        count: function() { return n++; },
        reset: function() { n = 0; }
    };
}

let c = counter(), d = counter();   // Create two counters
c.count()                           // =&gt; 0
d.count()                           // =&gt; 0: they count independently
c.reset();                          // reset() and count() methods share state
c.count()                           // =&gt; 0: because we reset c
d.count()                           // =&gt; 1: d was not reset
</code></pre>

<p>counter() 函数返回了一个“计数器”对象，这个对象包含两个方法：count() 返回下一个整数，reset() 重置内部状态。首先要理解，这两个方法都可以访问私有变量n。再者，每次调用 counter() 都会创建一个新的作用域链和一个新的私有变量。因此，如果调用 counter() 两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的 count() 或 reset() 不会影响到另外一个对象。</p>

<p>从技术角度看，其实可以将这个闭包合并为属性存取器方法 getter 和 setter。下面这段代码所示的 counter() 函数的版本是 §6.10.6 中代码的变种，所不同的是，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现：</p>

<pre><code class="language-javascript">function counter(n) {  // Function argument n is the private variable
    return {
        // Property getter method returns and increments private counter var.
        get count() { return n++; },
        // Property setter doesn&#39;t allow the value of n to decrease
        set count(m) {
            if (m &gt; n) n = m;
            else throw Error(&quot;count can only be set to a larger value&quot;);
        }
    };
}

let c = counter(1000);
c.count            // =&gt; 1000
c.count            // =&gt; 1001
c.count = 2000;
c.count            // =&gt; 2000
c.count = 2000;    // !Error: count can only be set to a larger value
</code></pre>

<p>需要注意的是，这个版本的 counter() 函数并未声明局部变量，而只是使用参数 n 来保存私有状态并与属性存取器方法共享。这样的话，调用 counter() 的函数就可以指定私有变量的初始值了。</p>

<p>例 8-2是这种使用闭包技术来共享的私有状态的通用做法。这个例子定义了 addPrivateProperty() 函数，这个函数定义了一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值。它将这些嵌套函数添加为所指定对象的方法：</p>

<p>例 8-2：利用闭包实现的私有属性存取器方法</p>

<pre><code class="language-javascript">// This function adds property accessor methods for a property with
// the specified name to the object o. The methods are named get&lt;name&gt;
// and set&lt;name&gt;. If a predicate function is supplied, the setter
// method uses it to test its argument for validity before storing it.
// If the predicate returns false, the setter method throws an exception.
//
// The unusual thing about this function is that the property value
// that is manipulated by the getter and setter methods is not stored in
// the object o. Instead, the value is stored only in a local variable
// in this function. The getter and setter methods are also defined
// locally to this function and therefore have access to this local variable.
// This means that the value is private to the two accessor methods, and it
// cannot be set or modified except through the setter method.
function addPrivateProperty(o, name, predicate) {
    let value;  // This is the property value

    // The getter method simply returns the value.
    o[`get${name}`] = function() { return value; };

    // The setter method stores the value or throws an exception if
    // the predicate rejects the value.
    o[`set${name}`] = function(v) {
        if (predicate &amp;&amp; !predicate(v)) {
            throw new TypeError(`set${name}: invalid value ${v}`);
        } else {
            value = v;
        }
    };
}

// The following code demonstrates the addPrivateProperty() method.
let o = {};  // Here is an empty object

// Add property accessor methods getName and setName()
// Ensure that only string values are allowed
addPrivateProperty(o, &quot;Name&quot;, x =&gt; typeof x === &quot;string&quot;);

o.setName(&quot;Frank&quot;);       // Set the property value
o.getName()               // =&gt; &quot;Frank&quot;
o.setName(0);             // !TypeError: try to set a value of the wrong type
</code></pre>

<p>我们已经看到了很多例子，在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包，了解这一点也很重要。看一下下面这段代码：</p>

<pre><code class="language-javascript">// This function returns a function that always returns v
function constfunc(v) { return () =&gt; v; }

// Create an array of constant functions:
let funcs = [];
for(var i = 0; i &lt; 10; i++) funcs[i] = constfunc(i);

// The function at array element 5 returns the value 5.
funcs[5]()    // =&gt; 5
</code></pre>

<p>这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：</p>

<pre><code class="language-javascript">// Return an array of functions that return the values 0-9
function constfuncs() {
    let funcs = [];
    for(var i = 0; i &lt; 10; i++) {
        funcs[i] = () =&gt; i;
    }
    return funcs;
}

let funcs = constfuncs();
funcs[5]()    // =&gt; 10; Why doesn&#39;t this return 5?
</code></pre>

<p>上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量 i。当 constfuncs() 返回时，变量 i 的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域都是“活动的”，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照。从根本上讲，这里的问题是，使用 var 声明的变量，它的定义贯穿整个函数。我们的 for 循环使用 var i 声明循环变量，因此变量 i 在整个函数中都有定义，而不是更狭义地作用于循环的主体。该代码演示了 ES6 之前的常见 Bug 类别，但在 ES6 中引入块级变量作用域解决了这个问题。如果我们只是用 let 或 const 替换 var， 那么问题就消失了。由于 let 和 const 是块级作用域，因此循环的每个迭代都定义了一个独立于所有其他迭代的作用域，并且每个作用域都有其自己的独立绑定 i。</p>

<p>书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，而不是变量。正如之前讨论的，箭头函数从包含它们的函数中继承 this 值，但是用 function 关键字定义的函数不是。所以如果写一个闭包需要使用包含它的函数的 this 值，要在闭包返回之前使用箭头函数或者用调用 bind()，或者将 this 值赋值给一个变量，这样你的闭包会继承它：</p>

<pre><code class="language-javascript">const self = this;  // Make the this value available to nested functions
</code></pre>

<h2 id="toc_25">8.7 函数属性、方法、和构造函数</h2>

<p>我们看到在 JavaScript 程序中，函数是值。对函数执行 typeof 运算会返回字符串“function”，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用 Function() 构造函数来创建新的函数对象。接下来几节就会着重介绍函数 length、name 和 prototype 属性；call()、 apply()、 bind() 和 toString() 方法；以及 Function() 构造函数。</p>

<h3 id="toc_26">8.7.1 length 属性</h3>

<p>函数的只读属性 length 指定函数参数个数--声明在其参数列表中的参数个数，大多数函数期望的实参个数。如果一个函数有一个剩余函数，它的参数个数不被计算入 length 属性。（经测试，可选参数也不计算 length。）</p>

<h3 id="toc_27">8.7.2 name 属性</h3>

<p>如果使用名称定义函数，只读属性 name 指定函数定义时用的名称，或未命名函数表达式在首次创建时分配给的变量或属性的名称。此属性在编写调试或错误消息时很有用。</p>

<h3 id="toc_28">8.7.3 prototype 属性</h3>

<p>所有函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做原型对象。每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。§6.2.3 讨论了原型和 prototype 属性，在第9章里会有进一步讨论。</p>

<h3 id="toc_29">8.7.4 call() 和 apply() 方法</h3>

<p>我们可以将 call() 和 apply () 看做是某个对象的方法，通过调用方法的形式来间接调用（见 §8.2.4）函数。call() 和 apply() 的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内变成 this 关键字的值。要想以对象 o 的方法来调用函数 f()（没有实参传递），可以这样使用 call() 和 apply()：</p>

<pre><code class="language-javascript">f.call(o);
f.apply(o);
</code></pre>

<p>每行代码和下面代码的功能类似（假设对象 o 中预先不存在名为 m 的属性）:</p>

<pre><code class="language-javascript">o.m = f;     // Make f a temporary method of o.
o.m();       // Invoke it, passing no arguments.
delete o.m;  // Remove the temporary method.
</code></pre>

<p>不要忘了，箭头函数从它定义的位置的上下文继承 this 值。这不能被 call() 和 apply() 方法重写。如果通过箭头函数调用它俩任何一个方法，第一个实参实际上都被忽略。</p>

<p>对于 call() 来说，除了第一个作为调用上下文实参，之后的所有实参就是要传入待调用函数的值（并且，这部分实参对于箭头函数来说不被忽略）。比如，以对象 o 的方法的形式调用函数 f()，并传入两个数，可以使用这样的代码：</p>

<pre><code class="language-javascript">f.call(o, 1, 2);
</code></pre>

<p>apply() 方法和 call() 类似，但传入实参的形式和 call() 有所不同，它的实参都放入一个数组中：</p>

<pre><code class="language-javascript">f.apply(o, [1,2]);
</code></pre>

<p>如果一个函数的实参可以是任意数量，用 apply() 方法允许你传入的参数数组可以是任意长度的。在 ES6 之后，我们可以用展开运算符，但是在 ES5 的代码中你可以看到这种情况是用 apply() 来替代。比如，不用展开运算符找出数组中最大的数值元素，调用 Math.max() 方法的时候可以给  apply() 传入一个包含任意个元素的数组：</p>

<pre><code class="language-javascript">let biggest = Math.max.apply(Math, arrayOfNumbers);
</code></pre>

<p>下面定义的 trace() 与 §8.3.4 中定义的 timed() 函数类似，但是它对方法有效而不是函数。它使用 apply() 方法而不是展开运算符，通过这样做，它能够调用具有相同参数和与被包装方法相同的 this 值的包装方法。</p>

<pre><code class="language-javascript">// Replace the method named m of the object o with a version that logs
// messages before and after invoking the original method.
function trace(o, m) {
    let original = o[m];         // Remember original method in the closure.
    o[m] = function(...args) {   // Now define the new method.
        console.log(new Date(), &quot;Entering:&quot;, m);      // Log message.
        let result = original.apply(this, args);      // Invoke original.
        console.log(new Date(), &quot;Exiting:&quot;, m);       // Log message.
        return result;                                // Return result.
    };
}
</code></pre>

<h3 id="toc_30">8.7.5 bind() 方法</h3>

<p>The primary purpose of bind() is to bind a function to an object. When you invoke the bind() method on a function f and pass an object o, the method returns a new function. Invoking the new function (as a function) invokes the original function f as a method of o. Any arguments you pass to the new function are passed to the original function. For example:</p>

<blockquote>
<p>bind() 方法的主要作用就是将函数绑定至某个对象。当在函数 f() 上调用 bind() 方法并传入一个对象 o 作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数 f() 当做 o 的方法来调用。传入新函数的任何实参都将传入原始函数，比如：</p>
</blockquote>

<pre><code class="language-javascript">function f(y) { return this.x + y; } // This function needs to be bound
let o = { x: 1 };                    // An object we&#39;ll bind to
let g = f.bind(o);                   // Calling g(x) invokes f() on o
g(2)                                 // =&gt; 3
let p = { x: 10, g };                // Invoke g() as a method of this object
p.g(2)                               // =&gt; 3: g is still bound to o, not p.
</code></pre>

<p>箭头函数从它们定义的上下文中继承 this 值，并且其不可被 bind() 方法重写，所以如果上面的代码用箭头函数定义函数 f()，这个绑定不会生效。调用 bind() 方法的最常用场景是让不带箭头的函数的行为像箭头函数一样，所以实际上绑定箭头函数的 this 局限性并不是一个问题。</p>

<p>但是 bind() 方法不仅仅是将函数绑定至一个对象。它还附带一些其他应用：除了第一个实参之外，传入 bind() 的实参也会绑定至 this 值。这个附带的应用在箭头函数上也同样生效。是一种常见的函数式编程技术，有时也被称为“柯里化”。参照下面这个例子中的 bind() 方法的实现：</p>

<pre><code class="language-javascript">let sum = (x,y) =&gt; x + y;      // Return the sum of 2 args
let succ = sum.bind(null, 1);  // Bind the first argument to 1
succ(2)  // =&gt; 3: x is bound to 1, and we pass 2 for the y argument

function f(y,z) { return this.x + y + z; }
let g = f.bind({x: 1}, 2);     // Bind this and y
g(3)     // =&gt; 6: this.x is bound to 1, y is bound to 2 and z is 3
</code></pre>

<p>bind() 返回函数的名称属性是调用 bind() 的函数的名称属性前面加上前缀为单词&quot;bound&quot;。</p>

<h3 id="toc_31">8.7.6 toString() 方法</h3>

<p>和所有的 JavaScript 对象一样，函数也有 toString() 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的 toString() 方法的实现都返回函数的完整源码。内置函数往往返回一个类似”[native code]”的字符串作为函数体。</p>

<h3 id="toc_32">8.7.7 The Function() Constructor</h3>

<p>因为函数是对象，有一个 Function() 构造函数可以用来创建新的函数：</p>

<pre><code class="language-javascript">const f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);
</code></pre>

<p>这一行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价：</p>

<pre><code class="language-javascript">const f = function(x, y) { return x*y; };
</code></pre>

<p>Function() 构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体——即可。</p>

<p>注意，Function() 构造函数并不需要通过传入实参以指定函数名。就像函数字面量一样，Function() 构造函数创建一个匿名函数。</p>

<p>关于 Function() 构造函数有几点需要特别注意：</p>

<p>Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数。</p>

<p>每次调用 Function() 构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。</p>

<p>最后一点，也是关于 Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，如下面代码所示：</p>

<pre><code class="language-javascript">let scope = &quot;global&quot;;
function constructFunction() {
    let scope = &quot;local&quot;;
    return new Function(&quot;return scope&quot;);  // Doesn&#39;t capture local scope!
}
// This line returns &quot;global&quot; because the function returned by the
// Function() constructor does not use the local scope.
constructFunction()()  // =&gt; &quot;global&quot;
</code></pre>

<p>我们可以将 Function() 构造函数认为是在全局作用域中执行的 eval()（见  §4.12.2），eval() 可以在自己的私有作用域内定义新变量和函数，Function() 构造函数在实际编程过程中很少会用到。</p>

<h2 id="toc_33">8.8 Functional Programming</h2>

<p>JavaScript is not a functional programming language like Lisp or Haskell, but the fact that JavaScript can manipulate functions as objects means that we can use functional programming techniques in JavaScript. Array methods such as map() and reduce() lend themselves particularly well to a functional programming style. The sections that follow demonstrate techniques for functional programming in JavaScript. They are intended as a mind-expanding exploration of the power of JavaScript’s functions, not as a prescription for good programming style.</p>

<blockquote>
<p>和 Lisp、Haskell 不同，JavaScript 并非函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术。数组方法诸如 map() 和 reduce() 就可以非常适合用于函数式编程风格。接下来的几节将会着重介绍 JavaScript 中的函数式编程技术。函数式编程旨在扩展对 JavaScript 函数功能功能的探索，而不是为了良好的编程风格。</p>
</blockquote>

<h3 id="toc_34">8.8.1 Processing Arrays with Functions</h3>

<p>Suppose we have an array of numbers and we want to compute the mean and standard deviation of those values. We might do that in nonfunctional style like this:</p>

<blockquote>
<p>假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样：</p>
</blockquote>

<pre><code class="language-javascript">let data = [1,1,3,5,5];  // This is our array of numbers

// The mean is the sum of the elements divided by the number of elements
let total = 0;
for(let i = 0; i &lt; data.length; i++) total += data[i];
let mean = total/data.length;  // mean == 3; The mean of our data is 3

// To compute the standard deviation, we first sum the squares of
// the deviation of each element from the mean.
total = 0;
for(let i = 0; i &lt; data.length; i++) {
    let deviation = data[i] - mean;
    total += deviation * deviation;
}
let stddev = Math.sqrt(total/(data.length-1));  // stddev == 2
</code></pre>

<p>We can perform these same computations in concise functional style using the array methods map() and reduce() like this (see §7.8.1 to review these methods):</p>

<blockquote>
<p>可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其简洁（参照 §7.8.1 来查看这些方法）：</p>
</blockquote>

<pre><code class="language-javascript">// First, define two simple functions
const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;

// Then use those functions with Array methods to compute mean and stddev
let data = [1,1,3,5,5];
let mean = data.reduce(sum)/data.length;  // mean == 3
let deviations = data.map(x =&gt; x-mean);
let stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1));
stddev  // =&gt; 2
</code></pre>

<p>This new version of the code looks quite different than the first one, but it is still invoking methods on objects, so it has some object-oriented conventions remaining. Let’s write functional versions of the map() and reduce() methods:</p>

<blockquote>
<p>这个新版本的代码看起来跟第一版有很大不同，但是它仍然调用对象的方法，所以它还是面向对象编程。接下来用函数版本的 map() 和 reduce() 方法：</p>
</blockquote>

<pre><code class="language-javascript">const map = function(a, ...args) { return a.map(...args); };
const reduce = function(a, ...args) { return a.reduce(...args); };
</code></pre>

<p>With these map() and reduce() functions defined, our code to compute the mean and standard deviation now looks like this:</p>

<blockquote>
<p>用这两个函数定义了 map() 和 reduce()，我们计算平均值和标准差变成这样：</p>
</blockquote>

<pre><code class="language-javascript">const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;

let data = [1,1,3,5,5];
let mean = reduce(data, sum)/data.length;
let deviations = map(data, x =&gt; x-mean);
let stddev = Math.sqrt(reduce(map(deviations, square), sum)/(data.length-1));
stddev  // =&gt; 2
</code></pre>

<h3 id="toc_35">8.8.2 Higher-Order Functions</h3>

<p>A higher-order function is a function that operates on functions, taking one or more functions as arguments and returning a new function. Here is an example:</p>

<blockquote>
<p>所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数。来看这个例子：</p>
</blockquote>

<pre><code class="language-javascript">// This higher-order function returns a new function that passes its
// arguments to f and returns the logical negation of f&#39;s return value;
function not(f) {
    return function(...args) {             // Return a new function
        let result = f.apply(this, args);  // that calls f
        return !result;                    // and negates its result.
    };
}

const even = x =&gt; x % 2 === 0; // A function to determine if a number is even
const odd = not(even);         // A new function that does the opposite
[1,1,3,5,5].every(odd)         // =&gt; true: every element of the array is odd
</code></pre>

<p>This not() function is a higher-order function because it takes a function argument and returns a new function. As another example, consider the mapper() function that follows. It takes a function argument and returns a new function that maps one array to another using that function. This function uses the map() function defined earlier, and it is important that you understand how the two functions are different:</p>

<blockquote>
<p>上面的 not() 函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的 mapper() 函数，它也是接收一个函数作为实参，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的 map() 函数，但要首先理解这两个函数有哪里不 同，理解这一点至关重要：</p>
</blockquote>

<pre><code class="language-javascript">// Return a function that expects an array argument and applies f to
// each element, returning the array of return values.
// Contrast this with the map() function from earlier.
function mapper(f) {
    return a =&gt; map(a, f);
}

const increment = x =&gt; x+1;
const incrementAll = mapper(increment);
incrementAll([1,2,3])  // =&gt; [2,3,4]
</code></pre>

<p>Here is another, more general, example that takes two functions, f and g, and returns a new function that computes f(g()):</p>

<blockquote>
<p>这里是一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())：</p>
</blockquote>

<pre><code class="language-javascript">// Return a new function that computes f(g(...)).
// The returned function h passes all of its arguments to g, then passes
// the return value of g to f, then returns the return value of f.
// Both f and g are invoked with the same this value as h was invoked with.
function compose(f, g) {
    return function(...args) {
        // We use call for f because we&#39;re passing a single value and
        // apply for g because we&#39;re passing an array of values.
        return f.call(this, g.apply(this, args));
    };
}

const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;
compose(square, sum)(2,3)  // =&gt; 25; the square of the sum
</code></pre>

<p>The partial() and memoize() functions defined in the sections that follow are two more important higher-order functions.</p>

<blockquote>
<p>本章后续几节中定义了 partial() 和 memoize() 函数，这两个函数是非常重要的高阶函数。</p>
</blockquote>

<h3 id="toc_36">8.8.3 Partial Application of Functions</h3>

<p>The bind() method of a function f (see §8.7.5) returns a new function that invokes f in a specified context and with a specified set of arguments. We say that it binds the function to an object and partially applies the arguments. The bind() method partially applies arguments on the left—that is, the arguments you pass to bind() are placed at the start of the argument list that is passed to the original function. But it is also possible to partially apply arguments on the right:</p>

<blockquote>
<p>函数 f()（见 §8.7.5）的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数“绑定至”对象并传入一部分参数。bind() 方法只是将实参放在（完整实参列表的）左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在（完整实参列表的）右侧：</p>
</blockquote>

<pre><code class="language-javascript">// The arguments to this function are passed on the left
function partialLeft(f, ...outerArgs) {
    return function(...innerArgs) { // Return this function
        let args = [...outerArgs, ...innerArgs]; // Build the argument list
        return f.apply(this, args);              // Then invoke f with it
    };
}

// The arguments to this function are passed on the right
function partialRight(f, ...outerArgs) {
    return function(...innerArgs) {  // Return this function
        let args = [...innerArgs, ...outerArgs]; // Build the argument list
        return f.apply(this, args);              // Then invoke f with it
    };
}

// The arguments to this function serve as a template. Undefined values
// in the argument list are filled in with values from the inner set.
function partial(f, ...outerArgs) {
    return function(...innerArgs) {
        let args = [...outerArgs]; // local copy of outer args template
        let innerIndex=0;          // which inner arg is next
        // Loop through the args, filling in undefined values from inner args
        for(let i = 0; i &lt; args.length; i++) {
            if (args[i] === undefined) args[i] = innerArgs[innerIndex++];
        }
        // Now append any remaining inner arguments
        args.push(...innerArgs.slice(innerIndex));
        return f.apply(this, args);
    };
}

// Here is a function with three arguments
const f = function(x,y,z) { return x * (y - z); };
// Notice how these three partial applications differ
partialLeft(f, 2)(3,4)         // =&gt; -2: Bind first argument: 2 * (3 - 4)
partialRight(f, 2)(3,4)        // =&gt;  6: Bind last argument: 3 * (4 - 2)
partial(f, undefined, 2)(3,4)  // =&gt; -6: Bind middle argument: 3 * (2 - 4)
</code></pre>

<p>These partial application functions allow us to easily define interesting functions out of functions we already have defined. Here are some examples:</p>

<blockquote>
<p>利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数，参照下面这个例子：</p>
</blockquote>

<pre><code class="language-javascript">const increment = partialLeft(sum, 1);
const cuberoot = partialRight(Math.pow, 1/3);
cuberoot(increment(26))  // =&gt; 3
</code></pre>

<p>Partial application becomes even more interesting when we combine it with other higher-order functions. Here, for example, is a way to define the preceding not() function just shown using composition and partial application:</p>

<blockquote>
<p>当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了 not() 函数，它用到了刚才提到的不完全调用：</p>
</blockquote>

<pre><code class="language-javascript">const not = partialLeft(compose, x =&gt; !x);
const even = x =&gt; x % 2 === 0;
const odd = not(even);
const isNumber = not(isNaN);
odd(3) &amp;&amp; isNumber(2)  // =&gt; true
</code></pre>

<p>We can also use composition and partial application to redo our mean and standard deviation calculations in extreme functional style:</p>

<blockquote>
<p>我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程：</p>
</blockquote>

<pre><code class="language-javascript">// sum() and square() functions are defined above. Here are some more:
const product = (x,y) =&gt; x*y;
const neg = partial(product, -1);
const sqrt = partial(Math.pow, undefined, .5);
const reciprocal = partial(Math.pow, undefined, neg(1));

// Now compute the mean and standard deviation.
let data = [1,1,3,5,5];   // Our data
let mean = product(reduce(data, sum), reciprocal(data.length));
let stddev = sqrt(product(reduce(map(data,
                                     compose(square,
                                             partial(sum, neg(mean)))),
                                 sum),
                          reciprocal(sum(data.length,neg(1)))));
[mean, stddev]  // =&gt; [3, 2]
</code></pre>

<p>Notice that this code to compute mean and standard deviation is entirely function invocations; there are no operators involved, and the number of parentheses has grown so large that this JavaScript is beginning to look like Lisp code. Again, this is not a style that I advocate for JavaScript programming, but it is an interesting exercise to see how deeply functional JavaScript code can be.</p>

<blockquote>
<p>注意，这段代码计算平均值和标准差完全是函数调用;没有涉及运算符，并且括号的数量增长如此之大让 JavaScript 开始看起来像 Lisp 代码。同样，这不是我提倡的 JavaScript 编程风格，但它是一个有趣的练习，看看 JavaScript 代码的功能有多深。</p>
</blockquote>

<h3 id="toc_37">8.8.4 Memoization</h3>

<p>In §8.4.1, we defined a factorial function that cached its previously computed results. In functional programming, this kind of caching is called memoization. The code that follows shows a higher-order function, memoize(), that accepts a function as its argument and returns a memoized version of the function:</p>

<blockquote>
<p>在 §8.4.1 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数:</p>
</blockquote>

<pre><code class="language-javascript">// Return a memoized version of f.
// It only works if arguments to f all have distinct string representations.
function memoize(f) {
    const cache = new Map();  // Value cache stored in the closure.

    return function(...args) {
        // Create a string version of the arguments to use as a cache key.
        let key = args.length + args.join(&quot;+&quot;);
        if (cache.has(key)) {
            return cache.get(key);
        } else {
            let result = f.apply(this, args);
            cache.set(key, result);
            return result;
        }
    };
}
</code></pre>

<p>The memoize() function creates a new object to use as the cache and assigns this object to a local variable so that it is private to (in the closure of) the returned function. The returned function converts its arguments array to a string and uses that string as a property name for the cache object. If a value exists in the cache, it returns it directly. Otherwise, it calls the specified function to compute the value for these arguments, caches that value, and returns it. Here is how we might use memoize():</p>

<blockquote>
<p>memorize() 函数创建一个新的对象，这个对象被当做缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用 memorize()：</p>
</blockquote>

<pre><code class="language-javascript">// Return the Greatest Common Divisor of two integers using the Euclidian
// algorithm: http://en.wikipedia.org/wiki/Euclidean_algorithm
function gcd(a,b) {  // Type checking for a and b has been omitted
    if (a &lt; b) {           // Ensure that a &gt;= b when we start
        [a, b] = [b, a];   // Destructuring assignment to swap variables
    }
    while(b !== 0) {       // This is Euclid&#39;s algorithm for GCD
        [a, b] = [b, a%b];
    }
    return a;
}

const gcdmemo = memoize(gcd);
gcdmemo(85, 187)  // =&gt; 17

// Note that when we write a recursive function that we will be memoizing,
// we typically want to recurse to the memoized version, not the original.
const factorial = memoize(function(n) {
    return (n &lt;= 1) ? 1 : n * factorial(n-1);
});
factorial(5)      // =&gt; 120: also caches values for 4, 3, 2 and 1.
</code></pre>

<h2 id="toc_38">8.9 Summary</h2>

<p>Some key points to remember about this chapter are as follows:</p>

<p>You can define functions with the function keyword and with the ES6 =&gt; arrow syntax.</p>

<p>You can invoke functions, which can be used as methods and constructors.</p>

<p>Some ES6 features allow you to define default values for optional function parameters, to gather multiple arguments into an array using a rest parameter, and to destructure object and array arguments into function parameters.</p>

<p>You can use the ... spread operator to pass the elements of an array or other iterable object as arguments in a function invocation.</p>

<p>A function defined inside of and returned by an enclosing function retains access to its lexical scope and can therefore read and write the variables defined inside the outer function. Functions used in this way are called closures, and this is a technique that is worth understanding.</p>

<p>Functions are objects that can be manipulated by JavaScript, and this enables a functional style of programming.</p>

<blockquote>
<p>本章关键点总结如下：</p>

<p>可以用函数关键字和 ES6 =&gt; 箭头函数来定义函数。</p>

<p>可以以方法和构造函数的方式调用函数。</p>

<p>一些 ES6 特性，允许参数设定默认值，可以用剩余参数将多个参数搜集到一个数组中，可以解构对象和数组实参到函数参数中。</p>

<p>可以用 ... 展开运算符传递数组元素或者其他可迭代对象到函数调用。</p>

<p>封闭函数内部定义并返回的函数保留对其词法作用域的访问，因此可以读取和写入外部函数内定义的变量。用这种方式使用的函数称为闭包，这是一种值得理解的技术。</p>

<p>函数是可由 JavaScript 操作的对象，这使 JavaScript 支持函数式编程。</p>
</blockquote>

<hr/>

<ol>
<li>The term was coined by Martin Fowler. See <a href="http://martinfowler.com/dslCatalog/methodChaining.html">http://martinfowler.com/dslCatalog/methodChaining.html</a>.</li>
<li>If you are familiar with Python, note that this is different than Python, in which every invocation shares the same default value.</li>
<li>This may not seem like a particularly interesting point unless you are familiar with more static languages, in which functions are part of a program but cannot be manipulated by the program.</li>
</ol>

<blockquote>
<ol>
<li>这个术语最初是由 Martin Fowler 提出的，参见<a href="http://martinfowler.com/dslwip/MethodChaining.html%E3%80%82">http://martinfowler.com/dslwip/MethodChaining.html。</a></li>
<li>这看起来不足为奇，但如果你对 Python 很熟悉，你会发现 Python 中的函数是程序的一 部分，但无法被程序操作。</li>
<li>这似乎并不是一个特别有趣的点，除非你熟悉更多的静态语言，其中函数是程序的一部分，但不能由程序操作。</li>
</ol>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[chapter 3 Travaling]]></title>
    <link href="blog.2019919.top/16092359109167.html"/>
    <updated>2020-12-29T17:58:30+08:00</updated>
    <id>blog.2019919.top/16092359109167.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型转换]]></title>
    <link href="blog.2019919.top/16089553577924.html"/>
    <updated>2020-12-26T12:02:37+08:00</updated>
    <id>blog.2019919.top/16089553577924.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"> 不注意会出错的类型转换</h2>

<h3 id="toc_1"> 转数值型</h3>

<table>
<thead>
<tr>
<th>原类型</th>
<th>转换后类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>0</td>
</tr>
<tr>
<td>非空非数字字符串</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<blockquote>
<p> NaN（Not a Number，非数）</p>
</blockquote>

<p>NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。<br/>
isNaN() 全局函数来判断一个值是否是 NaN 值。</p>

<pre><code class="language-javascript">    Number.NaN === NaN
    // false
    Number.NaN == NaN
    // false
    isNaN(NaN)
    // true
</code></pre>

<h3 id="toc_2"> 转布尔型</h3>

<table>
<thead>
<tr>
<th>原类型</th>
<th>转换后类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>&quot;&quot;</td>
<td>false</td>
</tr>
<tr>
<td>0,-0,NaN</td>
<td>false</td>
</tr>
<tr>
<td>Infinity,-Infinity,非零数</td>
<td>true</td>
</tr>
</tbody>
</table>

<p>NaN空串null和undefined都为false，所以常用ture,false判断对象是否可以使用。</p>

<h2 id="toc_3"> 转换</h2>

<p>转换分为两种：</p>

<ul>
<li>显示转换</li>
<li>隐式转换<br/>
### 显示转换<br/>
最简单的方法就是使用Boolean（）、Number（）、String（）或Object（）函数。当不通过new运算符调用这些函数时，它们会作为类型转换函数。<br/>
除了null或undefined之外的任何值都具有toString（）方法，这个方法的执行结果通常和String（）方法的返回结果一致。<br/>
把null或undefined转换为对象抛出一个类型错误。<br/>
&gt; 为什么123.tostring()报错？</li>
</ul>

<p>JavaScript中还提供了专门的函数和方法来做显示转换。</p>

<ul>
<li>Number.toString（）方法可以接收表示转换基数（radix）。</li>
<li>Number.toFixed（）根据小数点后的指定位数将数字转换为字符串。</li>
<li>Number.toExponential（）使用指数记数法将数字转换为指数形式的字符串，其中小数点位数为参数。</li>
<li>Number，toPrecision（）根据指定的有效数字位数将数字转换成字符串。<br/>
后三个方法都会进行四舍五入或填充0。<br/>
Number（）只能进行十进制转换。<br/>
全局函数parseInt（）和parseFloat（）会跳过任意数量的前导空格，尽可能多的解析数值字符，并忽略后面的内容。如果第一个为非空字符返回NaN。<br/>
parseInt（）可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2～36。<br/>
&gt; 在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。</li>
</ul>

<p>Number 是比 parseInt 和 parseFloat 更好的选择。</p>

<h3 id="toc_4"> 隐式转换</h3>

<p>某些运算符会做隐式的类型转换，有时用于类型转换。</p>

<pre><code class="language-javascript">    x + &quot;&quot; // 等价于String(x)
    +x   // 等价于Number(x)
    !!x  // 等价于Boolean(x)
</code></pre>

<h2 id="toc_5"> 对象转换为原始值（拆箱转换）</h2>

<p>到布尔值转换，所有对象（包括数组和函数）都转换为true。</p>

<pre><code class="language-javascript">    Boolean(Boolean(false))
    // false
    Boolean(new Boolean(false))
    // true
</code></pre>

<p>对象到字符串和数字是通过两个不同的方法来转换的。<br/>
所有对象都继承了两个方法toString()和valueOf()。对象转化字符串先tostring()方法，如果不是原始值用valueof()方法，如果还不是原始值 抛类型错误。有任何原始值都用原始值进行toStirng()。<br/>
反之转数值型转换，先进行valueof()后进行tostring()。<br/>
案例：空数组转数值型等于0.</p>

<pre><code class="language-javascript">    Number([])
    0
    [].valueOf()
    []
    [].toString()
    &quot;&quot;
    Number(&quot;&quot;)
    0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[chapter 2 Dining]]></title>
    <link href="blog.2019919.top/16089552578971.html"/>
    <updated>2020-12-26T12:00:57+08:00</updated>
    <id>blog.2019919.top/16089552578971.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"> lesson 12</h2>

<p>Good evening.<strong>May I take your order?</strong><br/>
Yes,I would like to have the salad please,and I think the bread and butter is <strong>free of charge</strong>?<br/>
Yes,bread and butter if free.Are you interested in a <strong>main course</strong>?<br/>
Yes,<strong>Do you have any speicals</strong> tonight?<br/>
Of course.Tonight we&#39;<strong>re offering</strong> lobster for only twenty dollars.<br/>
Ok.I&#39;ll take it!</p>

<h2 id="toc_1"> lesson 13</h2>

<p>Are we <strong>still on</strong> for dinner tonight?I&#39;m already getting hungry.<br/>
Sure!<strong>What do you have in mind?</strong><br/>
I&#39;d like a big meal in the evening.What about you?<strong>What are you in the mood for?</strong><br/>
We should <strong>head over to</strong> the new <strong>department store</strong>.They&#39;ve got an <strong>enormous food court</strong> with <strong>loads of</strong> different restaurants.There are supposed to be Japanese,Korean,Thai restaurants and so on.<br/>
My friend gave great <strong>reviews</strong> of the Mexican and Italian places.<strong>Are you in the mood for</strong> a taco or a burrito？Or maybe some pasta?<br/>
<strong>I think I have more of an appetite for</strong> Italian food right now.<br/>
Let&#39;s <strong>definitely</strong> go there.</p>

<h2 id="toc_2"> lesson 14</h2>

<p>Hi,<strong>what can I get you?</strong><br/>
I&#39;ll have a large <strong>mocha</strong> with cream,and a small <strong>cappuccino</strong>.<br/>
<strong>Would you like anything else?</strong><br/>
Yes,I&#39;d also like an <strong>espresso</strong> and a brownie,please.<br/>
<strong>Are they for here or go?</strong><br/>
To go.<br/>
<strong>Your total comes to $12.</strong><br/>
<strong>Hear you go.</strong><br/>
Here&#39;s your change.Thank you.</p>

<h2 id="toc_3"> lesson 15</h2>

<p><strong>What&#39;d you have for lunch</strong> today?<br/>
I had sushi and a salad.<br/>
Oh,sounds heathly.<br/>
<strong>I&#39;m watching my weight.</strong><br/>
You don&#39;t need to <strong>go on a diet</strong>.You look fine.<br/>
I know,but I&#39;<strong>ve been eating too much junk food lately</strong>,like too many <strong>lollipops</strong>,packets of chips,and lots of chocolate bars.<br/>
I know,those potato chips are really <strong>addictive</strong>.You just can&#39;t stop.<br/>
So I&#39;m trying to be healthy for a few weeks.<br/>
Well,<strong>everything in moderation</strong>.</p>

<h2 id="toc_4"> lesson 16</h2>

<p>Excuse me,I&#39;d like to try some Chinese food.<br/>
<strong>We serve authentic Chinese food.Which style do you prefer?</strong><br/>
I know nothing about Chinese food.<strong>Chould you give me some suggestions?</strong><br/>
It&#39;s <strong>divided into eight cuisines</strong>,such as Cantonese food,Shandong food and Sichuan food.<br/>
Is there any difference?<br/>
Yes,Cantonese food is lighter while Sichuan food is spicy and hot.They taste different.<br/>
Oh,really?I like hot food.So <strong>what is your recommendation for me?</strong><br/>
I think mapo tofu and yuxiang shredded pork are quite special and delicious.I recommend the Sichuan food dining room on the third floor.</p>

<h2 id="toc_5">lesson 17</h2>

<p>Good morning。<strong>I&#39;d like to order some groceries</strong>,please.<br/>
Sure,what&#39;d you like to order?<br/>
Well,I need a medium bottle of vanilla essence,a small bottle of chocolate syrup,and some dark chocolate cubes.<strong>When can I expect the dilivery?</strong><br/>
It&#39;ll be delivered in about an hour.May I please have your name and address?<br/>
Sure.My name is Wesley Thomas.The address is 34-B,George Sstreet.<br/>
Alright.<strong>A delivery staff member</strong> will reach your palce in about an hour.<br/>
<strong>What&#39;s the total amount of the things that I just purchased?</strong><br/>
That would be $25.<br/>
Thank you.</p>

<h2 id="toc_6">lesson 18</h2>

<p>Hello,this is Love Restaurant.<strong>How may I assist you?</strong><br/>
<strong>I&#39;d like to make a reservation for two.</strong><br/>
May I have your name,please.?<br/>
I&#39;m Cindy lautner.<br/>
Okay,ma&#39;am.<strong>Would you like the corner table or middle?</strong><br/>
<strong>In the corner with a window view</strong>.<br/>
Okay,done.We reserved your table for two for tomorrow evening.<br/>
Yes,thanks a lot.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chapter 1 Shopping]]></title>
    <link href="blog.2019919.top/16089552264437.html"/>
    <updated>2020-12-26T12:00:26+08:00</updated>
    <id>blog.2019919.top/16089552264437.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"> Lesson 1</h2>

<p>These clothes are <strong>on sale</strong> now.<br/>
Mybe I&#39;ll buy a new shirt.<br/>
<strong>What size are you?</strong><br/>
XL,but I should <strong>try it on</strong>.<strong>Where&#39;s the fitting room?</strong><br/>
It looks a little loose for you.But size L is <strong>out of stock</strong> right now.<br/>
Then I&#39;ll <strong>take it in</strong>.</p>

<h2 id="toc_1"> lesson 2</h2>

<p>Good evening,sir,can I help you?<br/>
Yeah!I&#39;m <strong>looking for</strong> a gift for my girlfriend.<br/>
Do you <strong>have something in mind?</strong><br/>
I think a necklace would be prefect.<br/>
<strong>How about this one?</strong>It sells very well.<br/>
Sounds good,but could you <strong>gift-wrap</strong> this,please?<br/>
Sure.</p>

<h2 id="toc_2"> lesson 3</h2>

<p>Have a look at these <strong>toothbrushes</strong>.They are <strong>being promoted</strong> in this gift pack now.<br/>
What&#39;s <strong>included</strong> in the gift pack?<br/>
Toothbrushes,toothpaste,mouthwash and a cup!<br/>
<strong>It&#39;s a good deal.</strong>Where can I find shower gel?<br/>
It&#39;s in <strong>aisle</strong> 10.</p>

<h2 id="toc_3"> lesson 4</h2>

<p>How about this one?<br/>
I like this brand,and the price isn&#39;t too high.<br/>
<strong>How long is the warranty for this TV?</strong><br/>
It <strong>comes with</strong> a 2-year parts warranty.It&#39;s also the <strong>best-seller</strong> now.<br/>
<strong>Do you offer free delivery?</strong><br/>
Yes,we do.</p>

<h2 id="toc_4"> lesson 5</h2>

<p><strong>What&#39;s special about this phone?</strong><br/>
That&#39;s our <strong>top-of-the-line</strong> model,and if you choose this carrier,<strong>you&#39;ll have unlimited access to the Internet.</strong><br/>
I go online alot with my phone.It easily gets <strong>out of credit</strong> and I have to <strong>top it up</strong> twice a month.<br/>
<strong>Then this really works for you.</strong></p>

<h2 id="toc_5"> lesson 6</h2>

<p>How much are these three books?<br/>
80 yuan.<br/>
But they <strong>set me back</strong> only 60 yuan on the Internet.<strong>Could you go down on the price?</strong><br/>
Maybe I could <strong>make an exception</strong> for you if you bug four books.80 yuan for four boosk.<strong>That would be my final offer.</strong><br/>
Alright.That&#39;s a <strong>bargain</strong>.<br/>
You&#39;ve got a <strong>windfall</strong>!</p>

<h2 id="toc_6"> lesson 7</h2>

<p>Would you like to <strong>pay by card or in cash</strong>?<br/>
I want to <strong>pay by credit card</strong>.Do you take Visa?<br/>
Yes we do.Just a moment.Oh,there&#39;s an error.It syas your password is incorrect.Could you please try it again?<br/>
Well,I completely forgot the password.How about <strong>paying in cash</strong>?<br/>
Not a problem.<strong>Here is your change and your receipt.</strong>Have a nice day!</p>

<h2 id="toc_7"> lesson 8</h2>

<p>How can I help you,sir?<br/>
I&#39;m <strong>returning</strong> a cellphone that I bought yesterday.<br/>
<strong>Is there something wrong with it?</strong><br/>
It keeps <strong>turning off on its own</strong>.It doesn&#39;t work at all.<br/>
I&#39;m sorry to hear about your bad experience.Do you have the receipt with you?<br/>
I have it right here.<br/>
Thank you,sir.I am going to <strong>take care of</strong> this and give you the refund.</p>

<h2 id="toc_8"> lesson 9</h2>

<p>Hey,where did you but this dress?<br/>
I <strong>ordered</strong> it on eBay.<br/>
Didn&#39;t you find it expensive there?<br/>
No,not at all.<strong>It has some great deals!I got crazy discounts!</strong><br/>
<strong>How much did this cost you?</strong><br/>
Well,I got a 45% <strong>discount</strong> on the <strong>original</strong> price.<br/>
Wow!That&#39;s a super <strong>deal</strong>.I will check it out today.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[01 JavaScript Drum Kit]]></title>
    <link href="blog.2019919.top/16089052254448.html"/>
    <updated>2020-12-25T22:07:05+08:00</updated>
    <id>blog.2019919.top/16089052254448.html</id>
    <content type="html"><![CDATA[
<p>模拟一个打鼓的页面。用户在键盘上按下 ASDFGHJKL 这几个键时，页面上与字母对应的按钮变大变亮，对应的鼓点声音响起来。</p>

<h2 id="toc_0">知识点</h2>

<h3 id="toc_1">Html5</h3>

<h4 id="toc_2">data-*</h4>

<blockquote>
<p>HTML（超文本标记语言） &gt; 全局属性 &gt; data-*</p>
</blockquote>

<p>data-* 全局属性 是一类被称为自定义数据属性的属性，它赋予我们在所有 HTML 元素上嵌入自定义数据属性的能力，并可以通过脚本在 HTML 与 DOM 表现之间进行专有数据的交换。<br/>
所有这些自定义数据属性都可以通过所属元素的 HTMLElement 接口来访问。  HTMLElement.dataset 属性可以访问它们。</p>

<p>TODO</p>

<h4 id="toc_3">HTML <audio></h4>

<blockquote>
<p>HTML（超文本标记语言）&gt; HTML 元素参考 &gt; <audio></p>
</blockquote>

<p>HTML <audio> 元素用于在文档中嵌入音频内容。 <audio> 元素可以包含一个或多个音频资源， 这些音频资源可以使用 src 属性或者<source> 元素来进行描述：浏览器将会选择最合适的一个来使用。也可以使用 MediaStream 将这个元素用于流式媒体。</p>

<h3 id="toc_4">JavaScript</h3>

<h4 id="toc_5">Array.from()</h4>

<blockquote>
<p>JavaScript &gt; JavaScript 参考 &gt; JavaScript 标准内置对象&gt;Array&gt;Array.from()</p>
</blockquote>

<p>Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>

<pre><code class="language-javascript">    console.log(Array.from(&#39;foo&#39;));
    // expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]    
    console.log(Array.from([1, 2, 3], x =&gt; x + x));
    // expected output: Array [2, 4, 6]
</code></pre>

<h3 id="toc_6">WebAPI</h3>

<blockquote>
<p>Web API 接口参考 &gt; HTMLCollection</p>
</blockquote>

<p>HTMLCollection 接口表示一个包含了元素（元素顺序为文档流中的顺序）的通用集合（generic collection），还提供了用来从该集合中选择元素的方法和属性。</p>

<blockquote>
<p>document.getElementsBy***是获取了HTMLCollection，如果想要foreach需要转成数组。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[01 JavaScript Drum Kit 中文指南]]></title>
    <link href="blog.2019919.top/16089048368062.html"/>
    <updated>2020-12-25T22:00:36+08:00</updated>
    <id>blog.2019919.top/16089048368062.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>作者：©<a href="https://github.com/soyaine">未枝丫</a><br/><br/>
简介：<a href="https://javascript30.com">JavaScript30</a> 是 <a href="https://github.com/wesbos">Wes Bos</a> 推出的一个 30 天挑战。项目免费提供了 30 个视频教程、30 个挑战的起始文档和 30 个挑战解决方案源代码。目的是帮助人们用纯 JavaScript 来写东西，不借助框架和库，也不使用编译器和引用。现在你看到的是这系列指南的第 1 篇。完整指南在 <a href="https://github.com/soyaine/JavaScript30">GitHub</a>，喜欢请 Star 哦♪(<sup>∇<sup>*)</sup></sup></p>
</blockquote>

<h2 id="toc_0">实现效果</h2>

<p>模拟一个打鼓的页面。用户在键盘上按下 ASDFGHJKL 这几个键时，页面上与字母对应的按钮变大变亮，对应的鼓点声音响起来。</p>

<p><a href="http://soyaine.github.io/JavaScript30/01%20-%20JavaScript%20Drum%20Kit/index-SOYAINE.html">看在线效果</a></p>

<h2 id="toc_1">关键要点</h2>

<ol>
<li>键盘事件</li>
<li>播放声音</li>
<li>改变样式</li>
</ol>

<h2 id="toc_2">步骤分解</h2>

<ol>
<li><strong>添加键盘事件监听</strong>。在 window 上添加键盘 <code>keydown</code> 事件。</li>
<li><strong>对应事件处理程序。</strong>
<ol>
<li><strong>获取键码</strong></li>
<li><strong>用 <code>querySelector</code> 获取元素</strong></li>
<li><strong>获取 <code>data-key</code> 为对应键码的元素</strong></li>
<li><strong>处理元素</strong>。播放音频、添加样式。</li>
</ol></li>
<li><strong>为所有的 <code>div.key</code> 添加 <code>transitionened</code> 事件</strong>。
<ol>
<li><strong>获取所有样式为 <code>key</code> 的元素</strong></li>
<li><strong>为其添加事件监听</strong></li>
</ol></li>
<li><strong>去除样式的事件处理程序</strong></li>
</ol>

<h2 id="toc_3">基础语法</h2>

<h3 id="toc_4">一些 ES6 语法</h3>

<ol>
<li><p><code>const</code> ：声明一个只读的常量，标识符的值只能赋值一次。</p></li>
<li><p>`字符串 \({ 变量、属性名 } \`：模板字面量（Template literals）中用于表示模板字符串的标识。特点是字符串首尾用反引号（\`），内部的模板部分用 \){ } 括起来表示，具体请看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">MDN文档</a>。简单例子如下：</p>
<pre><code class="language-javascript">      var a = 1;
      var b = 2;<br/>
      //不用模板的写法<br/>
      console.log(&quot;三是&quot; + (a + b) + &quot;不是&quot; + (2 * a + b)); //&quot;三是3不是4&quot;<br/>
      //使用模板字符串的写法<br/>
      console.log(`三是${a + b}不是${2 * a + b}`); //&quot;三是3不是4&quot;
</code></pre></li>
</ol>

<h3 id="toc_5"><code>forEach</code> 与箭头函数</h3>

<p>使用 <code>document.querySelector</code> 获取一组符合 CSS 选择符的元素快照，类型为 NodeList（此对象是对于文档的实时运行的动态查询），对其进行遍历时可采用 <code>forEach</code> 方法。</p>

<pre><code class="language-javascript">// Code from http://es6-features.org/#StatementBodies

// ES6
nums.forEach(v =&gt; {
    if (v % 5 === 0)
        fives.push(v);
})

// ES5
nums.forEach(function (v) {
    if (v % 5 === 0)
        five.push(v);
})
</code></pre>

<h2 id="toc_6">解决难点</h2>

<h3 id="toc_7">如何将键盘按键与页面按钮对应起来？</h3>

<p>连接的帮手是 <code>keydown</code> 事件中的 <code>keyCode</code> 属性，<code>keyCode</code> 属性的值和 ASCII 编码值相同（对应小写字母）。在<a href="http://keycode.info/">这个网站</a>可以用按键盘来查看对应的键码。</p>

<p>我们能获取到的初始页面中，按钮 <code>div</code> 和音频 <code>audio</code> 标签中都添加了一个属性 <code>data-key</code> 用于存储对应的键码，这样做的目的是，添加键盘事件监听后，触发键盘事件时即可获取事件的 <code>keyCode</code> 属性值，以此为线索，操作对应的按钮及音频。</p>

<pre><code class="language-javascript">const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`);
const key = document.querySelector(`div[data-key=&quot;${e.keyCode}&quot;]`);
</code></pre>

<h3 id="toc_8">如何保证按键被按住不放时，可以马上响起连续鼓点声？</h3>

<p>asdf<br/>
每次播放音频之前，设置播放时间戳为 0：</p>

<pre><code class="language-javascript">var audio = document.getElementById(&quot;video&quot;); 
audio.currentTime = 0;
audio.play();
</code></pre>

<h3 id="toc_9">如何使页面按钮恢复原状？</h3>

<p>利用一个叫 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/transitionend"><code>transitionend</code></a> 的事件，它在 CSS transition 结束后会被触发。我们就可以利用这个事件，在每次打鼓的效果（尺寸变大、颜色变化）完成之后，去除相应样式。</p>

<p>在这个页面中，发生 <code>transition</code> 的样式属性不止一个（<code>box-shadow</code>, <code>transform</code>, <code>border-color</code>），所以需要添加一个判断语句，使每发生一次按键事件时，只去除一次样式。</p>

<pre><code class="language-javascript">funciton remove(event) {
  if (event.propertyName !== &#39;border-left-color&#39;) return;
  this.classList.remove(&#39;playing&#39;);
  // event.target.classList.remove(&#39;playing&#39;);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过变量作用域深入了解undefined]]></title>
    <link href="blog.2019919.top/16088182648987.html"/>
    <updated>2020-12-24T21:57:44+08:00</updated>
    <id>blog.2019919.top/16088182648987.html</id>
    <content type="html"><![CDATA[
<p>听winter老师的课知道undefined是一个变量，它可以被改变，所以使用void（0）来代替他，但是在做实验的时候发现虽然它赋值不报错，取值时候undefined却并没有改变。</p>

<pre><code class="language-javascript">    undefined = 0
    // 0
    undefined
    // undefined
</code></pre>

<p>这回学习到了变量作用域，再结合之前学的对象的属性，深入了解下undefined到底什么时候会被篡改。</p>

<h2 id="toc_0">函数作用域和声明提前</h2>

<p>别的语言一般为块级作用域，js取而代之使用了函数作用域：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p>

<pre><code class="language-javascript">    var a = function test(o){
        var i = 0;                          // i在整个函数体内均是有定义的
        if(typeof o == &quot;object&quot;){
            var j = 4;                      // j在函数体内是有定义的，不仅仅是在这个代码段内
            for(var k=0; k &lt; 3; k++){       // k在函数体内是有定义的，不仅仅是在循环内
                console.log(k);             // 输出数字0～2
            }
            console.log(k);                 // k已经定义了，输出3
        }
        console.log(k);                     // k已经定义了，输出3
        console.log(j);                     // j已经定义了，输出4
    };
</code></pre>

<p>JavaScript的这个特性被非正式地称为声明提前（hoisting），即JavaScript函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部。</p>

<pre><code class="language-javascript">    var a = &#39;1&#39;;
    function f(){
        console.log(a);
        var a = &#39;2&#39;;
        console.log(a);
    }
</code></pre>

<p>由于函数作用域的特性，变量a的声明被提前到了整个函数体最前面，声明了但是没赋值，所以第一次console是undefined。执行到var语句时才被赋值，这应该也是为什么可以一个变量多次var生命的愿意，后面每一次var都只是起到了赋值的作用。</p>

<h2 id="toc_1">ES6块作用域</h2>

<p>ES6弥补了这这个概念，追加了let和const，也就有了{}块作用域的概念，let和const的区别就不提了，这个在工作中经常用到，用上面的例子感受一下let和var的区别。</p>

<pre><code class="language-javascript">    var a = function test(o){
        var i = 0;                          // i在整个函数体内均是有定义的
        if(typeof o == &quot;object&quot;){
            let j = 4;                      // j在if块内是有定义的
            for(var k=0; k &lt; 3; k++){       // k在函数体内是有定义的，不仅仅是在循环内
                console.log(k);             // 输出数字0～2
                console.log(j);             // j已经定义了，输出4
            }
            console.log(k);                 // k已经定义了，输出3
        }
        console.log(k);                     // k已经定义了，输出3
        console.log(j);                     // j在块外，抛出异常Uncaught ReferenceError: j is not defined
    };
</code></pre>

<p>let和const只有在块内是被声明的。</p>

<h2 id="toc_2">全局变量的本质</h2>

<p>当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。当使用var声明一个变量时，创建的这个属性是不可配置的，无法通过delete运算符删除。</p>

<pre><code class="language-javascript">    test =1
    // 1
    window.test
    // 1
    delete test
    // true
    window.test
    // undefined
    var test = 1
    // undefined
    window.test
    // 1
    delete test
    // false
    window.test
    // 1
</code></pre>

<p>可以看到当定义一个全局变量的时候他变成了window的属性。<br/>
JavaScript可以允许使用this关键字来引用全局对象，但是不能引用局部变量中存放的对象。</p>

<pre><code class="language-javascript">    this.test
    // 1
</code></pre>

<h2 id="toc_3">深入理解undefined的本质</h2>

<p>undefined明明是个变量为什么赋值后无法使用呢。任何地方都可以直接使用undefined，那他是一个全局变量一个全局的属性，事实也果然如此。</p>

<pre><code class="language-javascript">    window.undefined == undefined
    // true
</code></pre>

<p>而属性分两类，他们的特征如下：</p>

<ul>
<li>数据属性
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性是否能被赋值。</li>
<li>enumerable：决定for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul></li>
<li>访问器属性（getter/setter）
<ul>
<li>getter：函数或undefined，在取属性值时被调用。</li>
<li>setter：函数或undefined，在设置属性值时被调用。</li>
<li>enumerable：决定for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。<br/>
查看下全局属性undefined的属性特征。</li>
</ul></li>
</ul>

<pre><code class="language-javascript">    console.log(Object.getOwnPropertyDescriptor(window,&#39;undefined&#39;));
    // configurable: false
    // enumerable: false
    // value: undefined
    // writable: false
</code></pre>

<p>writable：false，就是这个原因undefined虽然是个全局变量，但是我们赋值之后他并没有被改变。那为什么还需要用void(0)来代替undefined呢？结合上面的函数作用域再做一个实验。</p>

<pre><code class="language-javascript">    function test() {
        var undefined = 100; 
        console.log(undefined);
        var obj = {a : undefined}; 
        console.log(Object.getOwnPropertyDescriptor(obj,&#39;a&#39;));
    }
    test();
    // 100
    // configurable: true
    // enumerable: true
    // value: 100
    // writable: true
</code></pre>

<p>在函数作用域中，undefined被从声明并赋值为100，无论是直接console它自己还是去查看undefined属性特性都能看出，undefined变量被修改了。这也就说在作用域内undefined可以被修改。</p>

<pre><code class="language-javascript">    function test() {
        const undefined = 100; 
        console.log(undefined);
        const obj = {a : undefined}; 
        console.log(Object.getOwnPropertyDescriptor(obj,&#39;a&#39;));
        test();
    }
    // 100
    // configurable: true
    // enumerable: true
    // value: 100
    // writable: true
</code></pre>

<p>块作用域内也一样可以被修改，得出结论undefined是一个类似var声明一样可以被重复声明的全局属性，而他的属性特性writable是false，所以不能被修改，但是在非全局作用域内，他是可以被篡改的，这是由也就要注意用void (0)来替代undefined。</p>

<h2 id="toc_4">作用域链</h2>

<p>以书中的角度用对象属性去看作用域链：</p>

<ul>
<li>JavaScript最顶层的代码，其作用域链只有一个全局对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Global object</td>
    <tr>
</table>

<ul>
<li>不包含嵌套的函数，其作用域两个对象：函数自身的变量对象和全局对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Activation object</td>
    <tr>
    <tr>
        <td>1</td><td>Global object</td>
    <tr>
</table>

<blockquote>
<p>活动对象(activation object)，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端</p>
</blockquote>

<ul>
<li>对于包含了嵌套函数的函数，其作用域包含至少三个对象：自身的变量对象，外层的变量对象（将自身嵌套的函数），全局变量对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Sub activation object</td>
    <tr>
    <tr>
        <td>1</td><td>Activation object</td>
    <tr>
    <tr>
        <td>2</td><td>Global object</td>
    <tr>
</table>

<p>作用域链给我的感觉类似原型链，将函数的上下文构成了链表的形式,而方法执行时一层一层往外找，所以为了方便链表从上到下查找属性，所以有了声明提前，链表最顶端为嵌套函数的最里层，链表最底端则是全局变量对象。</p>

<pre><code class="language-javascript">    function test(){
        var fun1,fun2;
        for(var i=0;i&lt;2;i++){
            if(i === 0){
                fun1 = function(){console.log(&#39;fun1:i=&#39;+i)};
            }
            if(i === 1){
                fun2 = function(){console.log(&#39;fun2:i=&#39;+i)};
            }
        };
        fun1();
        fun2();
    }∫
    test();
    // fun1:i=2
    // fun2:i=2
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[努力了三个月的总结]]></title>
    <link href="blog.2019919.top/16084764191221.html"/>
    <updated>2020-12-20T23:00:19+08:00</updated>
    <id>blog.2019919.top/16084764191221.html</id>
    <content type="html"><![CDATA[
<p>今年是个灾难年，疫情让大家都不是太好受，但是年初的疫情期间，我想一定有很多人抓住了这段空闲时期努力学习，而这些人一般都是一些比别人更加优秀的人，这几个月他们再次拉开了和我的距离，而我到了8月中旬的夏休长假后才意识到这一点，此时此刻距离我<strong>30岁</strong>还剩1个月。</p>

<h2 id="toc_0">第一次落实到笔纸上的执行计划</h2>

<p>第一次的计划起于我的夏休，夏休期间因为电脑更换了新配置，旧件废物利用做家庭服务器，研究多个NAS操作系统和软路由，在不断的失败中了解了好多操作系统都是基于Linux，再加上公司最近的项目都是在Linux中开发，觉得熟练Linux命令行对今后的作业有一定的帮助，在NAS草草的选择了WINDOWS之后有了这一路线。</p>

<ol>
<li>centOS</li>
<li>git</li>
<li>开发环境（原设想windows开发，通过CLI让Linux服务器同步代码编译并发布）</li>
<li>angular</li>
<li>postgreSQL</li>
<li>dotnet core</li>
<li>ngnix</li>
<li>docker</li>
<li>软路由</li>
</ol>

<h3 id="toc_1">想法初衷</h3>

<p>整体目标是通过工作中应用的语言和技术来实现一个blog，然后将我的软件硬件爬坑的经历给记录下来，123三点进行开发环境学习，4为前端，56是DB和后端api，789是部署服务器相关内容。<br/>
整个流程走下来应该可以将我想要的博客搭建起来，今后更好的记录未来工作中遇到的问题，便于回顾，而开发过程中也是一个学习的过程，毕竟在项目中没有完全一个人从无到有的实施。</p>

<h3 id="toc_2">实施结果</h3>

<p>经过两个月的学习做一个小总结，<strong>以下都是垃圾</strong>：</p>

<blockquote>
<p>centOS学习了一些基本指令，什么文件处理啊权限用户处理啊，这些简单的能用的到的，跟了一波视频，自己也做了一些笔记。<br/>
git和开发环境，嗯设想的并没有去实现，感觉怪怪得，明明docker就是为了多平台，打个镜像就完事了我干啥做这么奇葩，所以最后熟悉了下git的一些常用命令行，从此脱离vsCode的图形化界面操作。<br/>
关于angular，不得不说还真是有一些提高，尤其是在路由（包括后期部署的坑）这一块，还真是有了一定的提高，再就是结构指令，真正的不是纸上谈兵真正的动手操作了一番。前端这一部分最耽误时间的应该就是在选择一个富文本编辑器，最后应用的是tinymce，不用额外的资源文件，也比较美观功能齐全。<br/>
后端因为一直不是我的侧重点，仅仅是为了API的实现浅浅的完成了前端的需求，不过在tinymce图片文件交互这里也稍微下了一点功夫。<br/>
最后的部署环境首先是在IIS中完成了前后端部署，毕竟电脑还是都是windows的，然后docker也是撸了一遍视频，简单的完成了部署。<br/>
公网IP也申请了，还傻傻的去备案了，至今还是下面这个状态<br/>
<img src="media/16084764191221/16086441905741.jpg" alt="" style="width:943px;"/></p>
</blockquote>

<p><strong>以上灰色部分都是垃圾！</strong><br/>
到此为止，我总结下我的状态，我发现我没留下什么，除了github上多了几行代码电脑多了几个软件安装包之外，我觉得我一无所获，于是就在次沉浸在迷茫之中。我为什么就无法提升，我也没有在闲着，而且效率明显比之前提高了，学习时间也增加了，我的未来呢。</p>

<h2 id="toc_3">奇遇➡️心得</h2>

<p>好在我迷茫但是没有堕落，有一天在学习浏览器原理时，看到别人博客的引用文献中除了一些书和别人的博文，还有一些课程，而这个课程的介绍就有意思了。</p>

<blockquote>
<p>前端学习是一条先块后慢的曲线。在快速入门之后，大多数人都会感觉：自己仅仅停留在会用的阶段，后面的学习之路似乎越来越陡峭，每前进一步都十分艰难。<br/>
其实是你没有意识到，你在自学的过程中走了太多弯路。</p>
</blockquote>

<p>后面还有一些，我觉得这些完全说到了我的心坎，还是有大牛懂得菜鸟的心的，而其课程目录正含有我在自学的浏览器原理，我觉得我碰到知己了啊，赶紧买过来课啃，上下班一起啃。<br/>
这样坚持了大概～～好吧6天，我成功服输了。就有种刚接触人工智能AI，人家提了一个名词我去查，最后一直查到了高中数学，而且这知识早就忘了。<br/>
好在赶上了这个老师的直播，这个课程原来是面向阿里P5P6水平如何上P7的一个指导，通过他的直播我确切的找到了差距，要知道这些大牛也不过30到35左右，甚至可能是我同届的毕业生，我八年的对日经验真的是提前养老了，而脑子也养老了，但是我真的不愿意这样认输，我唯一的目标就是不希望到我40岁的时候活得跟周围这些40岁老大哥一样，满嘴都是没法学习的借口。<br/>
带着迷茫悲哀和不服的心态继续浏览着知乎，<a href="https://zhuanlan.zhihu.com/p/27662828">JavaScript入门的5条建议</a>救世的贴出现了，这个贴发写于2017年。我总结下对我最有用的亮点：</p>

<ol>
<li>写代码 &gt; 看视频 &gt; 看书 三个部分时间配比</li>
<li>不可盲目追新技术</li>
</ol>

<p>第一点新鸟老鸟都懂，但是我经常看视频简单就不动手了，讲的东西我知道我会，但是落实到键盘上发现就总也写不对。<br/>
第二点他的描述很有趣：</p>

<blockquote>
<p>react，vue，angular,和你没关系<br/>
node，express，koa，和你没关系<br/>
grunt，gulp，webpack，和你没关系</p>
</blockquote>

<p>这确实是我的问题，做dotnet出身，因typescript后端程序员很容易接纳，而基本上没有什么基础直接开始了angularJs到angular的开发，html样式能做，然而说不清楚，一切都靠搜索大家记录的bug来辅助我完成工作，真的做到了老师说的会用而已，而跟不上老师的课原因就是没有基础，一个曾经让我们看不起的前端程序员所需要的基础知识梁是我根本不了解的。虽然心理上不接受，但是不得不说，我这八年工作经验可能赶不上大厂p4的新手。<br/>
以上心理活动和经历再加上睡觉，大概经历了18个小时，之后我重新操起了《JavaScript权威指南》，一本传说中最不适合初学者学习的书，而恰巧，这本书上次读到了类型转换。对象类型的转换也就是装箱拆箱这一块，读完了也理解了老师当时讲的拆箱转换 valueOf() 方法和 toString() 方法的执行顺序，而这时我发现，原来像听了天书的一节课程，我竟然用读《JavaScript权威指南》不到两个小时就全部消化了。<br/>
内心汹涌澎湃，至此我觉得我得到的不仅仅是一课的知识，还得到的是对这个学习方向的肯定，找到了能前进一步的路线。</p>

<h2 id="toc_4">直播其他所得</h2>

<p>winter老师直播的主要围绕是面试，而今年我也仅仅参加了一次面试，这一次就让我知道了差距，那总结老师所说的案例性问题：</p>

<ul>
<li>css布局</li>
<li>dom api</li>
<li>原型</li>
<li>闭包</li>
</ul>

<p>后两个问题对日至今也没有被问过，通过这次直播也找到了原因。</p>

<blockquote>
<p>考原型闭包是为了考架构能力<br/>
原型是考面向对象<br/>
考闭包是为了考函数式编程</p>
</blockquote>

<p>所以对日外包真的是并不需要呢。</p>

<h2 id="toc_5">最新计划</h2>

<ul>
<li>《JavaScript权威指南》</li>
<li>《JavaScript函数式编程》</li>
<li>《重学前端》--JS部分</li>
<li>css布局</li>
<li>浏览器原理及API</li>
</ul>

<p>新的计划很简单，抓好基础，不甘堕落。争取明年七月完成这些目标。</p>

<h2 id="toc_6">今年的最后总结</h2>

<p>这三个月也是今年最后的三个月了，那也就基本是今年的总结了，也是我开始真的努力坚持写博客的第一次总结。<br/>
今年上半年虽然没学习技术，好在磨练了下心性，读书是人类走向心智成熟的最佳捷径。在上半年中除了名人传记金融和技术相关方面的书之外，我觉得心理上的书最让我受益匪浅，这里不仅仅是类似《论语》的《人性的弱点》这类书，只讲表象，《少有人走的路》这一套书从心理上讲解了我们一些人性上的弱点的起因以及自己努力掩盖这些弱点的行为，而起初发现这本书只是我想寻求一些在自律上的帮助，却获得了更大的回报，真的是太幸运了。今年读书让我得到的最大最受用的两大改变：</p>

<ol>
<li>控制焦躁的心，可以做到不争吵并且坚决拒绝否定别人。</li>
<li>正式面对自己的善恶和伪善，不以恶小而为之，不以善小而不为。</li>
</ol>

<p>在不断的读书和知识的学习中，我的谈吐也在发生改变，无论跟同事朋友还是亲人，说话越来越调理清晰了。<br/>
我是个喜欢完善环境的人，开发环境我会去找各种各样的插件来辅助编程，这次的学习环境也有了很大的投入，买了两份前端课程，买了一个英语外教课程，买了一个苹果一体机，买了一个新pad，买了niz键盘，买了妙控板。嗯这些都花在了11月底12月初，也就是说我有了个明确的目标，我希望到我31岁的时候就能获得丰厚的30岁进行自我投资的知识回报，并在不久的将来进行变现。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新认识下熟悉的浏览器]]></title>
    <link href="blog.2019919.top/16076922632055.html"/>
    <updated>2020-12-11T21:11:03+08:00</updated>
    <id>blog.2019919.top/16076922632055.html</id>
    <content type="html"><![CDATA[
<p>前端程序员每天都在抠代码，各种各样的技术，千变万化的框架，但最后组装压缩在一起，就是为了伺候操作系统的一个软件————浏览器。这一次，在阅读了三天各大博主的精华后，就chrome浏览器来做一下自己的整理记录。<br/>
双击桌面chrome浏览器发生了什么呢：</p>

<blockquote>
<p>系统创建了一个chrome的进程。</p>

<blockquote>
<p>从多标签页app的开始，一个chrome进程中有了多个子tab进程。</p>

<blockquote>
<p>每个tab进程内有下面这些进程：<br/>
<a href="#toc_0">渲染引擎</a><br/>
<a href="#toc_1">JS引擎</a><br/>
<a href="#toc_2">用户界面</a><br/>
<a href="#toc_3">存储</a></p>
</blockquote>
</blockquote>
</blockquote>

<h2 id="toc_0">渲染引擎</h2>

<p>最初渲染引擎和JS引擎并没有分家，在一起统称为浏览器内核，后来JS引擎越来越独立，内核就完全倾向于渲染引擎。chrome原来使用的就是webkit引擎，后来为了不受制于苹果，基于webkit改编了blink，将其内置于chrome中。</p>

<h2 id="toc_1">JS引擎</h2>

<h2 id="toc_2">用户界面</h2>

<h2 id="toc_3">存储</h2>

<h2 id="toc_4">感受</h2>

<p>现在对学习的感觉是即入迷又无力，学到这里的时候回想一下，我最开始只是看到了一篇短文，浅谈JS事件的原理，而当时的那篇文章真的是比较浅，我现在已经忘了内容是什么了，但是在我不断深入的时候，每每看到一个强大的人的博客的时候就会发现一些新内容，当我为了弄懂其中一个小名词的时候又会引出无数的子节点，真的是树无处不在，越来越入迷，也越来越吃力。虽然我不知道整个树有多大，但是当学到末梢节点的时候回头来总结一下，看看我捋顺的健壮的树枝，真的是振奋人心。</p>

<h2 id="toc_5">参考</h2>

<p><a href="https://segmentfault.com/a/1190000018806562">webkit引擎和v8引擎工作原理</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript类型转换]]></title>
    <link href="blog.2019919.top/16087263047458.html"/>
    <updated>2020-12-23T20:25:04+08:00</updated>
    <id>blog.2019919.top/16087263047458.html</id>
    <content type="html"><![CDATA[
<p>《JavaScript权威指南》的这一章节就是让我确定了我学习路线的一节，这一节的掌握与老师讲拆包转换的时候内容一致，只是描述名词略有变化，也就是说还是要从基础抓起。</p>

<h2 id="toc_0"> 不注意会出错的类型转换</h2>

<h3 id="toc_1"> 转数值型</h3>

<table>
<thead>
<tr>
<th>原类型</th>
<th>转换后类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>0</td>
</tr>
<tr>
<td>非空非数字字符串</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<blockquote>
<p>NaN（Not a Number，非数）<br/>
NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。<br/>
isNaN() 全局函数来判断一个值是否是 NaN 值。</p>
</blockquote>

<pre><code class="language-javascript">    Number.NaN === NaN
    // false
    Number.NaN == NaN
    // false
    isNaN(NaN)
    // true
</code></pre>

<h3 id="toc_2"> 转布尔型</h3>

<table>
<thead>
<tr>
<th>原类型</th>
<th>转换后类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>&quot;&quot;</td>
<td>false</td>
</tr>
<tr>
<td>0,-0,NaN</td>
<td>false</td>
</tr>
<tr>
<td>Infinity,-Infinity,非零数</td>
<td>true</td>
</tr>
</tbody>
</table>

<p>NaN空串null和undefined都为false，所以常用ture,false判断对象是否可以使用。</p>

<h2 id="toc_3"> 转换</h2>

<p>转换分为两种：</p>

<ul>
<li>显示转换</li>
<li>隐式转换</li>
</ul>

<h3 id="toc_4"> 显示转换</h3>

<p>最简单的方法就是使用Boolean（）、Number（）、String（）或Object（）函数。当不通过new运算符调用这些函数时，它们会作为类型转换函数。</p>

<p>除了null或undefined之外的任何值都具有toString（）方法，这个方法的执行结果通常和String（）方法的返回结果一致。</p>

<p>把null或undefined转换为对象抛出一个类型错误。</p>

<blockquote>
<p>为什么123.tostring()报错？</p>
</blockquote>

<p>JavaScript中还提供了专门的函数和方法来做显示转换。</p>

<ul>
<li>Number.toString（）方法可以接收表示转换基数（radix）。</li>
<li>Number.toFixed（）根据小数点后的指定位数将数字转换为字符串。</li>
<li>Number.toExponential（）使用指数记数法将数字转换为指数形式的字符串，其中小数点位数为参数。</li>
<li>Number，toPrecision（）根据指定的有效数字位数将数字转换成字符串。</li>
</ul>

<p>后三个方法都会进行四舍五入或填充0。</p>

<p>Number（）只能进行十进制转换。</p>

<p>全局函数parseInt（）和parseFloat（）会<strong>跳过任意数量的前导空格，结束于空格</strong>，尽可能多的解析数值字符，并忽略后面的内容。如果第一个为非空字符不是数字返回NaN。</p>

<pre><code class="language-javascript">    parseInt(&#39; 112 333&#39;)
    // 112
</code></pre>

<p>parseInt（）可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2～36。</p>

<blockquote>
<p>在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。<br/>
Number 是比 parseInt更好的选择。<br/>
这一段觉得老师说的有问题</p>
</blockquote>

<pre><code class="language-javascript">    parseInt(&#39;! 112 333&#39;)
    // NaN
    parseInt(&#39;0x 112 333&#39;)
    // NaN
</code></pre>

<h3 id="toc_5"> 隐式转换</h3>

<p>某些运算符会做隐式的类型转换，有时用于类型转换。</p>

<pre><code class="language-javascript">    x + &quot;&quot; // 等价于String(x)
    +x   // 等价于Number(x)
    !!x  // 等价于Boolean(x)
</code></pre>

<h2 id="toc_6"> 对象转换为原始值（拆箱转换）</h2>

<p>到布尔值转换，所有对象（包括数组和函数）都转换为true。</p>

<pre><code class="language-javascript">    Boolean(Boolean(false))
    // false
    Boolean(new Boolean(false))
    // true
</code></pre>

<p>对象到字符串和数字是通过两个不同的方法来转换的。<br/>
所有对象都继承了两个方法toString()和valueOf()。对象转化字符串先tostring()方法，如果不是原始值用valueof()方法，如果还不是原始值 抛类型错误。有任何原始值都用原始值进行toStirng()。<br/>
反之转数值型转换，先进行valueof()后进行tostring()。<br/>
案例：空数组转数值型等于0.</p>

<pre><code class="language-javascript">    Number([])
    // 0
    [].valueOf()
    // []
    [].toString()
    // &quot;&quot;
    Number(&quot;&quot;)
    // 0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript全部的对象分类]]></title>
    <link href="blog.2019919.top/16085442753431.html"/>
    <updated>2020-12-21T17:51:15+08:00</updated>
    <id>blog.2019919.top/16085442753431.html</id>
    <content type="html"><![CDATA[
<p>之前讲解的对象只是特定的一部分，并不能涵盖全部的JavaScript对象。<br/>
比如无论怎样编写代码都没法绕开Array，实现一个跟原生数组行为一模一样的对象，因为原生数组底层实现了一个自动随着下标变化的length属性。并且也无法依靠JavaScript代码实现div对象，需要用document.createElement来创建。这也说明了JavaScript的对象机制并非简单的属性集合+原型。</p>

<h2 id="toc_0"> JavaScript中的对象分类</h2>

<p>* 宿主对象（host Objects）<br/>
由JavaScript宿主环境提供的对象，他们的行为完全由宿主环境决定。<br/>
* 内置对象（Built-in Objects）<br/>
由JavaScript语言提供的对象。<br/>
    - 固有对象（Intrinsic Objects）<br/>
    由便准规定，随着JavaScript运行时创建而自动创建的对象实例。<br/>
    - 原生对象（Native Objects）<br/>
    可以由用户通过Array、RegExp等内置构造器或者特殊语法创建的对象。<br/>
    - 普通对象（Ordinary Objects）<br/>
    由{}语法、Object构造器或者calss关键字定义类创建的对象，它能够被原型继承。</p>

<h2 id="toc_1"> 宿主对象</h2>

<p>前端最熟悉的就是浏览器环境中的宿主。在浏览器环境中全局对象是window，window上又有很多属性，如document。<br/>
实际上这个全局对象window上的属性一部分来自于JavaScript语言，一部分来自浏览器环境。</p>

<h2 id="toc_2"> 内置对象·固有对象</h2>

<p>固有对象是由标准规定，随着JavaScript运行时创建而自动创建的对象实例，类似基础库的角色。比如window、document等。</p>

<h2 id="toc_3"> 内置对象·原生对象</h2>

<p>能够通过语言本身的构造器创建的对象叫做原生对象。<br/>
老师将对象分成了如下五类：<br/>
通过这些构造器可以通过new运算创建新的对象，</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript的面向对象]]></title>
    <link href="blog.2019919.top/16085441443213.html"/>
    <updated>2020-12-21T17:49:04+08:00</updated>
    <id>blog.2019919.top/16085441443213.html</id>
    <content type="html"><![CDATA[
<p>在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。而 JavaScript 早年却选择了一个更为冷门的方式：原型。<br/>
这节课了解一下 JavaScript 是如何设计对象模型的。</p>

<h2 id="toc_0"> JavaScript对象的特征</h2>

<p>* 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。<br/>
* 对象有状态：对象具有状态，同一对象可能处于不同状态之下。<br/>
* 对象具有行为：即对象的状态，可能因为他的行为产生变迁。<br/>
一般而言，各语言对象唯一标识性都是用内存地址来体现。</p>

<pre><code class="language-javascript">    var o1 = { a: 1 };
    var o2 = { a: 1 };
    console.log(o1 == o2); // false
</code></pre>

<p>两个一模一样的对象，但是打印结果是false，两个对象并不是同一个对象。<br/>
“状态和行为”在不同语言中会使用不同的术语来描述他们，C++中是“成员变量和成员函数”，Java中则称为“属性和方法”。在JavaScript中，将状态和行为统一抽象为“属性”。</p>

<pre><code class="language-javascript">    var o = { 
        d: 1,
        f() {
            console.log(this.d);
            }    
        };
</code></pre>

<p>o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。<br/>
JavaScript 中对象独有的特色是：<strong>对象具有高度的动态性</strong>，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p>

<pre><code class="language-javascript">    var o = { a: 1 };
    o.b = 2;
    console.log(o.a, o.b); //1 2
</code></pre>

<h2 id="toc_1"> JavaScript对象的两类属性</h2>

<h3 id="toc_2"> 第一类属性数据属性</h3>

<p>数据属性接近于其他语言的属性概念，具有四个特征：</p>

<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性是否能被赋值。</li>
<li>enumerable：决定for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。<br/>
### 第二类属性访问器属性（getter/setter）<br/>
访问器属性也有四个特征：</li>
<li>getter：函数或undefined，在取属性值时被调用。</li>
<li>setter：函数或undefined，在设置属性值时被调用。</li>
<li>enumerable：决定for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。<br/>
## 总结<br/>
实际上 JavaScript 对象的运行时是一个“属性的集合”。<br/>
&gt; 属性key：字符串或者 Symbol<br/>
&gt; 值value：数据属性特征值或者访问器属性特征值<br/>
对象是一个属性的索引结构（索引结构是一类常见的数据结构，可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript中的类型]]></title>
    <link href="blog.2019919.top/16083847578374.html"/>
    <updated>2020-12-19T21:32:37+08:00</updated>
    <id>blog.2019919.top/16083847578374.html</id>
    <content type="html"><![CDATA[
<p>根据最新的语言标准，javascript规定了7种语言类型：</p>

<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Symbol</li>
<li>Object</li>
</ul>

<blockquote>
<p>但是在MDN中是这样描述的：<br/>
基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：string，number，bigint，boolean，null，undefined，symbol  (ECMAScript 2016新增)。</p>
</blockquote>

<h2 id="toc_0">Undefined</h2>

<p>void运算把任意一个表达式变成undefined。</p>

<pre><code class="language-markup">&lt;a href=&quot;javascript: void(0)&quot;&gt;&lt;/a&gt;
</code></pre>

<p>常用以上代码来描述一个没有锚点的死链接。<br/>
往往应用void 0来做undefined使用的原因是<strong>Javascript中undefined是一个变量，并非关键字，可以被篡改</strong>。</p>

<h2 id="toc_1">Null</h2>

<p>null是关键字，可以放心使用null关键字获取null的值。</p>

<h2 id="toc_2">Boolean</h2>

<p>true 和 false。</p>

<h2 id="toc_3">String</h2>

<p>String并非“字符串”，而是字符串的UTF16编码，所以charAt、charCodeAt、length等方法都是针对UTF16编码。所以字符串的最大长度实际上是受字符串的编码长度影响的,String 有最大长度是 2<sup>53</sup> - 1是指编码长度，并不是字符数。</p>

<blockquote>
<p><strong>Unicode</strong> <br/>
Unicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。<br/>
UTF是Unicode的编码格式，<br/>
他具体定义 了 Unicode 字符在计算机中存取方法。<br/>
常见的就是UTF-16和UTF-8 <br/>
UTF-16用两个字节表示一个Unicode转化格式，定长两个字节16bit，所以是UTF-16。<br/>
UTF-8因为很大一部分字符用一个字节就可以表示现在要的两个字节表示，UTF-8采用了一种变长的技术，每个编码区域有不同的字码长度，不同类型的字符可以是由1~6个字节组成，看前两字节的值来确定是什么类型的字符。</p>
</blockquote>

<p><strong>string是不可变的引用类型。</strong>他拥有值类型的特性。</p>

<h2 id="toc_4">Number</h2>

<p><strong>NAN</strong>编码中很少直接使用。通常都是在计算失败时，作为 Math 的某个方法的返回值出现的，比较NAN必须使用 Number.isNaN() 或 isNaN() 函数。<br/>
但是，请注意isNaN（）和Number.isNaN（）之间的区别：如果当前值是NaN，或者将其强制转换为数字后将是NaN，则前者将返回true。<br/>
<strong>Infinity</strong> 无穷大<br/>
<strong>-Infinity</strong> 负无穷大<br/>
-0和0在进行除法作为除数的时候符号带入计算。</p>

<p>经典问题0.1+0.2不能等于0.3，浮点数运算的精度问题导致等式左右不是严格相等，而是相差了个微小的值。<br/>
正确的比较方法是：</p>

<pre><code class="language-javascript">console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);
</code></pre>

<p><strong>检查等式两边的差值是否小于最小精度</strong>才是正确比较浮点数的方法。</p>

<h2 id="toc_5">Symbol</h2>

<p>这个英文单词就是象征和符号的意思,它是一切非字符串的对象key的集合。一个symbol值能作为对象属性的标识符,这是该数据类型仅有的目的。<br/>
Symbol() 函数会返回Symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的Symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：&quot;new Symbol()&quot;。</p>

<pre><code class="language-javascript">var mySymbol = Symbol(&quot;my symbol&quot;);
</code></pre>

<p>每个从Symbol()返回的symbol值都是唯一的。</p>

<pre><code class="language-javascript">console.log(Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;));
// expected output: false
</code></pre>

<h2 id="toc_6">Object</h2>

<p>在JavaScript中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是key-value结构，key可以是字符串或者Symbol类型。<br/>
JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：</p>

<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol</li>
</ul>

<p>所以3与new Number(3)是完全不同的值，一个是Number类型，一个是对象类型。<br/>
日常代码中可以把对象的方法在基本类型上使用</p>

<pre><code class="language-javascript">console.log(&quot;abc&quot;.charAt(0)); //a
</code></pre>

<p>而往常常理解为String类型有charAt方法，看来这个理解是错误的。<br/>
甚至可以在基本类型的亲戚对象的原型中添加方法，这样任何相同基本类型的变量都可以调用这个方法。</p>

<pre><code class="language-javascript">    Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;);

    var a = Symbol(&quot;a&quot;);
    console.log(typeof a); //symbol，a并非对象
    a.hello(); //hello，有效
</code></pre>

<p>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能够在基础类型上条用对应对象的方法。（感觉类似一个原型链的应用）</p>

<blockquote>
<p>值类型给引用类型叫装箱<br/>
引用类型给值类型叫拆箱<br/>
给我的理解是将多个属性打包成对象就是装箱，将对象的属性独立出来就是拆箱。</p>
</blockquote>

<h2 id="toc_7">类型转换</h2>

<p>==运算很臭，应该是没有意义去记住他的比较结果，只需要记住只用===来比较。</p>

<h3 id="toc_8">StringToNumber</h3>

<p>字符串到数字的类型转换支持十进制、二进制、八进制和十六进制,还包括正负号科学计数法，可以使用大写或者小写的 e 来表示。<br/>
parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。<br/>
<strong>Number</strong> 是比 parseInt 和 parseFloat 更好的选择。</p>

<h3 id="toc_9">NumberToString</h3>

<p>当Number绝对值较大或者较小时，字符串为了保证不会过长会用科学记数法表示。</p>

<h3 id="toc_10">装箱转换</h3>

<p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。<br/>
Symbole函数无法使用new来调用，可以利用call方法来强迫装箱。</p>

<pre><code class="language-javascript">    var symbolObject = (function(){ return this; }).call(Symbol(&quot;a&quot;));

    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true
</code></pre>

<p>我们可以用 console.log 看一下 symbolObject 的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象，这里再次应用了js原型。<br/>
装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。<br/>
使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p>

<pre><code class="language-javascript">    var symbolObject = Object(Symbol(&quot;a&quot;));

    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true
</code></pre>

<h3 id="toc_11">拆箱转换</h3>

<p>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）<a href="https://juejin.cn/post/6844903555548053511">JavaScript 对象转换到基本类型值算法 ToPrimitive</a>。对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p>

<pre><code class="language-javascript">    var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }

    o * 2
    // valueOf
    // toString
    // TypeError
</code></pre>

<p>进行 o*2 这个运算的时候，先执行了 valueOf，接下来是 toString，最后抛出了一个TypeError，拆箱转换失败了。</p>

<pre><code class="language-javascript">    var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }

   String(o)
    // toString
    // valueOf
    // TypeError
</code></pre>

<p>到 String 的拆箱转换会优先调用 toString。</p>

<blockquote>
<p>在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为.</p>

<pre><code class="language-javascript">var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }
   
o[Symbol.toPrimitive] = () =&gt; {console.log(&quot;toPrimitive&quot;); return &quot;hello&quot;}
    console.log(o + &quot;&quot;)
    // toPrimitive
    // hello
</code></pre>
</blockquote>

<h2 id="toc_12">补充</h2>

<p>除了这七种语言类型，还有一些语言的实现者更关心的规范类型。</p>

<ul>
<li>List 和 Record： 用于描述函数传参过程。</li>
<li>Set：主要用于解释字符集等。</li>
<li>Completion Record：用于描述异常、跳出等语句执行过程。</li>
<li>Reference：用于描述对象属性访问、delete 等。</li>
<li>Property Descriptor：用于描述对象的属性。</li>
<li>Lexical Environment 和 Environment Record：用于描述变量和作用域。</li>
<li>Data Block：用于描述二进制数据。</li>
</ul>

<p>标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。<br/>
<img src="media/16083847578374/16084396239357.jpg" alt="" style="width:305px;"/><br/>
JavaScript 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript原型和原型链]]></title>
    <link href="blog.2019919.top/16080322533005.html"/>
    <updated>2020-12-15T19:37:33+08:00</updated>
    <id>blog.2019919.top/16080322533005.html</id>
    <content type="html"><![CDATA[
<p>今天刚开始学习【重学前端】的课程，讲到装箱转换的时候提到了函数的<code>call</code>方法，而<code>call</code>方法在我的印象中就只有<code>call</code>约等于<code>apply</code>，然后就再没有然后了。在我想深入了解下<code>call</code>方法的时候又发现了有人在同时讲解原型，而于此同时我看到了知乎上的一个贴<a href="https://www.zhihu.com/question/60165921">面试一个5年的前端，却连原型链也搞不清楚，满口都是Vue，React之类的实现，这样的人该用吗？</a>，这我不看内容我就惊呆了，这标题不就是在说我吗。带着各种心情赶紧学习下到底什么是原型和原型链。</p>

<h2 id="toc_0">原型</h2>

<pre><code class="language-text">prototype  [ˈproʊtətaɪp]  原型
</code></pre>

<p>OK完了😊！</p>

<p>下面这个图很多大神都有画过，下面记录下我自己的理解和实验。</p>

<p><img src="media/16080322533005/16080400429560.jpg" alt="" style="width:450px;"/></p>

<h3 id="toc_1">构造函数视角</h3>

<p>函数可以用来做构造器，也就是constructor，而构造器也可以称为类。<br/>
通过构造器<code>Apple</code>来创建一个对象对象<code>apple</code>。</p>

<p><img src="media/16080322533005/16080397593797.jpg" alt="" style="width:198px;"/></p>

<p><strong>构造函数创建了实例对象</strong>，这是构造函数与实例对象的关系。</p>

<hr/>

<p><strong>构造函数有一个属性叫做propotype,他指向了原型对象。</strong></p>

<p><img src="media/16080322533005/16080405364424.jpg" alt="" style="width:299px;"/></p>

<p>这里的原型对象有些大神也写做<code>[[propotype]]</code>，这里我猜测是为了区分propotype的属性。</p>

<h3 id="toc_2">原型对象视角</h3>

<p><strong>原型对象的constructor属性指向了构造函数</strong>。</p>

<p><img src="media/16080322533005/16080407735350.jpg" alt="" style="width:382px;"/></p>

<p>这里用构造器的原型对象的constructor方法来创建一个<code>badApple</code>，会发现它和<code>apple</code>的类型是相等的。</p>

<h3 id="toc_3">实例对象视角</h3>

<p>对象也有一个属性__propo__，这是一个隐式属性，<strong>对象的__propo__指向了他的构造函数的原型对象。</strong><br/>
也就是说<code>Apple</code>的propotype属性和<code>apple</code>、<code>badApple</code>的__propo__指向了同一个地址。</p>

<p><img src="media/16080322533005/16080419126552.jpg" alt="" style="width:318px;"/></p>

<h3 id="toc_4">由函数引出原型链</h3>

<p>函数是JS中的第一类对象，在Javascript中，对象所拥有的函数也同样拥有，也就是说构造函数<code>Apple</code>也同样会有__propo__属性去指向他的父类的原型对象，为了理清这乱七八糟的关系，就有了下面【对象-函数-构造函数-实例对象】这样的一个关系图，也就是原型链图。</p>

<h2 id="toc_5">原型链</h2>

<p><img src="media/16080322533005/16080423510561.jpg" alt=""/></p>

<p>这张图理解了上面的内容之后就感觉容易多了，总结一下有以下几点需要注意。</p>

<ul>
<li>任何函数的父类都是Function函数，也就是任何函数的__proto__指向Function的原型对象,这里同样包含了Function函数自己。</li>
<li>Object函数的__proto__指向Function的原型对象
<code>TODO</code></li>
</ul>

<h2 id="toc_6"> ES6中的类</h2>

<p>类的写法也是由原型运行时来承载的，逻辑上JavaScript认为每个类是有共同原型的一组对象，类中定义的方法和属性会被卸载原型对象之上。此外最重要的是类提供了继承能力。</p>

<pre><code class="language-javascript">class Animal { 
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(this.name + &#39; makes a noise.&#39;);
  }
}
class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }
  speak() {
    console.log(this.name + &#39; barks.&#39;);
  }
}
let d = new Dog(&#39;Mitzie&#39;);
d.speak(); // Mitzie barks.
</code></pre>

<p>以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p>

<blockquote>
<p>super关键字用于访问和调用一个对象的父对象上的函数。<br/>
在构造函数中使用时，super关键字将单独出现，并且必须在使用this关键字之前使用。</p>

<pre><code class="language-javascript">super([arguments]);
// 调用 父对象/父类 的构造函数
super.functionOnParent([arguments]);
// 调用 父对象/父类 上的方法
</code></pre>
</blockquote>

<h2 id="toc_7">最后</h2>

<p>在我继续学习这个课程之后，发现老师讲了什么是原型。。。尴尬！先过一遍全部课程，再回过头来自己输出一遍。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[angular mock的使用]]></title>
    <link href="blog.2019919.top/16073237309370.html"/>
    <updated>2020-12-07T14:48:50+08:00</updated>
    <id>blog.2019919.top/16073237309370.html</id>
    <content type="html"><![CDATA[
<p>在现在公司中，并没有真的前后端分离，往往是前后端一同疏通测试，美其名曰节省时间全面发展。因此至今没有单独写过mock进行前端自己的单体测试。这一次调查下mock的使用。</p>

<h2 id="toc_0">Angular的environments文件</h2>

<p><img src="media/16073237309370/16073245939102.jpg" alt="" style="width:746px;"/></p>

<p>environments文件分别是每个环境对应的配置。<br/>
每个文件与环境的对应关系存放于<code>angular.json</code>中。</p>

<p><img src="media/16073237309370/16073266078090.jpg" alt="" style="width:555px;"/></p>

<p>这个设定指定了cli在进行<code>production build</code>的时候将<code>environment.ts</code>替换成<code>environment.prod.ts</code>，即将开发环境的环境配置替换成生产环境的开发配置。<br/>
在这里设置isMock属性，让mock在生产环境中自动启动，开发环境~~~~中自动关闭。</p>

<h2 id="toc_1">Angular的main.ts文件</h2>

<p><img src="media/16073237309370/16073284745167.jpg" alt="" style="width:555px;"/></p>

<p>同样在cli中webpack的入口程序被设置为<code>src/main.ts</code>，也就是说<code>main.ts</code>是我们整个angualr的入口程序。我们在这里判断当前环境是否引入mock服务。</p>

<p><img src="media/16073237309370/16073286403589.jpg" alt="" style="width:566px;"/></p>

<h2 id="toc_2">mock服务的实现</h2>

<h3 id="toc_3">1.选择自己的包管理器添加mock的指令安装mock</h3>

<pre><code class="language-text">npm install mockjs --save
</code></pre>

<pre><code class="language-text">yarn add mockjs
</code></pre>

<h3 id="toc_4">2.创建mock文件，并添加到打包配置文件中</h3>

<p>又是<code>angualr.json</code>，在scripts中添加自己的mock文件路径，让webpack打包angular时同时打包我们的mock文件。<br/>
<img src="media/16073237309370/16073291483432.jpg" alt="" style="width:541px;"/></p>

<h3 id="toc_5">3.编写mock服务</h3>

<ul>
<li><p>首先导入mockjs。</p>
<pre><code class="language-typescript">import * as Mock from &#39;mockjs&#39;;
</code></pre></li>
<li><p>然后拦截请求，返回假数据</p>
<pre><code class="language-typescript">Mock.mock(&#39;http://localhost:9080/list&#39;, {
message: &#39;调用成功&#39;,<br/>
&#39;data|10&#39;: [{<br/>
&#39;id|+1&#39;: 1,<br/>
title: &#39;This is a title&#39;,<br/>
tags: [<br/>
  {<br/>
    id: 1,<br/>
    name: &#39;aaaa&#39;,<br/>
    color: &#39;red&#39;<br/>
  }<br/>
],<br/>
&#39;note|100&#39;: &#39;There are notes!&#39;<br/>
}]<br/>
});
</code></pre></li>
</ul>

<h2 id="toc_6">最后鼓励下自己</h2>

<p>angular中如何加载mock服务就到这，mock中的精髓是通过代码来生成数据，一行代码就可以生成千万条带有逻辑的数据，这些还需要细读一下API。这次记录是通过编译打包时的顺序来记录mock的使用方法，今后需要更深入的理解angular要多多从这个方向调查问题。</p>

]]></content>
  </entry>
  
</feed>
