<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[十]]></title>
  <link href="blog.2019919.top/atom.xml" rel="self"/>
  <link href="blog.2019919.top/"/>
  <updated>2020-12-21T17:58:03+08:00</updated>
  <id>blog.2019919.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript全部的对象分类]]></title>
    <link href="blog.2019919.top/16085442753431.html"/>
    <updated>2020-12-21T17:51:15+08:00</updated>
    <id>blog.2019919.top/16085442753431.html</id>
    <content type="html"><![CDATA[
<p>之前讲解的对象只是特定的一部分，并不能涵盖全部的JavaScript对象。<br/>
比如无论怎样编写代码都没法绕开Array，实现一个跟原生数组行为一模一样的对象，因为原生数组底层实现了一个自动随着下标变化的length属性。并且也无法依靠JavaScript代码实现div对象，需要用document.createElement来创建。这也说明了JavaScript的对象机制并非简单的属性集合+原型。</p>

<h2 id="toc_0"> JavaScript中的对象分类</h2>

<p>* 宿主对象（host Objects）<br/>
由JavaScript宿主环境提供的对象，他们的行为完全由宿主环境决定。<br/>
* 内置对象（Built-in Objects）<br/>
由JavaScript语言提供的对象。<br/>
    - 固有对象（Intrinsic Objects）<br/>
    由便准规定，随着JavaScript运行时创建而自动创建的对象实例。<br/>
    - 原生对象（Native Objects）<br/>
    可以由用户通过Array、RegExp等内置构造器或者特殊语法创建的对象。<br/>
    - 普通对象（Ordinary Objects）<br/>
    由{}语法、Object构造器或者calss关键字定义类创建的对象，它能够被原型继承。</p>

<h2 id="toc_1"> 宿主对象</h2>

<p>前端最熟悉的就是浏览器环境中的宿主。在浏览器环境中全局对象是window，window上又有很多属性，如document。<br/>
实际上这个全局对象window上的属性一部分来自于JavaScript语言，一部分来自浏览器环境。</p>

<h2 id="toc_2"> 内置对象·固有对象</h2>

<p>固有对象是由标准规定，随着JavaScript运行时创建而自动创建的对象实例，类似基础库的角色。比如window、document等。</p>

<h2 id="toc_3"> 内置对象·原生对象</h2>

<p>能够通过语言本身的构造器创建的对象叫做原生对象。<br/>
老师将对象分成了如下五类：<br/>
通过这些构造器可以通过new运算创建新的对象，</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript的面向对象]]></title>
    <link href="blog.2019919.top/16085441443213.html"/>
    <updated>2020-12-21T17:49:04+08:00</updated>
    <id>blog.2019919.top/16085441443213.html</id>
    <content type="html"><![CDATA[
<p>在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。而 JavaScript 早年却选择了一个更为冷门的方式：原型。<br/>
这节课了解一下 JavaScript 是如何设计对象模型的。</p>

<h2 id="toc_0"> JavaScript对象的特征</h2>

<p>* 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。<br/>
* 对象有状态：对象具有状态，同一对象可能处于不同状态之下。<br/>
* 对象具有行为：即对象的状态，可能因为他的行为产生变迁。<br/>
一般而言，各语言对象唯一标识性都是用内存地址来体现。</p>

<pre><code class="language-javascript">    var o1 = { a: 1 };
    var o2 = { a: 1 };
    console.log(o1 == o2); // false
</code></pre>

<p>两个一模一样的对象，但是打印结果是false，两个对象并不是同一个对象。<br/>
“状态和行为”在不同语言中会使用不同的术语来描述他们，C++中是“成员变量和成员函数”，Java中则称为“属性和方法”。在JavaScript中，将状态和行为统一抽象为“属性”。</p>

<pre><code class="language-javascript">    var o = { 
        d: 1,
        f() {
            console.log(this.d);
            }    
        };
</code></pre>

<p>o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。<br/>
JavaScript 中对象独有的特色是：<strong>对象具有高度的动态性</strong>，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p>

<pre><code class="language-javascript">    var o = { a: 1 };
    o.b = 2;
    console.log(o.a, o.b); //1 2
</code></pre>

<h2 id="toc_1"> JavaScript对象的两类属性</h2>

<h3 id="toc_2"> 第一类属性数据属性</h3>

<p>数据属性接近于其他语言的属性概念，具有四个特征：<br/>
* value：就是属性的值。<br/>
* writable：决定属性是否能被赋值。<br/>
* enumerable：决定for in 能否枚举该属性。<br/>
* configurable：决定该属性能否被删除或者改变特征值。</p>

<h3 id="toc_3"> 第二类属性访问器属性（getter/setter）</h3>

<p>访问器属性也有四个特征：<br/>
* getter：函数或undefined，在取属性值时被调用。<br/>
* setter：函数或undefined，在设置属性值时被调用。<br/>
* enumerable：决定for in 能否枚举该属性。<br/>
* configurable：决定该属性能否被删除或者改变特征值。</p>

<h2 id="toc_4"> 总结</h2>

<p>实际上 JavaScript 对象的运行时是一个“属性的集合”。</p>

<blockquote>
<p> 属性key：字符串或者 Symbol<br/>
 值value：数据属性特征值或者访问器属性特征值<br/>
对象是一个属性的索引结构（索引结构是一类常见的数据结构，可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chapter Shopping]]></title>
    <link href="blog.2019919.top/16084764191221.html"/>
    <updated>2020-12-20T23:00:19+08:00</updated>
    <id>blog.2019919.top/16084764191221.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript中的类型]]></title>
    <link href="blog.2019919.top/16083847578374.html"/>
    <updated>2020-12-19T21:32:37+08:00</updated>
    <id>blog.2019919.top/16083847578374.html</id>
    <content type="html"><![CDATA[
<p>根据最新的语言标准，javascript规定了7种语言类型：</p>

<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Symbol</li>
<li>Object</li>
</ul>

<blockquote>
<p>但是在MDN中是这样描述的：<br/>
基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：string，number，bigint，boolean，null，undefined，symbol  (ECMAScript 2016新增)。</p>
</blockquote>

<h2 id="toc_0">Undefined</h2>

<p>void运算把任意一个表达式变成undefined。</p>

<pre><code class="language-markup">&lt;a href=&quot;javascript: void(0)&quot;&gt;&lt;/a&gt;
</code></pre>

<p>常用以上代码来描述一个没有锚点的死链接。<br/>
往往应用void 0来做undefined使用的原因是<strong>Javascript中undefined是一个变量，并非关键字，可以被篡改</strong>。</p>

<h2 id="toc_1">Null</h2>

<p>null是关键字，可以放心使用null关键字获取null的值。</p>

<h2 id="toc_2">Boolean</h2>

<p>true 和 false。</p>

<h2 id="toc_3">String</h2>

<p>String并非“字符串”，而是字符串的UTF16编码，所以charAt、charCodeAt、length等方法都是针对UTF16编码。所以字符串的最大长度实际上是受字符串的编码长度影响的,String 有最大长度是 2<sup>53</sup> - 1是指编码长度，并不是字符数。</p>

<blockquote>
<p><strong>Unicode</strong> <br/>
Unicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。<br/>
UTF是Unicode的编码格式，<br/>
他具体定义 了 Unicode 字符在计算机中存取方法。<br/>
常见的就是UTF-16和UTF-8 <br/>
UTF-16用两个字节表示一个Unicode转化格式，定长两个字节16bit，所以是UTF-16。<br/>
UTF-8因为很大一部分字符用一个字节就可以表示现在要的两个字节表示，UTF-8采用了一种变长的技术，每个编码区域有不同的字码长度，不同类型的字符可以是由1~6个字节组成，看前两字节的值来确定是什么类型的字符。</p>
</blockquote>

<p><strong>string是不可变的引用类型。</strong>他拥有值类型的特性。</p>

<h2 id="toc_4">Number</h2>

<p><strong>NAN</strong>编码中很少直接使用。通常都是在计算失败时，作为 Math 的某个方法的返回值出现的，比较NAN必须使用 Number.isNaN() 或 isNaN() 函数。<br/>
但是，请注意isNaN（）和Number.isNaN（）之间的区别：如果当前值是NaN，或者将其强制转换为数字后将是NaN，则前者将返回true。<br/>
<strong>Infinity</strong> 无穷大<br/>
<strong>-Infinity</strong> 负无穷大<br/>
-0和0在进行除法作为除数的时候符号带入计算。</p>

<p>经典问题0.1+0.2不能等于0.3，浮点数运算的精度问题导致等式左右不是严格相等，而是相差了个微小的值。<br/>
正确的比较方法是：</p>

<pre><code class="language-javascript">console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);
</code></pre>

<p><strong>检查等式两边的差值是否小于最小精度</strong>才是正确比较浮点数的方法。</p>

<h2 id="toc_5">Symbol</h2>

<p>这个英文单词就是象征和符号的意思,它是一切非字符串的对象key的集合。一个symbol值能作为对象属性的标识符,这是该数据类型仅有的目的。<br/>
Symbol() 函数会返回Symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的Symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：&quot;new Symbol()&quot;。</p>

<pre><code class="language-javascript">var mySymbol = Symbol(&quot;my symbol&quot;);
</code></pre>

<p>每个从Symbol()返回的symbol值都是唯一的。</p>

<pre><code class="language-javascript">console.log(Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;));
// expected output: false
</code></pre>

<h2 id="toc_6">Object</h2>

<p>在JavaScript中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是key-value结构，key可以是字符串或者Symbol类型。<br/>
JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：</p>

<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol</li>
</ul>

<p>所以3与new Number(3)是完全不同的值，一个是Number类型，一个是对象类型。<br/>
日常代码中可以把对象的方法在基本类型上使用</p>

<pre><code class="language-javascript">console.log(&quot;abc&quot;.charAt(0)); //a
</code></pre>

<p>而往常常理解为String类型有charAt方法，看来这个理解是错误的。<br/>
甚至可以在基本类型的亲戚对象的原型中添加方法，这样任何相同基本类型的变量都可以调用这个方法。</p>

<pre><code class="language-javascript">    Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;);

    var a = Symbol(&quot;a&quot;);
    console.log(typeof a); //symbol，a并非对象
    a.hello(); //hello，有效
</code></pre>

<p>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能够在基础类型上条用对应对象的方法。（感觉类似一个原型链的应用）</p>

<blockquote>
<p>值类型给引用类型叫装箱<br/>
引用类型给值类型叫拆箱<br/>
给我的理解是将多个属性打包成对象就是装箱，将对象的属性独立出来就是拆箱。</p>
</blockquote>

<h2 id="toc_7">类型转换</h2>

<p>==运算很臭，应该是没有意义去记住他的比较结果，只需要记住只用===来比较。</p>

<h3 id="toc_8">StringToNumber</h3>

<p>字符串到数字的类型转换支持十进制、二进制、八进制和十六进制,还包括正负号科学计数法，可以使用大写或者小写的 e 来表示。<br/>
parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。<br/>
<strong>Number</strong> 是比 parseInt 和 parseFloat 更好的选择。</p>

<h3 id="toc_9">NumberToString</h3>

<p>当Number绝对值较大或者较小时，字符串为了保证不会过长会用科学记数法表示。</p>

<h3 id="toc_10">装箱转换</h3>

<p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。<br/>
Symbole函数无法使用new来调用，可以利用call方法来强迫装箱。</p>

<pre><code class="language-javascript">    var symbolObject = (function(){ return this; }).call(Symbol(&quot;a&quot;));

    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true
</code></pre>

<p>我们可以用 console.log 看一下 symbolObject 的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象，这里再次应用了js原型。<br/>
装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。<br/>
使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p>

<pre><code class="language-javascript">    var symbolObject = Object(Symbol(&quot;a&quot;));

    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true
</code></pre>

<h3 id="toc_11">拆箱转换</h3>

<p>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）<a href="https://juejin.cn/post/6844903555548053511">JavaScript 对象转换到基本类型值算法 ToPrimitive</a>。对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p>

<pre><code class="language-javascript">    var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }

    o * 2
    // valueOf
    // toString
    // TypeError
</code></pre>

<p>进行 o*2 这个运算的时候，先执行了 valueOf，接下来是 toString，最后抛出了一个TypeError，拆箱转换失败了。</p>

<pre><code class="language-javascript">    var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }

   String(o)
    // toString
    // valueOf
    // TypeError
</code></pre>

<p>到 String 的拆箱转换会优先调用 toString。</p>

<blockquote>
<p>在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为.</p>

<pre><code class="language-javascript">var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }
   
o[Symbol.toPrimitive] = () =&gt; {console.log(&quot;toPrimitive&quot;); return &quot;hello&quot;}
    console.log(o + &quot;&quot;)
    // toPrimitive
    // hello
</code></pre>
</blockquote>

<h2 id="toc_12">补充</h2>

<p>除了这七种语言类型，还有一些语言的实现者更关心的规范类型。</p>

<ul>
<li>List 和 Record： 用于描述函数传参过程。</li>
<li>Set：主要用于解释字符集等。</li>
<li>Completion Record：用于描述异常、跳出等语句执行过程。</li>
<li>Reference：用于描述对象属性访问、delete 等。</li>
<li>Property Descriptor：用于描述对象的属性。</li>
<li>Lexical Environment 和 Environment Record：用于描述变量和作用域。</li>
<li>Data Block：用于描述二进制数据。</li>
</ul>

<p>标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。<br/>
<img src="media/16083847578374/16084396239357.jpg" alt="" style="width:305px;"/><br/>
JavaScript 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript原型和原型链]]></title>
    <link href="blog.2019919.top/16080322533005.html"/>
    <updated>2020-12-15T19:37:33+08:00</updated>
    <id>blog.2019919.top/16080322533005.html</id>
    <content type="html"><![CDATA[
<p>今天刚开始学习【重学前端】的课程，讲到装箱转换的时候提到了函数的<code>call</code>方法，而<code>call</code>方法在我的印象中就只有<code>call</code>约等于<code>apply</code>，然后就再没有然后了。在我想深入了解下<code>call</code>方法的时候又发现了有人在同时讲解原型，而于此同时我看到了知乎上的一个贴<a href="https://www.zhihu.com/question/60165921">面试一个5年的前端，却连原型链也搞不清楚，满口都是Vue，React之类的实现，这样的人该用吗？</a>，这我不看内容我就惊呆了，这标题不就是在说我吗。带着各种心情赶紧学习下到底什么是原型和原型链。</p>

<h2 id="toc_0">原型</h2>

<pre><code class="language-text">prototype  [ˈproʊtətaɪp]  原型
</code></pre>

<p>OK完了😊！</p>

<p>下面这个图很多大神都有画过，下面记录下我自己的理解和实验。</p>

<p><img src="media/16080322533005/16080400429560.jpg" alt="" style="width:450px;"/></p>

<h3 id="toc_1">构造函数视角</h3>

<p>函数可以用来做构造器，也就是constructor，而构造器也可以称为类。<br/>
通过构造器<code>Apple</code>来创建一个对象对象<code>apple</code>。</p>

<p><img src="media/16080322533005/16080397593797.jpg" alt="" style="width:198px;"/></p>

<p><strong>构造函数创建了实例对象</strong>，这是构造函数与实例对象的关系。</p>

<hr/>

<p><strong>构造函数有一个属性叫做propotype,他指向了原型对象。</strong></p>

<p><img src="media/16080322533005/16080405364424.jpg" alt="" style="width:299px;"/></p>

<p>这里的原型对象有些大神也写做<code>[[propotype]]</code>，这里我猜测是为了区分propotype的属性。</p>

<h3 id="toc_2">原型对象视角</h3>

<p><strong>原型对象的constructor属性指向了构造函数</strong>。</p>

<p><img src="media/16080322533005/16080407735350.jpg" alt="" style="width:382px;"/></p>

<p>这里用构造器的原型对象的constructor方法来创建一个<code>badApple</code>，会发现它和<code>apple</code>的类型是相等的。</p>

<h3 id="toc_3">实例对象视角</h3>

<p>对象也有一个属性__propo__，这是一个隐式属性，<strong>对象的__propo__指向了他的构造函数的原型对象。</strong><br/>
也就是说<code>Apple</code>的propotype属性和<code>apple</code>、<code>badApple</code>的__propo__指向了同一个地址。</p>

<p><img src="media/16080322533005/16080419126552.jpg" alt="" style="width:318px;"/></p>

<h3 id="toc_4">由函数引出原型链</h3>

<p>函数是JS中的第一类对象，在Javascript中，对象所拥有的函数也同样拥有，也就是说构造函数<code>Apple</code>也同样会有__propo__属性去指向他的父类的原型对象，为了理清这乱七八糟的关系，就有了下面【对象-函数-构造函数-实例对象】这样的一个关系图，也就是原型链图。</p>

<h2 id="toc_5">原型链</h2>

<p><img src="media/16080322533005/16080423510561.jpg" alt=""/></p>

<p>这张图理解了上面的内容之后就感觉容易多了，总结一下有以下几点需要注意。</p>

<ul>
<li>任何函数的父类都是Function函数，也就是任何函数的__proto__指向Function的原型对象,这里同样包含了Function函数自己。</li>
<li>Object函数的__proto__指向Function的原型对象
<code>TODO</code></li>
</ul>

<h2 id="toc_6"> ES6中的类</h2>

<p>类的写法也是由原型运行时来承载的，逻辑上JavaScript认为每个类是有共同原型的一组对象，类中定义的方法和属性会被卸载原型对象之上。此外最重要的是类提供了继承能力。</p>

<pre><code class="language-javascript">class Animal { 
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(this.name + &#39; makes a noise.&#39;);
  }
}
class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }
  speak() {
    console.log(this.name + &#39; barks.&#39;);
  }
}
let d = new Dog(&#39;Mitzie&#39;);
d.speak(); // Mitzie barks.
</code></pre>

<p>以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p>

<blockquote>
<p>super关键字用于访问和调用一个对象的父对象上的函数。<br/>
在构造函数中使用时，super关键字将单独出现，并且必须在使用this关键字之前使用。</p>

<pre><code class="language-javascript">super([arguments]);
// 调用 父对象/父类 的构造函数
super.functionOnParent([arguments]);
// 调用 父对象/父类 上的方法
</code></pre>
</blockquote>

<h2 id="toc_7">最后</h2>

<p>在我继续学习这个课程之后，发现老师讲了什么是原型。。。尴尬！先过一遍全部课程，再回过头来自己输出一遍。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新认识下熟悉的浏览器]]></title>
    <link href="blog.2019919.top/16076922632055.html"/>
    <updated>2020-12-11T21:11:03+08:00</updated>
    <id>blog.2019919.top/16076922632055.html</id>
    <content type="html"><![CDATA[
<p>前端程序员每天都在抠代码，各种各样的技术，千变万化的框架，但最后组装压缩在一起，就是为了伺候操作系统的一个软件————浏览器。这一次，在阅读了三天各大博主的精华后，就chrome浏览器来做一下自己的整理记录。<br/>
双击桌面chrome浏览器发生了什么呢：</p>

<blockquote>
<p>系统创建了一个chrome的进程。</p>

<blockquote>
<p>从多标签页app的开始，一个chrome进程中有了多个子tab进程。</p>

<blockquote>
<p>每个tab进程内有下面这些进程：<br/>
<a href="#toc_0">渲染引擎</a><br/>
<a href="#toc_1">JS引擎</a><br/>
<a href="#toc_2">用户界面</a><br/>
<a href="#toc_3">存储</a></p>
</blockquote>
</blockquote>
</blockquote>

<h2 id="toc_0">渲染引擎</h2>

<p>最初渲染引擎和JS引擎并没有分家，在一起统称为浏览器内核，后来JS引擎越来越独立，内核就完全倾向于渲染引擎。chrome原来使用的就是webkit引擎，后来为了不受制于苹果，基于webkit改编了blink，将其内置于chrome中。</p>

<h2 id="toc_1">JS引擎</h2>

<h2 id="toc_2">用户界面</h2>

<h2 id="toc_3">存储</h2>

<h2 id="toc_4">感受</h2>

<p>现在对学习的感觉是即入迷又无力，学到这里的时候回想一下，我最开始只是看到了一篇短文，浅谈JS事件的原理，而当时的那篇文章真的是比较浅，我现在已经忘了内容是什么了，但是在我不断深入的时候，每每看到一个强大的人的博客的时候就会发现一些新内容，当我为了弄懂其中一个小名词的时候又会引出无数的子节点，真的是树无处不在，越来越入迷，也越来越吃力。虽然我不知道整个树有多大，但是当学到末梢节点的时候回头来总结一下，看看我捋顺的健壮的树枝，真的是振奋人心。</p>

<h2 id="toc_5">参考</h2>

<p><a href="https://segmentfault.com/a/1190000018806562">webkit引擎和v8引擎工作原理</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[angular mock的使用]]></title>
    <link href="blog.2019919.top/16073237309370.html"/>
    <updated>2020-12-07T14:48:50+08:00</updated>
    <id>blog.2019919.top/16073237309370.html</id>
    <content type="html"><![CDATA[
<p>在现在公司中，并没有真的前后端分离，往往是前后端一同疏通测试，美其名曰节省时间全面发展。因此至今没有单独写过mock进行前端自己的单体测试。这一次调查下mock的使用。</p>

<h2 id="toc_0">Angular的environments文件</h2>

<p><img src="media/16073237309370/16073245939102.jpg" alt="" style="width:746px;"/></p>

<p>environments文件分别是每个环境对应的配置。<br/>
每个文件与环境的对应关系存放于<code>angular.json</code>中。</p>

<p><img src="media/16073237309370/16073266078090.jpg" alt="" style="width:555px;"/></p>

<p>这个设定指定了cli在进行<code>production build</code>的时候将<code>environment.ts</code>替换成<code>environment.prod.ts</code>，即将开发环境的环境配置替换成生产环境的开发配置。<br/>
在这里设置isMock属性，让mock在生产环境中自动启动，开发环境~~~~中自动关闭。</p>

<h2 id="toc_1">Angular的main.ts文件</h2>

<p><img src="media/16073237309370/16073284745167.jpg" alt="" style="width:555px;"/></p>

<p>同样在cli中webpack的入口程序被设置为<code>src/main.ts</code>，也就是说<code>main.ts</code>是我们整个angualr的入口程序。我们在这里判断当前环境是否引入mock服务。</p>

<p><img src="media/16073237309370/16073286403589.jpg" alt="" style="width:566px;"/></p>

<h2 id="toc_2">mock服务的实现</h2>

<h3 id="toc_3">1.选择自己的包管理器添加mock的指令安装mock</h3>

<pre><code class="language-text">npm install mockjs --save
</code></pre>

<pre><code class="language-text">yarn add mockjs
</code></pre>

<h3 id="toc_4">2.创建mock文件，并添加到打包配置文件中</h3>

<p>又是<code>angualr.json</code>，在scripts中添加自己的mock文件路径，让webpack打包angular时同时打包我们的mock文件。<br/>
<img src="media/16073237309370/16073291483432.jpg" alt="" style="width:541px;"/></p>

<h3 id="toc_5">3.编写mock服务</h3>

<ul>
<li><p>首先导入mockjs。</p>
<pre><code class="language-typescript">import * as Mock from &#39;mockjs&#39;;
</code></pre></li>
<li><p>然后拦截请求，返回假数据</p>
<pre><code class="language-typescript">Mock.mock(&#39;http://localhost:9080/list&#39;, {
message: &#39;调用成功&#39;,<br/>
&#39;data|10&#39;: [{<br/>
&#39;id|+1&#39;: 1,<br/>
title: &#39;This is a title&#39;,<br/>
tags: [<br/>
  {<br/>
    id: 1,<br/>
    name: &#39;aaaa&#39;,<br/>
    color: &#39;red&#39;<br/>
  }<br/>
],<br/>
&#39;note|100&#39;: &#39;There are notes!&#39;<br/>
}]<br/>
});
</code></pre></li>
</ul>

<h2 id="toc_6">最后鼓励下自己</h2>

<p>angular中如何加载mock服务就到这，mock中的精髓是通过代码来生成数据，一行代码就可以生成千万条带有逻辑的数据，这些还需要细读一下API。这次记录是通过编译打包时的顺序来记录mock的使用方法，今后需要更深入的理解angular要多多从这个方向调查问题。</p>

]]></content>
  </entry>
  
</feed>
