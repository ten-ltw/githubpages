<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[十]]></title>
  <link href="blog.2019919.top/atom.xml" rel="self"/>
  <link href="blog.2019919.top/"/>
  <updated>2020-12-15T23:34:41+08:00</updated>
  <id>blog.2019919.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[javascript原型和原型链]]></title>
    <link href="blog.2019919.top/16080322533005.html"/>
    <updated>2020-12-15T19:37:33+08:00</updated>
    <id>blog.2019919.top/16080322533005.html</id>
    <content type="html"><![CDATA[
<p>今天刚开始学习【重学前端】的课程，讲到装箱转换的时候提到了函数的<code>call</code>方法，而<code>call</code>方法在我的印象中就只有<code>call</code>约等于<code>apply</code>，然后就再没有然后了。在我想深入了解下<code>call</code>方法的时候又发现了有人在同时讲解原型，而于此同时我看到了知乎上的一个贴<a href="https://www.zhihu.com/question/60165921">面试一个5年的前端，却连原型链也搞不清楚，满口都是Vue，React之类的实现，这样的人该用吗？</a>，这我不看内容我就惊呆了，这标题不就是在说我吗。带着各种心情赶紧学习下到底什么是原型和原型链。</p>

<h2 id="toc_0">原型</h2>

<pre><code class="language-text">prototype  [ˈproʊtətaɪp]  原型
</code></pre>

<p>OK完了😊！</p>

<p>下面这个图很多大神都有画过，下面记录下我自己的理解和实验。</p>

<p><img src="media/16080322533005/16080400429560.jpg" alt="" style="width:450px;"/></p>

<h3 id="toc_1">构造函数视角</h3>

<p>函数可以用来做构造器，也就是constructor，而构造器也可以称为类。<br/>
通过构造器<code>Apple</code>来创建一个对象对象<code>apple</code>。</p>

<p><img src="media/16080322533005/16080397593797.jpg" alt="" style="width:198px;"/></p>

<p><strong>构造函数创建了实例对象</strong>，这是构造函数与实例对象的关系。</p>

<hr/>

<p><strong>构造函数有一个属性叫做propotype,他指向了原型对象。</strong></p>

<p><img src="media/16080322533005/16080405364424.jpg" alt="" style="width:299px;"/></p>

<p>这里的原型对象有些大神也写做<code>[[propotype]]</code>，这里我猜测是为了区分propotype的属性。</p>

<h3 id="toc_2">原型对象视角</h3>

<p><strong>原型对象的constructor属性指向了构造函数</strong>。</p>

<p><img src="media/16080322533005/16080407735350.jpg" alt="" style="width:382px;"/></p>

<p>这里用构造器的原型对象的constructor方法来创建一个<code>badApple</code>，会发现它和<code>apple</code>的类型是相等的。</p>

<h3 id="toc_3">实例对象视角</h3>

<p>对象也有一个属性__propo__，这是一个隐式属性，<strong>对象的__propo__指向了他的构造函数的原型对象。</strong><br/>
也就是说<code>Apple</code>的propotype属性和<code>apple</code>、<code>badApple</code>的__propo__指向了同一个地址。</p>

<p><img src="media/16080322533005/16080419126552.jpg" alt="" style="width:318px;"/></p>

<h3 id="toc_4">由函数引出原型链</h3>

<p>函数是JS中的第一类对象，在Javascript中，对象所拥有的函数也同样拥有，也就是说构造函数<code>Apple</code>也同样会有__propo__属性去指向他的父类的原型对象，为了理清这乱七八糟的关系，就有了下面【对象-函数-构造函数-实例对象】这样的一个关系图，也就是原型链图。</p>

<h2 id="toc_5">原型链</h2>

<p><img src="media/16080322533005/16080423510561.jpg" alt=""/></p>

<p>这张图理解了上面的内容之后就感觉容易多了，总结一下有以下几点需要注意。</p>

<ul>
<li>任何函数的父类都是Function函数，也就是任何函数的__proto__指向Function的原型对象,这里同样包含了Function函数自己。</li>
<li>Object函数的__proto__指向Function的原型对象</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新认识下熟悉的浏览器]]></title>
    <link href="blog.2019919.top/16076922632055.html"/>
    <updated>2020-12-11T21:11:03+08:00</updated>
    <id>blog.2019919.top/16076922632055.html</id>
    <content type="html"><![CDATA[
<p>前端程序员每天都在抠代码，各种各样的技术，千变万化的框架，但最后组装压缩在一起，就是为了伺候操作系统的一个软件————浏览器。这一次，在阅读了三天各大博主的精华后，就chrome浏览器来做一下自己的整理记录。<br/>
双击桌面chrome浏览器发生了什么呢：</p>

<blockquote>
<p>系统创建了一个chrome的进程。</p>

<blockquote>
<p>从多标签页app的开始，一个chrome进程中有了多个子tab进程。</p>

<blockquote>
<p>每个tab进程内有下面这些进程：<br/>
<a href="#toc_0">渲染引擎</a><br/>
<a href="#toc_1">JS引擎</a><br/>
<a href="#toc_2">用户界面</a><br/>
<a href="#toc_3">存储</a></p>
</blockquote>
</blockquote>
</blockquote>

<h2 id="toc_0">渲染引擎</h2>

<p>最初渲染引擎和JS引擎并没有分家，在一起统称为浏览器内核，后来JS引擎越来越独立，内核就完全倾向于渲染引擎。chrome原来使用的就是webkit引擎，后来为了不受制于苹果，基于webkit改编了blink，将其内置于chrome中。</p>

<h2 id="toc_1">JS引擎</h2>

<h2 id="toc_2">用户界面</h2>

<h2 id="toc_3">存储</h2>

<h2 id="toc_4">感受</h2>

<p>现在对学习的感觉是即入迷又无力，学到这里的时候回想一下，我最开始只是看到了一篇短文，浅谈JS事件的原理，而当时的那篇文章真的是比较浅，我现在已经忘了内容是什么了，但是在我不断深入的时候，每每看到一个强大的人的博客的时候就会发现一些新内容，当我为了弄懂其中一个小名词的时候又会引出无数的子节点，真的是树无处不在，越来越入迷，也越来越吃力。虽然我不知道整个树有多大，但是当学到末梢节点的时候回头来总结一下，看看我捋顺的健壮的树枝，真的是振奋人心。</p>

<h2 id="toc_5">参考</h2>

<p><a href="https://segmentfault.com/a/1190000018806562">webkit引擎和v8引擎工作原理</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[angular mock的使用]]></title>
    <link href="blog.2019919.top/16073237309370.html"/>
    <updated>2020-12-07T14:48:50+08:00</updated>
    <id>blog.2019919.top/16073237309370.html</id>
    <content type="html"><![CDATA[
<p>在现在公司中，并没有真的前后端分离，往往是前后端一同疏通测试，美其名曰节省时间全面发展。因此至今没有单独写过mock进行前端自己的单体测试。这一次调查下mock的使用。</p>

<h2 id="toc_0">Angular的environments文件</h2>

<p><img src="media/16073237309370/16073245939102.jpg" alt="" style="width:746px;"/></p>

<p>environments文件分别是每个环境对应的配置。<br/>
每个文件与环境的对应关系存放于<code>angular.json</code>中。</p>

<p><img src="media/16073237309370/16073266078090.jpg" alt="" style="width:555px;"/></p>

<p>这个设定指定了cli在进行<code>production build</code>的时候将<code>environment.ts</code>替换成<code>environment.prod.ts</code>，即将开发环境的环境配置替换成生产环境的开发配置。<br/>
在这里设置isMock属性，让mock在生产环境中自动启动，开发环境~~~~中自动关闭。</p>

<h2 id="toc_1">Angular的main.ts文件</h2>

<p><img src="media/16073237309370/16073284745167.jpg" alt="" style="width:555px;"/></p>

<p>同样在cli中webpack的入口程序被设置为<code>src/main.ts</code>，也就是说<code>main.ts</code>是我们整个angualr的入口程序。我们在这里判断当前环境是否引入mock服务。</p>

<p><img src="media/16073237309370/16073286403589.jpg" alt="" style="width:566px;"/></p>

<h2 id="toc_2">mock服务的实现</h2>

<h3 id="toc_3">1.选择自己的包管理器添加mock的指令安装mock</h3>

<pre><code class="language-text">npm install mockjs --save
</code></pre>

<pre><code class="language-text">yarn add mockjs
</code></pre>

<h3 id="toc_4">2.创建mock文件，并添加到打包配置文件中</h3>

<p>又是<code>angualr.json</code>，在scripts中添加自己的mock文件路径，让webpack打包angular时同时打包我们的mock文件。<br/>
<img src="media/16073237309370/16073291483432.jpg" alt="" style="width:541px;"/></p>

<h3 id="toc_5">3.编写mock服务</h3>

<ul>
<li><p>首先导入mockjs。</p>
<pre><code class="language-typescript">import * as Mock from &#39;mockjs&#39;;
</code></pre></li>
<li><p>然后拦截请求，返回假数据</p>
<pre><code class="language-typescript">Mock.mock(&#39;http://localhost:9080/list&#39;, {
message: &#39;调用成功&#39;,<br/>
&#39;data|10&#39;: [{<br/>
&#39;id|+1&#39;: 1,<br/>
title: &#39;This is a title&#39;,<br/>
tags: [<br/>
  {<br/>
    id: 1,<br/>
    name: &#39;aaaa&#39;,<br/>
    color: &#39;red&#39;<br/>
  }<br/>
],<br/>
&#39;note|100&#39;: &#39;There are notes!&#39;<br/>
}]<br/>
});
</code></pre></li>
</ul>

<h2 id="toc_6">最后鼓励下自己</h2>

<p>angular中如何加载mock服务就到这，mock中的精髓是通过代码来生成数据，一行代码就可以生成千万条带有逻辑的数据，这些还需要细读一下API。这次记录是通过编译打包时的顺序来记录mock的使用方法，今后需要更深入的理解angular要多多从这个方向调查问题。</p>

]]></content>
  </entry>
  
</feed>
