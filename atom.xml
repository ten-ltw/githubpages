<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[十]]></title>
  <link href="blog.2019919.top/atom.xml" rel="self"/>
  <link href="blog.2019919.top/"/>
  <updated>2021-02-06T09:26:58+08:00</updated>
  <id>blog.2019919.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript 深浅拷贝]]></title>
    <link href="blog.2019919.top/16124460113427.html"/>
    <updated>2021-02-04T21:40:11+08:00</updated>
    <id>blog.2019919.top/16124460113427.html</id>
    <content type="html"><![CDATA[
<p>在数组章节提到数组的展开运算符时，作者举例说明展开运算符可以进行拷贝，原为如下：</p>

<blockquote>
<p>The spread operator is a convenient way to create a (shallow) copy of an array:</p>
</blockquote>

<pre><code class="language-javascript">let original = [1,2,3];
let copy = [...original];
copy[0] = 0;  // Modifying the copy does not change the original
original[0]   // =&gt; 1
</code></pre>

<p>copy 对象为 original 展开后的数组字面量，但是拷贝后的数组修改了序列为 0 的元素的值，但是被拷贝数组中序列为 0 的元素的值并没有被改变，作者称这样的拷贝为浅拷贝，</p>

<p>在我的印象中深浅拷贝是如下形式的：</p>

<ul>
<li>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，在修改了拷贝元，拷贝先也会跟着改变。</li>
<li>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，拷贝元和拷贝之间脱离了关系。</li>
</ul>

<p>但是这个实例中，作者只测试了拷贝先的修改，我又做了如下测试：</p>

<pre><code class="language-javascript">let original = [1,2,3];
let copy = [...original];
original[0] = 10;
copy[0]  // =&gt; 1
</code></pre>

<p>就是说在修改被拷贝数组时，拷贝后的数组也不跟随改变。<br/>
所以作者的浅拷贝指的是什么呢？<br/>
问题需要最根溯源，从基础来解决问题，下面就先来回溯下数据类型。</p>

<h2 id="toc_0">JavaScript 数据类型</h2>

<p>最新 ECMAScript 标准定义了九种类型：</p>

<ul>
<li>六个数据类型</li>
</ul>

<pre><code class="language-javascript">typeof undefined === &#39;undefined&#39;;
typeof true === &#39;boolean&#39;;
typeof 123 === &#39;number&#39;;
typeof &#39;str&#39; === &#39;string&#39;;
typeof 123n ===&#39;bigint&#39;;
typeof Symbol(&#39;symbol&#39;) === &#39;symbol&#39;;
</code></pre>

<ul>
<li>两个结构类型</li>
</ul>

<pre><code class="language-javascript">typeof {} === &#39;object&#39;;
typeof (() =&gt; {}) === &#39;function&#39;;
</code></pre>

<ul>
<li>结构根</li>
</ul>

<pre><code class="language-javascript">typeof null === &#39;object&#39;;
</code></pre>

<p>以上九种类型又分为原始值（Primitive Value）和对象（Object）：</p>

<ul>
<li>Primitive values
<ul>
<li>Boolean type</li>
<li>Null type</li>
<li>Undefined type</li>
<li>Number type</li>
<li>BigInt type</li>
<li>String type</li>
<li>Symbol type</li>
</ul></li>
<li>Objects</li>
</ul>

<p>原始值（又名基本类型）其值存放在栈中，它的值无法被修改，当对基本类型进行操作时，会在新的空间内创建一个原始值。</p>

<p>对象也就是引用类型（又名复杂类型），它只在栈中保存其内存地址，指向存在堆中的数据，当对其进行修改时，栈内的地址进行改变，指向堆中另外的数据。</p>

<h2 id="toc_1">问题解决</h2>

<p>现在再回想一下深浅拷贝的定义就会发现，其只是针对复杂类型。也就是说在原文中所用示例在用展开运算符对 original 数组进行拷贝，而其拷贝的值是初始数组内的元素，而其元素只是 number 类型的原始值，因此这个实例无法展示其浅拷贝特性。</p>

<p>了解了这些后，针对引用类型做一个实验：</p>

<pre><code class="language-javascript">let original = [{a:1},2,3];
let copy = [...original];
original[0].a = 10;
copy[0].a; // =&gt; 10
</code></pre>

<p>这个例子中初始数组中的第一个元素为对象，是一个引用类型数据，拷贝后对其中的 a 属性进行修改，果然拷贝后的数组中第一个元素的 a 属性值也被修改。如此证明了展开运算符的确是浅拷贝。</p>

<h2 id="toc_2"> 总结</h2>

<p>这次的错误理解的根源是对基本概念掌握的不够牢固，这里展开运算符只是将初始数组中的元素展开到一个新的数组字面量中，因此并不是拷贝整个数组，而是拷贝数组中的每个元素，所以深浅拷贝的描述对象也是数组中的元素。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数中的展开运算符和解构]]></title>
    <link href="blog.2019919.top/16108495213063.html"/>
    <updated>2021-01-17T10:12:01+08:00</updated>
    <id>blog.2019919.top/16108495213063.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过函数声明和调用掌握函数的 this 值]]></title>
    <link href="blog.2019919.top/16107633205948.html"/>
    <updated>2021-01-16T10:15:20+08:00</updated>
    <id>blog.2019919.top/16107633205948.html</id>
    <content type="html"><![CDATA[
<p>函数的 this 对于基础薄弱的前端程序员一直是一个比较头疼的问题，在对 ES6 的模糊和对 ES6 之前的函数作用域不理解双重打击下，往往无法区分 this 值到底是什么，因而在编写程序时常常需要通过测试当前作用域的 this 是什么，再去使用，甚至是某些公司严格规定哪种方式去实现。</p>

<p>细细的看完了权威指南的第七版受益颇多，但是作者并没有拿出一个章节专门将相关内容进行汇总，这里就通过函数的声明和调用来总结下函数 this 值的几种情况。</p>

<h2 id="toc_0"> 函数定义</h2>

<p>函数的定义有多种方式来适应不同的使用场景：</p>

<ul>
<li>函数声明语句</li>
<li>函数表达式</li>
<li>箭头函数</li>
<li>嵌套函数</li>
<li>应用函数的构造函数 Function()</li>
</ul>

<h3 id="toc_1"> 函数声明语句</h3>

<p>与大多数声明语句一样，以关键字 + 名称的形式来进行声明，函数用关键字 function 来声明：</p>

<pre><code class="language-javascript">function testOutPut(){
    console.log(&#39;Hello world!&#39;);        
}
</code></pre>

<p>函数声明语句是函数名变成一个变量，这个变量的值是函数本身。这里实际上是声明了一个 testOutPut 变量，并讲函数对象赋值给 testOutPut。在 JavaScript 的运行时中，函数对象创建于该函数所在作用域的代码开始执行之前，也就是说，在同一个上下文中，可以先执行函数调用再进行函数语句声明。只是第一个函数作为值的概念的应用场景。</p>

<h3 id="toc_2"> 函数表达式</h3>

<p>函数表达式是一个赋值语句，将一个函数赋值给一个变量或常量。感觉函数表达式跟函数声明语句的运行时一样，但是如果先进行函数调用再进行函数表达式来定义函数将会异常。因为函数表达式在没有执行前并没有将函数赋值给变量，所以它也就不能被引用。</p>

<pre><code class="language-javascript">beforeDefined();
let beforeDefined = function(){console.log(1);}
// Uncaught ReferenceError: beforeDefined is not defined
</code></pre>

<p>函数表达式的函数名称是可选项，如果给函数表达式添加一个函数名，那这个函数的<em>局部函数作用域内</em>会包含该属性的函数名的对象，其值绑定的是该函数：</p>

<pre><code class="language-javascript">const f = function fact(x) {
    if (x &lt;= 1) return 1;
    else return x*fact(x-1);
};
</code></pre>

<p>只有在函数局部作用域内会有这个对象，有点闭包的感觉。</p>

<h3 id="toc_3"> 箭头函数</h3>

<p>箭头函数是 ES6 的新特性，在实际生产中非常常用。它支持很多简洁语法：</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; { return x + y; };
const sum = (x, y) =&gt; x + y;
const polynomial = x =&gt; x*x + 2*x + 3;
const constantFunc = () =&gt; 42;
</code></pre>

<p>注意参数和箭头之间不能换行，否则会引起歧义。<br/>
除此之外，它最大的特性就是它继承定义它环境的 this 值，我理解添加箭头函数的目的就是为了解决方法的嵌套函数 this 值为全局对象（严格模式下是 undefined）的缺陷：</p>

<pre><code class="language-javascript">let o = {
    a:1,
    m:function(){
        let self = this;
        console.log(this === o);
        f();
        function f(){
            console.log(this === o);
            console.log(self === o);
            console.log(this);
        }
    }
}
o.m();
// true
// flase
// true
// Window{...}
</code></pre>

<p>在 ES6 之前，我们需要通过闭包将 this 值保存在变量中使用，而有了箭头函数，可以直接继承 m 方法的 this 值：</p>

<pre><code class="language-javascript">o = {
    a:1,
    m:function(){
        let self = this;
        console.log(this === o);
        const f = () =&gt; {
            console.log(this === o);
            console.log(self === o);
            console.log(this);
        }
        f();
    }
}
o.m();
// true
// true
// true
// {a: 1, m: ƒ}
</code></pre>

<h3 id="toc_4"> 嵌套函数</h3>

<p>函数可以嵌套在其他函数内。嵌套函数可以访问包含它们函数的变量和参数（闭包）：</p>

<pre><code class="language-javascript">function first(){
    let strFirst = &quot;first&quot;;
    second();
    function second(){
        let strSecond = &quot;second&quot;;
        third();
        function third(){
            console.log(strFirst);
            console.log(strSecond);
        }
    }
}
first();
// first
// second
</code></pre>

<h3 id="toc_5"> Function() 构造函数创建函数</h3>

<p>Function() 函数的实参都是字符串，最后一个实参是函数体。</p>

<pre><code class="language-javascript">const f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);
</code></pre>

<p>这里想到一个情况，当函数名相同时是否会报错：</p>

<pre><code class="language-javascript">const f1 = new Function(&quot;x&quot;, &quot;x&quot;, &quot;return x;&quot;);
f1(1,2);
// 2
</code></pre>

<p>实际情况并没有，再次测试一下直接函数声明语句使用两个相同的参数，也没有报错：</p>

<pre><code class="language-javascript">function f2(x,x,y){return x*y};
f2(1,2,2);
// 4
</code></pre>

<p>这样看实际上跟函数外部用 var 声明的变量在函数中再次声明一个效果：</p>

<pre><code class="language-javascript">var x = 1;
function test(){let x = 2;console.log(x)};
console.log(x);
test();
// 1
// 2
</code></pre>

<p>函数变量声明多个相相同的变量名时，传递的实参值将反复覆盖同名参数。<br/>
Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，看书上的一个例子：</p>

<pre><code class="language-javascript">let scope = &quot;global&quot;;
function constructFunction() {
    let scope = &quot;local&quot;;
    return new Function(&quot;return scope&quot;);  // Doesn&#39;t capture local scope!
}
constructFunction()(); 
// &quot;global&quot;
</code></pre>

<h2 id="toc_6"> 函数调用</h2>

<p>函数调用和方法调用很常见就不再赘述，这里有三种很少使用的调用方式：</p>

<ul>
<li>构造函数调用</li>
<li>间接调用</li>
<li>隐式调用</li>
</ul>

<h3 id="toc_7"> 构造函数调用</h3>

<pre><code class="language-javascript">function CreatObj(){
    this[&#39;p&#39;] = &quot;property&quot;;    
}
o = new CreatObj();
// CreatObj {p: &quot;property&quot;}
</code></pre>

<p>构造函数创建一个新对象，并将这个对象作为它的上下文，也就是说构造函数中的 this 值是新创建的对象。<br/>
构造函数通常没有 return 语句，当显示的用 return 语句返回一个对象时，构造函数创建的对象将变成它 return 的对象，其他情况当没有返回值或返回一个原始值时，返回值都被忽略，返回它新创建的对象。</p>

<h3 id="toc_8">间接调用</h3>

<p>JavaScript 万物接对象，对象就有自己的属性和方法。同理，函数也是对象，也有自己的方法和属性，而 call() 和 apply() 方法也可以用来间接调用函数。</p>

<h4 id="toc_9">call() 方法</h4>

<p>MDN 中对于 call() 的解释已经很明了了：</p>

<blockquote>
<p>The call() method calls a function with a given this value and arguments provided individually.</p>
</blockquote>

<pre><code class="language-javascript">f.call(o, 1, 2);
</code></pre>

<p>这里不过是将 o 对象作为函数 f 调用的上下文，并传入两个实参 1 和 2 作为实参列表，也就是说它等同与下面的代码：</p>

<pre><code class="language-javascript">o.m = f;
o.m(1, 2);
delete o.m;
</code></pre>

<p>这里注意 delete 语句，目的就是说函数在使用 call 方法时只是临时将 o 作为 f 的上下文并调用。而函数还有个不涉及调用的方法 bind() 它可以返回一个新的函数对象，<code>f.bind(o);</code>，而这个对象将一直绑定 o 为函数 f 的 this 值。</p>

<h4 id="toc_10">apply() 方法</h4>

<blockquote>
<p>The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).</p>
</blockquote>

<p>不难看出 apply() 和 call() 基本一致，只是实参以数组或者类似数组的对象进行传递。这里对类似数组的对象进行测试：</p>

<pre><code class="language-javascript">function test(...args){
    console.log(this);
    for(item in args) console.log(item);
}
let o = {a:1};
let likeArr = {p1:1,p2:2};
likeArr.length = 2;    
let unLikeArr = {p1:1,p2:2};
test.apply(o,likeArr);
// {a: 1}
// 0
// 1
test.apply(o,unLikeArr);
// {a: 1}
</code></pre>

<p>可见有了 length 的对象就被当作是类似数组的对象。</p>

<h4 id="toc_11">this 值</h4>

<p>可见当 call() 和 apply() 调用函数时给函数绑定了一个上下文 this 值，但是箭头函数是个特例，它从它定义的位置的上下文继承 this 值。也就是说当给箭头函数定义的函数使用这两个方法时，第一个参数将被忽略：</p>

<pre><code class="language-javascript">let o = {
    a: 1,
    f: function(){
        const oBind = {b:1};
        const test = ()=&gt; console.log(this);
        test.apply(oBind);
    }
}
o.f();
// {a: 1, f: ƒ}
</code></pre>

<h3 id="toc_12">隐式调用</h3>

<ul>
<li>getter 和 setter 方法在获取或者设置它的属性时可能被隐式调用。</li>
<li>在对象进行字符串或者数值型和 BigInt 类型转换时，会隐式调用 toString() 和 valueOf() 方法。</li>
<li>循环可迭代对象的元素时会产生很多方法调用。</li>
<li>模板字符串可以调用函数。</li>
<li>Proxy 对象的任何一个操作都会导致函数调用。</li>
</ul>

<h2 id="toc_13"> 关于函数 this 值的总结</h2>

<p>函数 this 值有以下几种情况：</p>

<ul>
<li>函数声明语句和函数表达式定义的函数，在非严格模式下 this 值永远是 global，严格模式下是 undefined。</li>
<li>apply() call() bind() 方法用在非箭头函数时，第一个参数作为函数运行时的 this 值。</li>
<li>箭头函数的 this 值永远继承于它所定义的位置的 this 值。</li>
<li>对象的方法中 this 值是该对象的引用，嵌套在该对象中的函数不为方法，所以遵循函数的 this 值（global 或者 undefined）。</li>
<li>构造函数的 this 值是新创建的对象。</li>
</ul>

<p>闭包只是参数和变量作用域的引用，与 this 值无关。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过变量作用域深入了解 undefined]]></title>
    <link href="blog.2019919.top/16088182648987.html"/>
    <updated>2020-12-24T21:57:44+08:00</updated>
    <id>blog.2019919.top/16088182648987.html</id>
    <content type="html"><![CDATA[
<p>undefined 是一个变量，它有可能被篡改，所以使用void（0）来代替他，但是在做实验的时候发现虽然给它赋值不报错，取值时候 undefined 却并没有改变。</p>

<pre><code class="language-javascript">    undefined = 0
    // 0
    undefined
    // undefined
</code></pre>

<p>这回学习到了变量作用域，再结合之前学的对象的属性，深入了解下 undefined 到底什么时候会被篡改。</p>

<h2 id="toc_0">函数作用域和声明提前</h2>

<p>别的语言一般为块级作用域，JavaScript 取而代之使用了函数作用域：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p>

<pre><code class="language-javascript">    var a = function test(o){
        var i = 0;                          // i在整个函数体内均是有定义的
        if(typeof o == &quot;object&quot;){
            var j = 4;                      // j在函数体内是有定义的，不仅仅是在这个代码段内
            for(var k=0; k &lt; 3; k++){       // k在函数体内是有定义的，不仅仅是在循环内
                console.log(k);             // 输出数字0～2
            }
            console.log(k);                 // k已经定义了，输出3
        }
        console.log(k);                     // k已经定义了，输出3
        console.log(j);                     // j已经定义了，输出4
    };
</code></pre>

<p>JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部。</p>

<pre><code class="language-javascript">    var a = &#39;1&#39;;
    function f(){
        console.log(a);
        var a = &#39;2&#39;;
        console.log(a);
    }
</code></pre>

<p>由于函数作用域的特性，变量 a 的声明被提前到了整个函数体最前面，声明了但是没赋值，所以第一次 console 是 undefined。执行到 var 语句时才被赋值，这应该也是为什么可以一个变量多次 var 声明的原因，后面每一次 var 只是起到了赋值的作用。</p>

<h2 id="toc_1">ES6 块作用域</h2>

<p>ES6 弥补了这这个概念，追加了 let 和 const，也就有了 {} 块作用域的概念，const 用来声明常量，这个就不提了，用上面的例子感受一下 let 和 var 的区别。</p>

<pre><code class="language-javascript">    var a = function test(o){
        var i = 0;                          // i在整个函数体内均是有定义的
        if(typeof o == &quot;object&quot;){
            let j = 4;                      // j在if块内是有定义的
            for(var k=0; k &lt; 3; k++){       // k在函数体内是有定义的，不仅仅是在循环内
                console.log(k);             // 输出数字0～2
                console.log(j);             // j已经定义了，输出4
            }
            console.log(k);                 // k已经定义了，输出3
        }
        console.log(k);                     // k已经定义了，输出3
        console.log(j);                     // j在块外，抛出异常Uncaught ReferenceError: j is not defined
    };
</code></pre>

<p>let 和 const 只有在块内是被声明的。</p>

<h2 id="toc_2">全局变量的本质</h2>

<p>当声明一个 JavaScript 全局变量时，实际上是定义了全局对象的一个属性。当使用 var 声明一个变量时，创建的这个属性是不可配置的，无法通过 delete 运算符删除。</p>

<pre><code class="language-javascript">    test =1
    // 1
    window.test
    // 1
    delete test
    // true
    window.test
    // undefined
    var test = 1
    // undefined
    window.test
    // 1
    delete test
    // false
    window.test
    // 1
</code></pre>

<p>可以看到当定义一个全局变量的时候他变成了 window 的属性。<br/>
JavaScript 可以允许使用 this 关键字来引用全局对象，但是不能引用局部变量中存放的对象。</p>

<pre><code class="language-javascript">    this.test
    // 1
</code></pre>

<h2 id="toc_3">深入理解 undefined 的本质</h2>

<p>undefined 明明是个变量为什么赋值后无法使用呢。任何地方都可以直接使用 undefined，那他是一个全局变量一个全局的属性，事实也果然如此。</p>

<pre><code class="language-javascript">    window.undefined == undefined
    // true
</code></pre>

<p>而属性分两类，他们的特征如下：</p>

<ul>
<li>数据属性
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性是否能被赋值。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul></li>
<li>访问器属性（getter/setter）
<ul>
<li>getter：函数或 undefined，在取属性值时被调用。</li>
<li>setter：函数或 undefined，在设置属性值时被调用。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。<br/>
查看下全局属性 undefined 的属性特征。</li>
</ul></li>
</ul>

<pre><code class="language-javascript">    console.log(Object.getOwnPropertyDescriptor(window,&#39;undefined&#39;));
    // configurable: false
    // enumerable: false
    // value: undefined
    // writable: false
</code></pre>

<p>writable：false，就是这个原因 undefined 虽然是个全局变量，但是我们赋值之后他并没有被改变。那为什么还需要用 void(0) 来代替 undefined 呢？结合上面的函数作用域再做一个实验。</p>

<pre><code class="language-javascript">    function test() {
        var undefined = 100; 
        console.log(undefined);
        var obj = {a : undefined}; 
        console.log(Object.getOwnPropertyDescriptor(obj,&#39;a&#39;));
    }
    test();
    // 100
    // configurable: true
    // enumerable: true
    // value: 100
    // writable: true
</code></pre>

<p>在函数作用域中，undefined 被从声明并赋值为 100，无论是直接 console 它自己还是去查看 undefined 属性特性都能看出，undefined 变量被修改了。这也就说在函数作用域内 undefined 可以被修改。</p>

<pre><code class="language-javascript">    function test() {
        const undefined = 100; 
        console.log(undefined);
        const obj = {a : undefined}; 
        console.log(Object.getOwnPropertyDescriptor(obj,&#39;a&#39;));
        test();
    }
    // 100
    // configurable: true
    // enumerable: true
    // value: 100
    // writable: true
</code></pre>

<p>块作用域内也一样可以被修改，得出结论 undefined 是一个类似 var 声明一样可以被重复声明的全局属性，而他的属性特性 writable 是 false，所以不能被修改，但是在非全局作用域内，他是可以被篡改的，这时候就要注意用 void (0) 来替代 undefined。</p>

<h2 id="toc_4">作用域链<sup>1</sup></h2>

<p>以书中的角度用对象属性去看作用域链：</p>

<ul>
<li>JavaScript最顶层的代码，其作用域链只有一个全局对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Global object</td>
    <tr>
</table>

<ul>
<li>不包含嵌套的函数，其作用域两个对象：函数自身的变量对象和全局对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Activation object</td>
    <tr>
    <tr>
        <td>1</td><td>Global object</td>
    <tr>
</table>

<blockquote>
<p>活动对象(activation object)，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端</p>
</blockquote>

<ul>
<li>对于包含了嵌套函数的函数，其作用域包含至少三个对象：自身的变量对象，外层的变量对象（将自身嵌套的函数），全局变量对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Sub activation object</td>
    <tr>
    <tr>
        <td>1</td><td>Activation object</td>
    <tr>
    <tr>
        <td>2</td><td>Global object</td>
    <tr>
</table>

<p>作用域链给我的感觉类似原型链，将函数的上下文构成了链表的形式，而方法执行时一层一层往外找，所以为了方便链表从上到下查找属性，所以有了声明提前，链表最顶端为嵌套函数的最里层，链表最底端则是全局变量对象。</p>

<pre><code class="language-javascript">    function test(){
        var fun1,fun2;
        for(var i=0;i&lt;2;i++){
            if(i === 0){
                fun1 = function(){console.log(&#39;fun1:i=&#39;+i)};
            }
            if(i === 1){
                fun2 = function(){console.log(&#39;fun2:i=&#39;+i)};
            }
        };
        fun1();
        fun2();
    }∫
    test();
    // fun1:i=2
    // fun2:i=2
</code></pre>

<h2 id="toc_5">注</h2>

<ol>
<li>在看 JavaScript 权威指南第七版第八章时发现作者将原来的作用域链的“链”字都删除了，变成了作用域，但是还没有看前面作用域相关内容，应该有新的理解，在完成翻译后再继续补全。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 6 章 对象]]></title>
    <link href="blog.2019919.top/16113218396407.html"/>
    <updated>2021-01-22T21:23:59+08:00</updated>
    <id>blog.2019919.top/16113218396407.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">6.1 介绍对象</a>
</li>
<li>
<a href="#toc_1">6.2 创建对象</a>
<ul>
<li>
<a href="#toc_2">6.2.1 对象字面量</a>
</li>
<li>
<a href="#toc_3">6.2.2 用 new 创建对象</a>
</li>
<li>
<a href="#toc_4">6.2.3 原型</a>
</li>
<li>
<a href="#toc_5">6.2.4 Object.create()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">6.3 查询和设置属性</a>
<ul>
<li>
<a href="#toc_7">6.3.1 对象作关联数组</a>
</li>
<li>
<a href="#toc_8">6.3.2 继承</a>
</li>
<li>
<a href="#toc_9">6.3.3 属性访问异常</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">6.4 删除属性</a>
</li>
<li>
<a href="#toc_11">6.5 测试属性</a>
</li>
<li>
<a href="#toc_12">6.6 枚举属性</a>
<ul>
<li>
<a href="#toc_13">6.6.1 属性枚举顺序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">6.7 扩展对象</a>
</li>
<li>
<a href="#toc_15">6.8 序列化对象</a>
</li>
<li>
<a href="#toc_16">6.9 对象方法</a>
<ul>
<li>
<a href="#toc_17">6.9.1 toString() 方法</a>
</li>
<li>
<a href="#toc_18">6.9.2 toLocaleString() 方法</a>
</li>
<li>
<a href="#toc_19">6.9.3 valueOf() 方法</a>
</li>
<li>
<a href="#toc_20">6.9.4 toJSON() 方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">6.10 扩展的对象字面量语法</a>
<ul>
<li>
<a href="#toc_22">6.10.1 速记属性</a>
</li>
<li>
<a href="#toc_23">6.10.2 计算属性名</a>
</li>
<li>
<a href="#toc_24">6.10.3 Symbol 作属性名</a>
</li>
<li>
<a href="#toc_25">6.10.4 展开运算符</a>
</li>
<li>
<a href="#toc_26">6.10.5 速记方法</a>
</li>
<li>
<a href="#toc_27">6.10.6 属性 Getter 和 Setter 方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_28">6.11 总结</a>
</li>
</ul>


<p>对象是 JavaScript 最基本的数据类型，在本章之前的章节中已经多次看到它们。因为对象对 JavaScript 语言非常重要，所以了解它们的工作原理非常重要，本章将提供这些细节。它从对象的正式概述开始，然后深入到关于创建对象以及查询、设置、删除、测试和枚举对象属性的实用部分。在这些以属性为中心的章节之后，将介绍如何扩展、序列化和定义对象上的重要方法。最后，本章以一大段关于 ES6 中的新对象文字语法和该语言的最新版本结尾。</p>

<h2 id="toc_0">6.1 介绍对象</h2>

<p>对象是一个复合值：它聚合了多个值（原始值或其他对象），并允许按名称存储和获取这些值。对象是属性的无序集合，每个属性都有一个名称和一个值。属性名通常是字符串（尽管，正如我们将在 §6.10.3 中看到的，属性名也可以是 Symbol），所以我们可以说对象将字符串映射到值。这种字符串到值的映射有不同的名称——可能已经熟悉这种基本数据结构的别的名称“散列”（hash）、“散列表”（hashtable）、“字典”（dictionary）或“关联数组”（associative array）。然而，对象不仅仅是简单的字符串到值的映射。除了维护自己的属性集，JavaScript 对象还继承另一个对象的属性，即它的“原型”。对象的方法通常是继承的属性，而这种“原型继承”是 JavaScript 的一个关键特性。</p>

<p>JavaScript 对象是动态的——属性通常可以添加和删除——但它们可以用来模拟静态类型语言的静态对象和“结构体”（struct）。有时它们也用做字符串的集 合（忽略名/值对中的值）。</p>

<p>JavaScript 中任何不是字符串、数字、Symbol 或 true、false、null 或 undefined 的值都是对象。即使字符串、数字和布尔值不是对象，它们的行为和不可变对象非常类似。</p>

<p>回想一下 §3.8，对象是可变的，通过引用而不是值来操作。如果变量 x 指向一个对象的引用，执行 <code>y = x;</code> 时，变量 y 也是指向同一对象的引用，而不是该对象的副本。通过变量 y 修改这个对象也会对变量 x 造成影响。</p>

<p>对对象最常见的操作是创建它们并设置、查询、删除、测试和枚举它们的属性。这些基本的操作将在本章的开头部分进行描述。之后的部分将介绍更高级的主题。</p>

<p>属性有一个名称和一个值。属性名可以是任何字符串，包括空字符串（或任何 Symbol），但任何对象都不能有两个同名的属性。值可以是任何 JavaScript 值，也可以是 getter 或 setter 函数（或两者都是）。我们将在 §6.10.6 中学习 getter 和 setter 函数。</p>

<p>有时，能够区分直接在对象上定义的属性和从原型对象继承的属性是很重要的。JavaScript 使用术语“自有属性”来指代非继承属性。</p>

<p>除了名称和值之外，每个属性还有三个属性属性:</p>

<ul>
<li>writable 属性指定是否可以设置属性的值。</li>
<li>enumerable 属性指定 for/in 循环是否返回属性名称。</li>
<li>可配置属性指定该属性是否可以删除，是否可以修改其属性。</li>
</ul>

<p>许多 JavaScript 的内置对象具有只读、不可枚举或不可配置的属性。但是，在默认情况下，创建的对象的所有属性都是可写、可枚举和可配置的。§14.1 解释了为对象指定非默认属性属性值的技巧。</p>

<h2 id="toc_1">6.2 创建对象</h2>

<p>对象可以用对象字面量创建，也可以用 new 关键字和 Object.create() 函数来创建。接下来的几部分对这些技术一一讲述。</p>

<h3 id="toc_2">6.2.1 对象字面量</h3>

<p>创建对象最简单的方式就是在 JavaScript 代码中使用对象直接量。对象直接量是由若干名/值对组成的映射表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是 JavaScript 标识符也可以是字符串字面量（包括空字符串）。属性的值可以是任意类型的 JavaScript 表达式；表达式的值（可以是原始值也可以是对象值）变成这个属性的值。下面有一些例子：</p>

<pre><code class="language-javascript">let empty = {};                          // An object with no properties
let point = { x: 0, y: 0 };              // Two numeric properties
let p2 = { x: point.x, y: point.y+1 };   // More complex values
let book = {
    &quot;main title&quot;: &quot;JavaScript&quot;,          // These property names include spaces,
    &quot;sub-title&quot;: &quot;The Definitive Guide&quot;, // and hyphens, so use string literals.
    for: &quot;all audiences&quot;,                // for is reserved, but no quotes.
    author: {                            // The value of this property is
        firstname: &quot;David&quot;,              // itself an object.
        surname: &quot;Flanagan&quot;
    }
};
</code></pre>

<p>对象文本中最后一个属性的尾随逗号是合法的，并且某些编程样式鼓励使用这些尾随逗号，因为，如果之后在对象文本的末尾添加新属性，则不太可能导致语法错误。</p>

<p>对象字面量是一个表达式，它每次计算时都会创建和初始化一个新对象。每次字面量计算时，将计算每个属性的值。这意味着，如果单个对象字面量出现在循环体或重复调用的函数中，它能创建许多个新对象，并且这些对象的属性值可能彼此不同。</p>

<p>此处的简单语法对象字面量，自 JavaScript 最早的版本以来一直是合法的。最新版本引入了许多对象字面量的新的特性，这些特性在 §6.10 中介绍。</p>

<h3 id="toc_3">6.2.2 用 new 创建对象</h3>

<p>new 运算符创建并初始化一个新的对象。new 关键字必须紧跟一个函数调用。这种方式使用函数叫做构造函数调用，其提供初始化一个新创建的对象的服务。在 JavaScript 中，内置类型都包含相对应的构造函数。例如：</p>

<pre><code class="language-javascript">let o = new Object();  // Create an empty object: same as {}.
let a = new Array();   // Create an empty array: same as [].
let d = new Date();    // Create a Date object representing the current time
let r = new Map();     // Create a Map object for key/value mapping
</code></pre>

<p>除了这些内置构造函数，常常用自定义构造函数来初始化新对象。 第 9 章将详细讲述其中的细节。</p>

<h3 id="toc_4">6.2.3 原型</h3>

<p>在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个 JavaScript 对象都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。</p>

<p>所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。当第一次学习 JavaScript 时，这可能令人困惑。请记住：几乎所有对象都有原型，但只有相对较少的对象具有原型属性。正是这些具有原型属性的对象定义了所有其他对象的原型。</p>

<p>没有原型的对象为数不多，Object.prototype就是其中之一：它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。大部分的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如， Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。这一系列链接的原型对象就是所谓 “原型链”（prototype chain）。</p>

<p>§6.3.2 节讲述属性继承的工作机制。第 9 章将会更详细地讨论原型和构造函数：包括如何通过编写构造函数定义对象的“类”，以及给构造函数的 prototype 属性赋值可以让其“实例”直接使用这个原型上的属性和方法。并且在 §14.3 我们会学习如何查询（甚至改变）对象的原型。</p>

<h3 id="toc_5">6.2.4 Object.create()</h3>

<p>Object.create() 创建一个新的对象，用第一个实参作为它的原型：</p>

<pre><code class="language-javascript">let o1 = Object.create({x: 1, y: 2});     // o1 inherits properties x and y.
o1.x + o1.y                               // =&gt; 3
</code></pre>

<p>可以通过传入参数 null 来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如 toString()，也就是说，它将不能和“+”运算符一起正常工作：</p>

<pre><code class="language-javascript">let o2 = Object.create(null);             // o2 inherits no props or methods.
</code></pre>

<p>如果想创建一个普通的空对象（像通过 {} 或 new Object() 创建的对象），需要传入 Object.prototype：</p>

<pre><code class="language-javascript">let o3 = Object.create(Object.prototype); // o3 is like {} or new Object().
</code></pre>

<p>可以通过任意原型创建新对象，这是一个强大的特性，并且本章我们会在很多地方使用 Object.create()。（Object.create() 也可以传入第二个可选实参来描述这个新的对象的属性。第二个实参是一个高级特性，在  §14.1 再进行描述。）</p>

<p>Object.create() 其中一个用途是预防对象无意间（非恶意地）被无法支配的库函数篡改。可以创建一个继承它的对象来传递给函数，而不是将其直接传递给函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象：</p>

<pre><code class="language-javascript">let o = { x: &quot;don&#39;t change this value&quot; };
library.function(Object.create(o));  // Guard against accidental modifications
</code></pre>

<p>想要了解其工作原理，需要先知道 JavaScript 中属性的查询和设置机制。这是接下来这节的主题。</p>

<h2 id="toc_6">6.3 查询和设置属性</h2>

<p>§4.4 已经提到，可以通过点（.）或方括号（[]）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。如果使用点运算符，右侧必须是一个以属性名称命名的简单标识符。如果使用方括号，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字：</p>

<pre><code class="language-javascript">let author = book.author;       // Get the &quot;author&quot; property of the book.
let name = author.surname;      // Get the &quot;surname&quot; property of the author.
let title = book[&quot;main title&quot;]; // Get the &quot;main title&quot; property of the book.
</code></pre>

<p>和查询属性值的写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧：</p>

<pre><code class="language-javascript">book.edition = 7;                   // Create an &quot;edition&quot; property of book.
book[&quot;main title&quot;] = &quot;ECMAScript&quot;;  // Change the &quot;main title&quot; property.
</code></pre>

<p>当使用方括号时，我们说方括号内的表达式必须返回字符串。其实更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值或 Symbol（§6.10.3）。在第 7 章里有一些例子中的方括号内使用了数字，这情况是非常常用的。</p>

<h3 id="toc_7">6.3.1 对象作关联数组</h3>

<p>上文提到，下面两个表达式有相同的值：</p>

<pre><code class="language-javascript">object.property
object[&quot;property&quot;]
</code></pre>

<p>第一种语法使用点运算符和一个标识符，这和 C 和 Java 中访问一个结构体或对象的静态字段非常类似。第二种语法使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array）（也称做散列、映射或字典）。JavaScript 对象都是关联数组，本节将讨论它的重要性。</p>

<p>在 C、C++、Java 和一些强类型语言中，对象只能拥有固定数目的属性，并且这些属性的名称必须提前定义好。由于 JavaScript 是一个弱类型语言，因此不适用这条规则：对象在程序中可以创建任意数量的属性。当使用 . 运算符访问对象的属性时，属性名用一个标识符来表示。标识符必须直接出现在 JavaScript 程序中，它们不是数据类型，所以无法在程序中修改。</p>

<p>另一种方式，当通过 [] 来访问对象的属性时，属性名通过字符串来表示。字符串是 JavaScript 的数据类型，在程序运行时可以修改和创建它们。因此，可以在 JavaScript 中使用下面这种代码：</p>

<pre><code class="language-javascript">let addr = &quot;&quot;;
for(let i = 0; i &lt; 4; i++) {
    addr += customer[`address${i}`] + &quot;\n&quot;;
}
</code></pre>

<p>这段代码读取 customer 对象的 address0、address1、address2 和 address3 属性，并将它们连接起来。</p>

<p>这个例子主要说明了通过字符串表达式使用数组标记来访问对象属性的灵活性。这段代码也可以通过点运算符来重写，但是一些场景只能使用数组写法来完成。假设你正在写一个程序，这个程序利用网络资源计算用户股票市场投资的当前价值。程序允许用户输入他们拥有的股票名称以及对应的数量。你可以用一个名为 portfolio 的对象来储存这些信息。每一个股票在对象中都有一个属性与之对应。属性名是股票名，属性值是股票持有份额。例如，如果用户持有 IBM 的 50 股，那么 portfolio.ibm 属性的值就为 50。</p>

<p>下面是程序的部分代码，这个函数用来给 portifolio 添加新的股票：</p>

<pre><code class="language-javascript">function addstock(portfolio, stockname, shares) {
    portfolio[stockname] = shares;
}
</code></pre>

<p>由于用户是在程序运行时输入股票名称，因此在之前无法得知这些股票的名称是什么。而由于在写程序的时候不知道属性名称，因此无法通过点运算符（.）来访问对象 portfolio 的属性。但可以使用 [] 运算符，因为它使用字符串值（字符串值是动态的，可以在运行时更改）而不是标识符（标识符是静态的，必须写死在程序中）作为索引对属性进行访问。</p>

<p>第 5 章介绍了 for/in 循环（§6.6 节还会进一步介绍）。当使用 for/in 循环遍历关联数组时，就可以清晰地体会到 for/in 的强大之处。下面的例子就是利用 for/in 计算  portfolio 的合计值：</p>

<pre><code class="language-javascript">function computeValue(portfolio) {
    let total = 0.0;
    for(let stock in portfolio) {       // For each stock in the portfolio:
        let shares = portfolio[stock];  // get the number of shares
        let price = getQuote(stock);    // look up share price
        total += shares * price;        // add stock value to total value
    }
    return total;                       // Return total value.
}
</code></pre>

<p>如本节所示，JavaScript 对象通常用作关联数组，理解其工作原理非常重要。但是，在 ES6 之后使用 Map 类常常是一个更好的选择，我们将在 §11.1.2 中进行描述。</p>

<h3 id="toc_8">6.3.2 继承</h3>

<p>JavaScript 对象中有一组“自有属性”，也有一组属性是继承自它的原型对象。想要理解属性继承，必须更深入地了解属性访问的细节。这一节的例子通过使用 Object.create() 函数创建对象来指定它的原型。我们会在第 9 章再次看到它，但是，每次使用 new 创建类的实例时，都会创建一个从原型对象继承属性的对象。</p>

<p>假设要查询对象 o 的属性 x。如果 o 中不存在 x 名称的自由属性，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到 x 或者查找到一个原型是 null 的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。</p>

<pre><code class="language-javascript">let o = {};               // o inherits object methods from Object.prototype
o.x = 1;                  // and it now has an own property x.
let p = Object.create(o); // p inherits properties from o and Object.prototype
p.y = 2;                  // and has an own property y.
let q = Object.create(p); // q inherits properties from p, o, and...
q.z = 3;                  // ...Object.prototype and has an own property z.
let f = q.toString();     // toString is inherited from Object.prototype
q.x + q.y                 // =&gt; 3; x and y are inherited from o and p
</code></pre>

<p>现在假设给对象 o 的属性 x 赋值，如果 o 中已经有属性 x（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性 x 的值。否则，赋值操作给 o 添加一个新属性 x。如果之前 o 继承自属性 x，那么这个继承的属性就被新创建的同名属性覆盖了。</p>

<p>属性赋值操作检查原型链只是判断是否允许赋值操作。例如，如果 o 继承自一个只读属性 x，那么赋值操作是不允许的（§6.3.3 将对此进行详细讨论）。 如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在 JavaScript 中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是 JavaScript 的一个重要特性，该特性让程序员可以有选择地重写继承的属性。</p>

<pre><code class="language-javascript">let unitcircle = { r: 1 };         // An object to inherit from
let c = Object.create(unitcircle); // c inherits the property r
c.x = 1; c.y = 1;                  // c defines two properties of its own
c.r = 2;                           // c overrides its inherited property
unitcircle.r                       // =&gt; 1: the prototype is not affected
</code></pre>

<p>属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性。但有一个例外，如果 o 继承自属性 x，而这个属性是一个具有 setter 方法的存取器属性（参照 §6.10.6），那么这时将调用 setter 方法而不是给 o 创建一个属性 x。需要注意的是，setter 方法是由对象 o 调用的，而不是定义这个属性的原型对象调用的。因此如果 setter 方法定义任意属性，这个操作只是针对 o 本身，并不会修改原型链。</p>

<h3 id="toc_9">6.3.3 属性访问异常</h3>

<p>属性访问表达式并不总是返回或设置一个值。本节讲述查询或设置属性时的一些出错情况。</p>

<p>查询一个不存在的属性并不会报错，如果在对象 o 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。回想一下我们的 book 对象有属性“sub-title”，而没有属性“subtitle”：</p>

<pre><code class="language-javascript">book.subtitle    // =&gt; undefined: property doesn&#39;t exist
</code></pre>

<p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null 和 undefined 值都没有属性，因此查询这些值的属性会报错，接上例：</p>

<pre><code class="language-javascript">let len = book.subtitle.length; // !TypeError: undefined doesn&#39;t have length
</code></pre>

<p>如果 . 的左边是 null 或 undefined 时，其属性表达式会失败。所以当写一个像 book.author.surname 一样的表达式时，如果你不确定 book 和 book.author 确实被定义就要小心了。下面提供了两种避免出错的方法：</p>

<pre><code class="language-javascript">// A verbose and explicit technique
let surname = undefined;
if (book) {
    if (book.author) {
        surname = book.author.surname;
    }
}

// A concise and idiomatic alternative to get surname or null or undefined
surname = book &amp;&amp; book.author &amp;&amp; book.author.surname;
</code></pre>

<p>为了理解为什么这里的第二种方法可以避免类型错误异常，可以参照 §4.10.1节 中关于 &amp;&amp; 运算符的短路行为。</p>

<p>如 §4.4.1 中所描述，ES2020 支持用 ?. 条件属性访问，它允许这样重写上面的赋值表达式：</p>

<pre><code class="language-javascript">let surname = book?.author?.surname;
</code></pre>

<p>当然，给 null 和 undefined 设置属性也会报类型错误。给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性。在严格模式下（§5.6.3），属性设定失败时会抛出 TypeError 异常。在非严格模式下，这些失败的处理经常没有任何反应。</p>

<p>尽管属性赋值成功或失败的规律看起来很简单，但要描述清楚并不容易。在这些场景下给对象 o 设置属性 p 会失败：</p>

<p>o 中的属性 p 是只读的：不能给只读属性重新赋值。</p>

<p>o 中的属性 p 是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。</p>

<p>o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且o的可扩展性是（见 §14.2）false。如果 o 中不存在 p，而且没有 setter 方法可供调用，则 p 一定会添加至 o 中。但如果 o 不是可扩展的，那么在 o 中不能定义新属性。</p>

<h2 id="toc_10">6.4 删除属性</h2>

<p>删除运算符（§4.13.4）能删除对象中的属性。它的操作数应当是一个属性访问表达式。令人意外的是，delete 没有操作属性的值，而是操作属性的属性：</p>

<pre><code class="language-javascript">delete book.author;          // The book object now has no author property.
delete book[&quot;main title&quot;];   // Now it doesn&#39;t have &quot;main title&quot;, either.
</code></pre>

<p>delete 运算符只删除自有属性，不删除继承属性。（想要删除一个继承属性，必须从定义这个属性的原型对象上删除它。这会影响所有继承这个原型的对象。）</p>

<p>如果删除成功或删除没有任何影响时删除表达式计算结果是 true（如删除不存在的属性）。delete 作用于非属性访问表达式（无用代码）时也返回 true。</p>

<pre><code class="language-javascript">let o = {x: 1};    // o has own property x and inherits property toString
delete o.x         // =&gt; true: deletes property x
delete o.x         // =&gt; true: does nothing (x doesn&#39;t exist) but true anyway
delete o.toString  // =&gt; true: does nothing (toString isn&#39;t an own property)
delete 1           // =&gt; true: nonsense, but true anyway
</code></pre>

<p>delete 不能删除那些可配置性为 false 的属性。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。在严格模式中，删除一个不可配置属性会报一个类型错误。在非严格模式中，在这些情况下的 delete 操作会返回 false：</p>

<pre><code class="language-javascript">// In strict mode, all these deletions throw TypeError instead of returning false
delete Object.prototype // =&gt; false: property is non-configurable
var x = 1;              // Declare a global variable
delete globalThis.x     // =&gt; false: can&#39;t delete this property
function f() {}         // Declare a global function
delete globalThis.f     // =&gt; false: can&#39;t delete this property either
</code></pre>

<p>当在非严格模式中删除全局对象的可配值属性时，可以省略对全局对象的引用，直接在 delete 操作符后跟随要删除的属性名即可：</p>

<pre><code class="language-javascript">globalThis.x = 1;       // Create a configurable global property (no let or var)
delete x                // =&gt; true: this property can be deleted
</code></pre>

<p>然而在严格模式中，delete 后跟随一个非法的操作数（比如 x），则会报一个语法错误，因此必须显式指定对象及其属性：</p>

<pre><code class="language-javascript">delete x;               // SyntaxError in strict mode
delete globalThis.x;    // This works
</code></pre>

<h2 id="toc_11">6.5 测试属性</h2>

<p>JavaScript 对象可以看作属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以用 in 运算符、hasOwnPreperty() 和  propertyIsEnumerable() 方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。这节的例子都是用字符串作为属性名称，但是也可以用 Symbol 作为属性名（§6.10.3）。</p>

<p>in 运算符的左侧是属性名，右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true：</p>

<pre><code class="language-javascript">let o = { x: 1 };
&quot;x&quot; in o         // =&gt; true: o has an own property &quot;x&quot;
&quot;y&quot; in o         // =&gt; false: o doesn&#39;t have a property &quot;y&quot;
&quot;toString&quot; in o  // =&gt; true: o inherits a toString property
</code></pre>

<p>对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false：</p>

<pre><code class="language-javascript">let o = { x: 1 };
o.hasOwnProperty(&quot;x&quot;)        // =&gt; true: o has an own property x
o.hasOwnProperty(&quot;y&quot;)        // =&gt; false: o doesn&#39;t have a property y
o.hasOwnProperty(&quot;toString&quot;) // =&gt; false: toString is an inherited property
</code></pre>

<p>propertyIsEnumerable() 是 hasOwnProperty() 的增强版。只有检测到是自有属性且这个属性的可枚举性为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非使用  §14.1 中介绍的技术来让它们不可枚举。</p>

<pre><code class="language-javascript">let o = { x: 1 };
o.propertyIsEnumerable(&quot;x&quot;)  // =&gt; true: o has an own enumerable property x
o.propertyIsEnumerable(&quot;toString&quot;)  // =&gt; false: not an own property
Object.prototype.propertyIsEnumerable(&quot;toString&quot;) // =&gt; false: not enumerable
</code></pre>

<p>除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined：</p>

<pre><code class="language-javascript">let o = { x: 1 };
o.x !== undefined        // =&gt; true: o has a property x
o.y !== undefined        // =&gt; false: o doesn&#39;t have a property y
o.toString !== undefined // =&gt; true: o inherits a toString property
</code></pre>

<p>然而有一种场景只能使用 in 运算符而不能使用上述属性访问的方式。in 可以区分不存在的属性和存在但值为 undefined 的属性。例如下面的代码：</p>

<pre><code class="language-javascript">let o = { x: undefined };  // Property is explicitly set to undefined
o.x !== undefined          // =&gt; false: property exists but is undefined
o.y !== undefined          // =&gt; false: property doesn&#39;t even exist
&quot;x&quot; in o                   // =&gt; true: the property exists
&quot;y&quot; in o                   // =&gt; false: the property doesn&#39;t exist
delete o.x;                // Delete the property x
&quot;x&quot; in o                   // =&gt; false: it doesn&#39;t exist anymore
</code></pre>

<h2 id="toc_12">6.6 枚举属性</h2>

<p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。有几种不同的方法可以做到这一点。</p>

<p>§5.4.5 讨论过 for/in 循环，其可以在循环体中遍历指定对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的 内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非用下文中提到的一个方法将它们转换为不可枚举的）。例如：</p>

<pre><code class="language-javascript">let o = {x: 1, y: 2, z: 3};          // Three enumerable own properties
o.propertyIsEnumerable(&quot;toString&quot;)   // =&gt; false: not enumerable
for(let p in o) {                    // Loop through the properties
    console.log(p);                  // Prints x, y, and z, but not toString
}
</code></pre>

<p>为了防止 for/in 枚举到继承属性，可以在循环中添加显示检查：</p>

<pre><code class="language-javascript">for(let p in o) {
    if (!o.hasOwnProperty(p)) continue;       // Skip inherited properties
}

for(let p in o) {
    if (typeof o[p] === &quot;function&quot;) continue; // Skip all methods
}
</code></pre>

<p>作为使用 for/in 循环的替代方法，通常使用 for/of 循环遍历易获取对象的属性名称数组。可以使用四个函数获取属性名称数组：</p>

<p>Object.keys() 返回对象的可枚举自有属性名称数组集合。数组内不包含不可枚举属性、继承属性或属性名称是 Symbol（见 §6.10.3）的属性</p>

<p>Object.getOwnPropertyNames() 用起来和 Object.keys() 类似，但是它返回数组中也包含不可迭代的自有属性，只要它们的名称是字符串。</p>

<p>Object.getOwnPropertySymbols() 返回名称是 Symbol 的自有属性，无论它们是否可枚举。</p>

<p>Reflect.ownKeys() 返回所有的自由属性名称，包括可枚举和不可枚举类型，也包括字符串和 Symbol（见 §14.6）。</p>

<p>在 §6.7 中有例子使用 for/of 循环 Object.keys()。</p>

<h3 id="toc_13">6.6.1 属性枚举顺序</h3>

<p>ES6 正式定义元素的自有属性的枚举顺序。Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Reflect.ownKeys() 和相关方法如 JSON.stringify() 属性列表都按以下顺序排列的，受它们自身是否是不可枚举属性列表或者属性是字符串或者 Symbol 影响：</p>

<p>首先列出名称为非负整数的字符串属性，按从最小到最大的数字顺序列出。此规则意味着数组和数组类对象将按顺序枚举其属性。</p>

<p>列出所有看起来像数组索引的属性后，将列出所有具有字符串名称的剩余属性（包括看起来像负数或浮点数字的属性）。这些属性按添加到对象的顺序列出。对于在对象字面量中定义的属性，此顺序与它们在文本中显示的顺序相同。</p>

<p>最后，其名称为 Symbol 对象的属性按添加到对象的顺序列出。</p>

<p>for/in 循环的枚举顺序不像这些枚举函数那样严格指定，但实现通常按刚才描述的顺序枚举自己的属性，然后向上移动原型链按相同顺序枚举每个原型对象的属性。但是请注意，如果已枚举具有相同名称的属性，或者不可枚举属性已经被检测过再次枚举到相同名称的属性，都不会再次枚举。</p>

<h2 id="toc_14">6.7 扩展对象</h2>

<p>在 JavaScript 代码中有一个很常见的操作，需要将一个对象中的属性拷贝到另外一个对象。以下面的代码很容易实现：</p>

<pre><code class="language-javascript">let target = {x: 1}, source = {y: 2, z: 3};
for(let key of Object.keys(source)) {
    target[key] = source[key];
}
target  // =&gt; {x: 1, y: 2, z: 3}
</code></pre>

<p>但是因为这个是个常用的操作，各种 JavaScript 框架定义公用函数，经常将其命名为 extend() 来执行这个拷贝操作。最后在 ES6 中，这个功能以 Object.assign() 的形式被添加到 JavaScript 核心语言中。</p>

<p>Object.assign() 需要两个或多个对象作为其实参。它修改并返回第一个实参，即目标对象，但不会改变第二个或任何后续参数，这些参数是源对象。对于每个源对象，它将该对象的可枚举自有属性（包括名称为 Symbol 的属性）复制到目标对象中。它按源对象在实参列表顺序中的顺序处理，所以第一个源对象中的属性会重写在目标对象中的同名属性，然后以第二个源对象中的同名属性（如果有第二个源对象）再次重写第一个源对象重写后的属性。</p>

<p>Object.assign() 通过普通属性的 get 和 set 操作复制属性，因此，如果源对象具有 getter 方法或目标对象具有 setter 方法，则将在复制期间调用它们，但不会复制方法本身。</p>

<p>看这样一个场景，有一个对象定义许多属性的默认值，希望将这些默认属性中不存在于目标对象中的属性复制到目标对象中，使用 Object.assign() 不会得到想要的结果：</p>

<pre><code class="language-javascript">Object.assign(o, defaults);  // overwrites everything in o with defaults
</code></pre>

<p>想得到这个效果需要创建一个新的对象，将默认值拷贝到其中，然后用 o 的属性重写默认值中的属性：</p>

<pre><code class="language-javascript">o = Object.assign({}, defaults, o);
</code></pre>

<p>我们会在 §6.10.4 见到，可以用 ... 展开操作符如下操作这个对象拷贝并重写：</p>

<pre><code class="language-javascript">o = {...defaults, ...o};
</code></pre>

<p>为了避免对象创建和复制的额外开销，我们还可以通过编写一个 Object.assign() 仅在缺少属性时复制属性：</p>

<pre><code class="language-javascript">// Like Object.assign() but doesn&#39;t override existing properties
// (and also doesn&#39;t handle Symbol properties)
function merge(target, ...sources) {
    for(let source of sources) {
        for(let key of Object.keys(source)) {
            if (!(key in target)) { // This is different than Object.assign()
                target[key] = source[key];
            }
        }
    }
    return target;
}
Object.assign({x: 1}, {x: 2, y: 2}, {y: 3, z: 4})  // =&gt; {x: 2, y: 3, z: 4}
merge({x: 1}, {x: 2, y: 2}, {y: 3, z: 4})          // =&gt; {x: 1, y: 2, z: 4}
</code></pre>

<p>编写其他属性操作公共函数很简单，就是像这个 merge() 函数。例如，如果对象的属性不出现在另一个模板对象中，则 restrict() 函数会删除这些属性。或者，subtract() 函数可以从其他对象中删除一个对象的所有属性。</p>

<h2 id="toc_15">6.8 序列化对象</h2>

<p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是“JavaScript Object Notation”——JavaScript 对象表示法，它的语法和 JavaScript 对象与数组字面量的语法非常相近：</p>

<pre><code class="language-javascript">let o = {x: 1, y: {z: [false, null, &quot;&quot;]}}; // Define a test object
let s = JSON.stringify(o);   // s == &#39;{&quot;x&quot;:1,&quot;y&quot;:{&quot;z&quot;:[false,null,&quot;&quot;]}}&#39;
let p = JSON.parse(s);       // p == {x: 1, y: {z: [false, null, &quot;&quot;]}}
</code></pre>

<p>JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。支持对象、数组、字符串、无穷大数字、true、false 和 null，并且它们可以序列化和还原。NaN、Infinity 和 -Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON() 函数），但 JSON.parse() 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify() 和 JSON.parse() 都可以接收第二个可选实参，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。§11.6 有关于这些函数的详细文档。</p>

<h2 id="toc_16">6.9 对象方法</h2>

<p>上文已经讨论过，所有的 JavaScript 对象都从 Object.prototype 继承属性（除了那些不通过原型显式创建的对象）。这些继承属性主要是方法，因为 JavaScript 程序员普遍对继承方法更感兴趣。例如我们已经见过的 hasOwnProperty() 和 propertyIsEnumerable() 方法。（并且我们也已经提到了一小部分定义在对象构造函数中的静态函数，像 Object.create() 和 Object.keys()。）本节介绍在 Object.prototype 上定义的少数通用对象方法，但是这些方法经常会被更专业的实现所取代。在下面的各节中，我们将展示在单个对象上定义这些方法的示例。在第 9 章中，将学习如何更常规化地为整个对象类定义这些方法。</p>

<h3 id="toc_17">6.9.1 toString() 方法</h3>

<p>toString() 方法没有实参，它将返回一个表示调用这个方法的对象值的字符串。在需要将对象转换为字符串的时候，JavaScript 都会调用这个方法。比如，当使用 + 运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用 toString()。</p>

<p>默认的 toString() 方法的返回值带有的信息量很少（尽管它在检测对象的类型时非常有用，参照 §14.4.3），例如，下面这行代码的计算结果为字符串”[object Object]”：</p>

<pre><code class="language-javascript">let s = { x: 1, y: 1 }.toString();  // s == &quot;[object Object]&quot;
</code></pre>

<p>由于默认的 toString() 方法并不会输出很多有用的信息，因此很多类都带有自定义的 toString()。例如，当数组转换为字符串的时候，结果是一个数组元素列表，只是每个元素都转换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。可以像下面这样自定义 toString() 方法：</p>

<pre><code class="language-javascript">let point = {
    x: 1,
    y: 2,
    toString: function() { return `(${this.x}, ${this.y})`; }
};
String(point)    // =&gt; &quot;(1, 2)&quot;: toString() is used for string conversions
</code></pre>

<h3 id="toc_18">6.9.2 toLocaleString() 方法</h3>

<p>除了基本的 toString() 方法之外，对象都包含 toLocaleString() 方法，这个方法返回一个表示这个对象的本地化字符串。Object 中默认的 toLocaleString() 方法并不做任何本地化自身的操作，它仅调用 toString() 方法并返回对应值。Date 和 Number 类对 toLocaleString() 方法做了定制，可以用它对数字、日期和时间做本地化的转换。 Array 类的 toLocaleString() 方法和 toString() 方法很像，唯一的不同是每个数组元素会调用 toLocaleString() 方法转换为字符串，而不是调用各自的 toString() 方法。可以像这样使用 point 对象做到同样的效果：</p>

<pre><code class="language-javascript">let point = {
    x: 1000,
    y: 2000,
    toString: function() { return `(${this.x}, ${this.y})`; },
    toLocaleString: function() {
        return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`;
    }
};
point.toString()        // =&gt; &quot;(1000, 2000)&quot;
point.toLocaleString()  // =&gt; &quot;(1,000, 2,000)&quot;: note thousands separators
</code></pre>

<p>在 §11.7 的国际化类中，toLocaleString() 方法的实现是非常有用的。</p>

<h3 id="toc_19">6.9.3 valueOf() 方法</h3>

<p>valueOf() 方法和 toString() 方法非常类似，但往往当 JavaScript 需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法。默认的 valueOf() 方法不足为奇，但有些内置类自定义了 valueOf() 方法. Date 类定义 valueOf() 将日期转化成数值型，并且这允许 Date 对象使用 &lt; 和 &gt; 按时间先手顺序比较。可以对 point 对象做同样的事，定义一个 valueOf() 方法返回原点到点的距离：</p>

<pre><code class="language-javascript">let point = {
    x: 3,
    y: 4,
    valueOf: function() { return Math.hypot(this.x, this.y); }
};
Number(point)  // =&gt; 5: valueOf() is used for conversions to numbers
point &gt; 4      // =&gt; true
point &gt; 5      // =&gt; false
point &lt; 6      // =&gt; true
</code></pre>

<h3 id="toc_20">6.9.4 toJSON() 方法</h3>

<p>Object.prototype 实际上没有定义 toJSON() 方法，但对于需要执行序列化的对象来说，JSON.stringify() 方法（见 §6.8）会调用 toJSON() 方法。如果在待序列化的对象中存在这 个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。Date 类（§11.4）定义了 toJSON() 方法返回日期的序列化字符串。我们可以这样对 point 对象做同样的事：</p>

<pre><code class="language-javascript">let point = {
    x: 1,
    y: 2,
    toString: function() { return `(${this.x}, ${this.y})`; },
    toJSON: function() { return this.toString(); }
};
JSON.stringify([point])   // =&gt; &#39;[&quot;(1, 2)&quot;]&#39;
</code></pre>

<h2 id="toc_21">6.10 扩展的对象字面量语法</h2>

<p>JavaScript 的最新版本扩展了许多有用的对象字面量相关的语法。以下小节解释这些扩展。</p>

<h3 id="toc_22">6.10.1 速记属性</h3>

<p>假设值存储在变量 x 和 y 中，并且想要创建具有名为 x 和 y 的属性的对象，这些属性包含这些值。使用基本对象字面量语法，最终会重复每个标识符两次：</p>

<pre><code class="language-javascript">let x = 1, y = 2;
let o = {
    x: x,
    y: y
};
</code></pre>

<p>在 ES6 之后，可以删除标识符的冒号和一个副本，最终使用更简单的代码：</p>

<pre><code class="language-javascript">let x = 1, y = 2;
let o = { x, y };
o.x + o.y  // =&gt; 3
</code></pre>

<h3 id="toc_23">6.10.2 计算属性名</h3>

<p>有时需要创建具有特定属性的对象，但该属性的名称不是可以在源代码中键入的编译时常量。相反，需要的属性名称存储在变量中，或者是调用的函数的返回值。不能对此类属性使用基本对象字面量。而必须创建一个对象，通过额外的步骤，添加所需的属性：</p>

<pre><code class="language-javascript">const PROPERTY_NAME = &quot;p1&quot;;
function computePropertyName() { return &quot;p&quot; + 2; }

let o = {};
o[PROPERTY_NAME] = 1;
o[computePropertyName()] = 2;
</code></pre>

<p>使用称为计算属性的 ES6 特性设置这样的对象要简单得多，该功能允许从前面的代码写入方括内并直接移动到对象字面量中：</p>

<pre><code class="language-javascript">const PROPERTY_NAME = &quot;p1&quot;;
function computePropertyName() { return &quot;p&quot; + 2; }

let p = {
    [PROPERTY_NAME]: 1,
    [computePropertyName()]: 2
};

p.p1 + p.p2 // =&gt; 3
</code></pre>

<p>使用这种新语法，方括号将其分隔成 JavaScript 表达式。计算该表达式，并将结果值（如有必要转换为字符串）用作属性名称。</p>

<p>可能想要使用计算属性的一个情况是，有一个 JavaScript 代码库，该库希望传递具有一组特定属性的对象，并且这些属性的名称定义为该库中的常量。如果要编写代码以创建将传递给该库的对象，可以硬编码属性名称，但如果在任何地方键入错误的属性名称，则存在错误风险；如果库的新版本更改了所需的属性名称，则存在版本不匹配问题的风险。相反，可能会发现，使用计算属性语法与库定义的属性名称常量时，它使代码更加健壮。</p>

<h3 id="toc_24">6.10.3 Symbol 作属性名</h3>

<p>计算属性语法启用了另一个非常重要的对象字面量特性。在 ES6 之后，属性名称可以是字符串或 Symbol。如果将 Symbol 分配给变量或常量，则可以使用计算属性语法将该 Symbol 用作属性名称：</p>

<pre><code class="language-javascript">const extension = Symbol(&quot;my extension symbol&quot;);
let o = {
    [extension]: { /* extension data stored in this object */ }
};
o[extension].x = 0; // This won&#39;t conflict with other properties of o
</code></pre>

<p>如 §3.6 中所述，符号是不透明值。除了将它们用作属性名称，不能对它们进行任何其他处理。但是，每个 Symbol 都不同于所有其他 Symbol，这意味着 Symbol 适合创建唯一的属性名称。通过调用 Symbol() 工厂函数创建新 Symbol。（Symbol 是原始值，而不是对象，因此 Symbol() 不是使用 new 调用的构造函数。）Symbol() 返回的值不等于任何其他 Symbol 或其他值。可以将字符串传递给 Symbol()，当 Symbol 转换为字符串时，将使用此字符串。但是，这只是一个调试帮助：使用同一字符串参数创建的两个 Symbol 仍然彼此不同。</p>

<p>Symbol 的要点不是安全性，而是为 JavaScript 对象定义一个安全的扩展机制。如果从第三方代码获取对象，您无法控制该对象，并且需要向该对象添加自己的一些属性，但希望确保属性不会与对象上可能存在的任何属性冲突，可以安全地使用 Symbol 作为属性名称。如果这样做，还可以确信第三方代码不会意外更改 Symbol 命名的属性。（当然，该第三方代码可以使用 Object.getOwnPropertySymbols() 来发现你使用的 Symbol，然后可以更改或删除你的属性。这就是为什么符号不是安全机制。）</p>

<h3 id="toc_25">6.10.4 展开运算符</h3>

<p>在 ES2018 之后，可以使用展开运算符 ... 将现有的对象中的属性复制到新的对象中：</p>

<pre><code class="language-javascript">let position = { x: 0, y: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ...position, ...dimensions };
rect.x + rect.y + rect.width + rect.height // =&gt; 175
</code></pre>

<p>在此代码中，position 和 dimensions 对象的属性被展开到 rect 对象字面量中，就像它们以字面量的方式写入这些大括号中一样。请注意，... 语法通常称为展开运算符，但在任何情况下都不是真正的 JavaScript 运算符。相反，它是一种特殊情况下语法，仅在对象文本中可用。（... 在别的 JavaScript 上下文中有其他用途，但是对象字面量上下文中只有这一种用法。）</p>

<p>如果展开的目标对象和源对象中具有相同的名称，则该属性的值将是位置处于后面的值：</p>

<pre><code class="language-javascript">let o = { x: 1 };
let p = { x: 0, ...o };
p.x   // =&gt; 1: the value from object o overrides the initial value
let q = { ...o, x: 2 };
q.x   // =&gt; 2: the value 2 overrides the previous value from o.
</code></pre>

<p>还有注意展开运算符只展开对象的自有属性，不展开继承属性：</p>

<pre><code class="language-javascript">let o = Object.create({x: 1}); // o inherits the property x
let p = { ...o };
p.x                            // =&gt; undefined
</code></pre>

<p>最后，值得注意的是，虽然展开运算符在代码中只是三个小点，但它对 JavaScript 解释器来说可以代表大量的工作。如果对象具有 n 个属性，则将这些属性分散到另一个对象的过程很可能是 O(n) 操作。这意味着，如果你发现自己在使用 ... 在循环或递归函数中，类似将数据累积到一个大对象中的方法，您可能正在编写一个低效的 O(n2) 算法，该算法不会随着 n 变大而扩展。</p>

<h3 id="toc_26">6.10.5 速记方法</h3>

<p>当函数被定义为对象的属性时，我们称该函数为方法（我们将在第 8 章和第 9 章中对方法有更多的描述）。在 ES6 之前，在对象字面量中用函数定义表达式定义一个方法和在对象中定义其他属性一样：</p>

<pre><code class="language-javascript">let square = {
    area: function() { return this.side * this.side; },
    side: 10
};
square.area() // =&gt; 100
</code></pre>

<p>但是，在 ES6 中，对象字面量语法（以及我们将在第 9 章中看到的类定义语法）已扩展成允许省略函数关键字和冒号的快捷方式，可以写成这样的代码：</p>

<pre><code class="language-javascript">let square = {
    area() { return this.side * this.side; },
    side: 10
};
square.area() // =&gt; 100
</code></pre>

<p>两种形式是相同的：在对象字面量中添加一个名为 area 的属性，并指定一个函数为这个属性的值。速记语法更清晰的看出 area() 是一个方法而不是一个像 side 一样的数据属性。</p>

<p>使用此速记语法编写方法时，属性名称可以采用对象字面量中的任何合法形式：除了像上面的名称 area 这样的常规 JavaScript 标识符外，还可以使用字符串字面量和计算属性名称，包括 Symbol 属性名称：</p>

<pre><code class="language-javascript">const METHOD_NAME = &quot;m&quot;;
const symbol = Symbol();
let weirdMethods = {
    &quot;method With Spaces&quot;(x) { return x + 1; },
    [METHOD_NAME](x) { return x + 2; },
    [symbol](x) { return x + 3; }
};
weirdMethods[&quot;method With Spaces&quot;](1)  // =&gt; 2
weirdMethods[METHOD_NAME](1)           // =&gt; 3
weirdMethods[symbol](1)                // =&gt; 4
</code></pre>

<p>使用 Symbol 作为方法名称并不像看起来那么奇怪。为了使对象可迭代（因此它可以与 for/of 循环一起使用），必须定义一个具有符号名称 Symbol.iterator 的方法，并且在第 12 章中有这样做的示例。</p>

<h3 id="toc_27">6.10.6 属性 Getter 和 Setter 方法</h3>

<p>到目前为止，本节我们所讨论的所有的对象都是具有名称和普通值的数据属性。JavaScript 还支持存取器属性，这些属性没有单个值，而是具有一个或两个存取器方法：getter 和或是或 setter。</p>

<p>当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无实参）。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时， JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。</p>

<p>如果属性同时有 getter 和 setter 方法，则它是一个可读写属性。如果它只含有 getter 方法，它是一个只读属性。如果它只有 setter 方法，它是一个只可写属性（这对一个数据属性来说是不可能的），如果尝试去读它，计算结果永远是 undefined。</p>

<p>存储器属性可以通过表达式在对象字面量语法中定义（不像我们在这里看到的其他 ES6 扩展，getter 和 setter 是 ES5 中的内容）：</p>

<pre><code class="language-javascript">let o = {
    // An ordinary data property
    dataProp: value,

    // An accessor property defined as a pair of functions.
    get accessorProp() { return this.dataProp; },
    set accessorProp(value) { this.dataProp = value; }
};
</code></pre>

<p>存储器属性定义为名称与属性名称相同的一个或两个方法。这些方法看起来像使用 ES6 速记定义的普通方法，只不过 getter 和 setter 定义使用 get 或 set 前缀。（在 ES6 中，在定义 getter 和 setter 时还可以使用计算属性名称。只需将带方括号的表达式替换属性名称即可。</p>

<p>上面定义的存储器方法只需获取并设置数据属性的值，没有理由将存储器属性替换数据属性。但作为一个更有趣的示例，请考虑以下表示 2D 笛卡尔点的对象。它具有表示点的 x 和 y 坐标的普通数据属性，并且具有提供点等效极坐标的存储器属性：</p>

<pre><code class="language-javascript">let p = {
    // x and y are regular read-write data properties.
    x: 1.0,
    y: 1.0,

    // r is a read-write accessor property with getter and setter.
    // Don&#39;t forget to put a comma after accessor methods.
    get r() { return Math.hypot(this.x, this.y); },
    set r(newvalue) {
        let oldvalue = Math.hypot(this.x, this.y);
        let ratio = newvalue/oldvalue;
        this.x *= ratio;
        this.y *= ratio;
    },

    // theta is a read-only accessor property with getter only.
    get theta() { return Math.atan2(this.y, this.x); }
};
p.r     // =&gt; Math.SQRT2
p.theta // =&gt; Math.PI / 4
</code></pre>

<p>请注意，在本示例中的 getter 和 setter 中使用 this 关键字。JavaScript 以对象的方法的方式调用这些函数，这意味着在函数体中，this 指的是点对象 p。因此，r 属性的 getter 方法通过 this.x 和 this.y 获取到 x 和 y 属性的引用。方法以及 this 关键字在 §8.2.2 中详细介绍。</p>

<p>存储器属性是可继承的，就像数据属性一样，因此可以使用上面定义的对象 p 作为其他点的原型。可以为新对象提供自有的 x 和 y 属性，它们将继承 r 和 theta 属性：</p>

<pre><code class="language-javascript">let q = Object.create(p); // A new object that inherits getters and setters
q.x = 3; q.y = 4;         // Create q&#39;s own data properties
q.r                       // =&gt; 5: the inherited accessor properties work
q.theta                   // =&gt; Math.atan2(4, 3)
</code></pre>

<p>上述代码使用存储器属性定义一个 API，该 API 提供一组数据的两种表示形式（笛卡尔坐标和极坐标）。使用存储器属性的其他场景包括属性写入的稳健性检测以及在每个属性上返回不同的值：</p>

<pre><code class="language-javascript">// This object generates strictly increasing serial numbers
const serialnum = {
    // This data property holds the next serial number.
    // The _ in the property name hints that it is for internal use only.
    _n: 0,

    // Return the current value and increment it
    get next() { return this._n++; },

    // Set a new value of n, but only if it is larger than current
    set next(n) {
        if (n &gt; this._n) this._n = n;
        else throw new Error(&quot;serial number can only be set to a larger value&quot;);
    }
};
serialnum.next = 10;    // Set the starting serial number
serialnum.next          // =&gt; 10
serialnum.next          // =&gt; 11: different value each time we get next
</code></pre>

<p>最后，下面是使用 getter 方法实现具有&quot;魔幻&quot;行为的属性的示例：</p>

<pre><code class="language-javascript">// This object has accessor properties that return random numbers.
// The expression &quot;random.octet&quot;, for example, yields a random number
// between 0 and 255 each time it is evaluated.
const random = {
    get octet() { return Math.floor(Math.random()*256); },
    get uint16() { return Math.floor(Math.random()*65536); },
    get int16() { return Math.floor(Math.random()*65536)-32768; }
};
</code></pre>

<h2 id="toc_28">6.11 总结</h2>

<p>本章非常详细地记录了 JavaScript 对象，涵盖的主题包括：</p>

<ul>
<li>基本对象术语，包括可枚举和自有属性等术语的含义。</li>
<li>对象字面量语法，包括 ES6 及以后的许多新特性。</li>
<li>如何读取、写入、删除、枚举和检查对象属性是否存在。</li>
<li>基于原型的继承是如何在 JavaScript 中工作，以及如何使用 Object.create() 创建一个从另一个对象继承的对象。</li>
<li>如何使用 Object.assign() 将属性从一个对象复制到另一个对象。</li>
<li>所有 JavaScript 的非原始值都是对象。这包括数组和函数，这是接下来两章的主题。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 原型和原型链]]></title>
    <link href="blog.2019919.top/16080322533005.html"/>
    <updated>2020-12-15T19:37:33+08:00</updated>
    <id>blog.2019919.top/16080322533005.html</id>
    <content type="html"><![CDATA[
<p>今天刚开始学习【重学前端】的课程，讲到装箱转换的时候提到了函数的 call 方法，而 call 方法在我的印象中就只有 call 约等于 apply ，然后就再没有然后了。在我想深入了解下 call 方法的时候又发现了有人在同时讲解原型，而于此同时我看到了知乎上的一个贴<a href="https://www.zhihu.com/question/60165921">面试一个5年的前端，却连原型链也搞不清楚，满口都是Vue，React之类的实现，这样的人该用吗？</a>，这我不看内容我就惊呆了，这标题不就是在说我吗。带着各种心情赶紧学习下到底什么是原型和原型链。</p>

<h2 id="toc_0">原型</h2>

<pre><code class="language-text">prototype  [ˈproʊtətaɪp]  原型
</code></pre>

<p>OK完了😊！</p>

<p>下面这个图很多大神都有画过，下面记录下我自己的理解和实验。</p>

<p><img src="media/16080322533005/16080400429560.jpg" alt="" style="width:450px;"/></p>

<h3 id="toc_1">构造函数视角</h3>

<p>函数可以用来做构造器，也就是 constructor，而构造器也可以称为类。<br/>
通过构造器 Apple 来创建一个对象对象 apple。</p>

<p><img src="media/16080322533005/16080397593797.jpg" alt="" style="width:198px;"/></p>

<p><strong>构造函数创建了实例对象</strong>，这是构造函数与实例对象的关系。</p>

<hr/>

<p><strong>构造函数有一个属性叫做 propotype，他指向了原型对象。</strong></p>

<p><img src="media/16080322533005/16080405364424.jpg" alt="" style="width:299px;"/></p>

<p>这里的原型对象写做 [[propotype]]，这里我猜测是为了区分propotype的属性。</p>

<h3 id="toc_2">原型对象视角</h3>

<p><strong>原型对象的 constructor 属性指向了构造函数</strong>。</p>

<p><img src="media/16080322533005/16080407735350.jpg" alt="" style="width:382px;"/></p>

<p>这里用构造器的原型对象的 constructor 方法来创建一个 badApple ，会发现它和 apple 的类型是相等的。</p>

<h3 id="toc_3">实例对象视角</h3>

<p>对象也有一个属性 __propo__，这是一个隐式属性，<strong>对象的 __propo__ 指向了他的构造函数的原型对象。</strong>也就是说 Apple 的 propotype 属性和 apple、badApple 的 __propo__ 指向了同一个地址。</p>

<p><img src="media/16080322533005/16080419126552.jpg" alt="" style="width:318px;"/></p>

<h3 id="toc_4">由函数引出原型链</h3>

<p>函数是 JS 中的第一类对象，在 Javascript 中，对象所拥有的函数也同样拥有，也就是说构造函数 Apple 也同样会有 __propo__ 属性去指向他的父类的原型对象，为了理清这乱七八糟的关系，就有了下面“对象-函数-构造函数-实例对象”这样的一个关系图，也就是原型链图。</p>

<h2 id="toc_5">原型链</h2>

<p><img src="media/16080322533005/16080423510561.jpg" alt=""/></p>

<p>这张图理解了上面的内容之后就感觉容易多了，总结一下有以下几点需要注意。</p>

<ul>
<li>任何函数的父类都是 Function 构造函数，也就是任何函数的 __proto__ 指向 Function.prototype，这里同样包含了 Function 构造函数自己。</li>
<li>Object 构造函数它也是函数，它的的 __proto__ 也指向 Function.prototype。</li>
<li>Function.prototype 的 __proto__ 指向 Object.prototype，这也就是为什么说函数也是对象。</li>
<li>Object.prototype 的 __proto__ 是 null。</li>
</ul>

<h2 id="toc_6"> ES6 中的类</h2>

<p>类的写法也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性会被卸载原型对象之上。此外最重要的是类提供了继承能力。</p>

<pre><code class="language-javascript">class Animal { 
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(this.name + &#39; makes a noise.&#39;);
  }
}
class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }
  speak() {
    console.log(this.name + &#39; barks.&#39;);
  }
}
let d = new Dog(&#39;Mitzie&#39;);
d.speak(); // Mitzie barks.
</code></pre>

<p>以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p>

<blockquote>
<p>super 关键字用于访问和调用一个对象的父对象上的函数。<br/>
在构造函数中使用时，super关键字将单独出现，并且必须在使用this关键字之前使用。</p>
</blockquote>

<pre><code class="language-javascript">super([arguments]);
// 调用 父对象/父类 的构造函数
super.functionOnParent([arguments]);
// 调用 父对象/父类 上的方法
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 7 章 数组]]></title>
    <link href="blog.2019919.top/16124375850406.html"/>
    <updated>2021-02-04T19:19:45+08:00</updated>
    <id>blog.2019919.top/16124375850406.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">7.1 创建数组</a>
<ul>
<li>
<a href="#toc_1">7.1.1 数组字面量</a>
</li>
<li>
<a href="#toc_2">7.1.2 展开运算符</a>
</li>
<li>
<a href="#toc_3">7.1.3 Array() 构造函数</a>
</li>
<li>
<a href="#toc_4">7.1.4 Array.of()</a>
</li>
<li>
<a href="#toc_5">7.1.5 Array.from()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">7.2 数组元素的读和写</a>
</li>
<li>
<a href="#toc_7">7.3 稀疏数组（Sparse Arrays）</a>
</li>
<li>
<a href="#toc_8">7.4 数组长度</a>
</li>
<li>
<a href="#toc_9">7.5 数组元素添加和删除</a>
</li>
<li>
<a href="#toc_10">7.6 数组遍历</a>
</li>
<li>
<a href="#toc_11">7.7 多维数组</a>
</li>
<li>
<a href="#toc_12">7.8 数组方法</a>
<ul>
<li>
<a href="#toc_13">7.8.1 数组迭代器方法</a>
<ul>
<li>
<a href="#toc_14">FOREACH()</a>
</li>
<li>
<a href="#toc_15">MAP()</a>
</li>
<li>
<a href="#toc_16">FILTER()</a>
</li>
<li>
<a href="#toc_17">FIND() 和 FINDINDEX()</a>
</li>
<li>
<a href="#toc_18">EVERY() 和 SOME()</a>
</li>
<li>
<a href="#toc_19">REDUCE() 和 REDUCERIGHT()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_20">7.8.2 用 flat() 和 flatMap() 展平数组</a>
</li>
<li>
<a href="#toc_21">7.8.3 用 concat() 添加数组</a>
</li>
<li>
<a href="#toc_22">7.8.4  push()、pop()、shift() 和 unshift() 与堆栈和队列</a>
</li>
<li>
<a href="#toc_23">7.8.5 slice()、splice()、fill() 和 copyWithin() 与子数组</a>
<ul>
<li>
<a href="#toc_24">SLICE()</a>
</li>
<li>
<a href="#toc_25">SPLICE()</a>
</li>
<li>
<a href="#toc_26">FILL()</a>
</li>
<li>
<a href="#toc_27">COPYWITHIN()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_28">7.8.6 数组的查询和排序方法</a>
<ul>
<li>
<a href="#toc_29">INDEXOF() 和 LASTINDEXOF()</a>
</li>
<li>
<a href="#toc_30">INCLUDES()</a>
</li>
<li>
<a href="#toc_31">SORT()</a>
</li>
<li>
<a href="#toc_32">REVERSE()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_33">7.8.7 数组转化字符串</a>
</li>
<li>
<a href="#toc_34">7.8.8 Array 的静态方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_35">7.9 类数组对象</a>
</li>
<li>
<a href="#toc_36">7.10 作为数组的字符串</a>
</li>
<li>
<a href="#toc_37">7.11 总结</a>
</li>
</ul>


<p>本章记录了数组、一个在 JavaScript 和大多数其他编程语言中的基本数据类型。数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript 数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。JavaScript 数组的索引是基于零的 32 位数值：第一个元素的索引为 0，最大可能的索引为 4,294,967,294（2<sup>32</sup>-2），数组最大能容纳 4,294,967,295 个元素。JavaScript 数组是动态的：根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。JavaScript 数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 大于任何元素的最高索引。</p>

<p>JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。我们将在本章的其他地方更多地讨论特殊化的数组。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。</p>

<p>数组继承自 Array.prototype 中的属性，它定义了一套丰富的数组操作方法，§7.8 涵盖这方面内容。大多数这些方法是通用的，这意味着它们不仅对真正的数组有效，而且对“类数组对象”同样有效。§7.9 讨论类数组对象。最后，JavaScript 字符串的行为与字符数组类似，我们将在 §7.10 讨论。</p>

<p>ES6 引入了一组新的数组类，这些类统称为“类型化数组”。与常规的 JavaScript 数组不同，类型化数组有固定的长度和固定的数值元素类型。它们提供高性能和对二进制数据的字节级访问，在 §11.2 中有介绍。</p>

<h2 id="toc_0">7.1 创建数组</h2>

<p>有很多种创建数组的方法。以下小节将说明如何使用以下方式创建数组：</p>

<ul>
<li>数组字面量</li>
<li>可迭代数组 ... 展开运算符</li>
<li>Array() 构造函数</li>
<li>Array.of() 和 Array.from() 工厂方法</li>
</ul>

<h3 id="toc_1">7.1.1 数组字面量</h3>

<p>到目前为止使用数组字面量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。例如：</p>

<pre><code class="language-javascript">let empty = [];                 // An array with no elements
let primes = [2, 3, 5, 7, 11];  // An array with 5 numeric elements
let misc = [ 1.1, true, &quot;a&quot;, ]; // 3 elements of various types + trailing comma
</code></pre>

<p>数组字面量中的值不一定要是常量；它们可以是任意的表达式：</p>

<pre><code class="language-javascript">let base = 1024;
let table = [base, base+1, base+2, base+3];
</code></pre>

<p>数组字面量可以包含对象字面量或其他数组字面量：</p>

<pre><code class="language-javascript">let b = [[1, {x: 1, y: 2}], [2, {x: 3, y: 4}]];
</code></pre>

<p>如果数组字面量在一行中包含多个逗号，之间没有值，则数组是稀疏的（请参阅 §7.3）。省略值的数组元素不存在，但如果查询它们则返回 undefined：</p>

<pre><code class="language-javascript">let count = [1,,3]; // Elements at indexes 0 and 2. No element at index 1
let undefs = [,,];  // An array with no elements but a length of 2
</code></pre>

<p>数组字面量语法允许可选的尾部逗号，所以 [,,] 的长度是 2，不是3。</p>

<h3 id="toc_2">7.1.2 展开运算符</h3>

<p>ES6 之后，可以使用展开操作符 ... 将一个数组中的元素展开在数组字面量中：</p>

<pre><code class="language-javascript">let a = [1, 2, 3];
let b = [0, ...a, 4];  // b == [0, 1, 2, 3, 4]
</code></pre>

<p>三个点展开数组 a，所以它的元素变成了数组字面量，并被创建在数组中。就像 ...a 被数组 a 的元素所替换，被列出作为未闭合的数组字面量的一部分。（注意，尽管我们称三点是展开运算符，但这并不是一个操作，因为它只能用于数组字面量和本书后面提到的函数调用。）</p>

<p>展开运算符可以方便的创建一个数组的拷贝（浅拷贝）：</p>

<pre><code class="language-javascript">let original = [1,2,3];
let copy = [...original];
copy[0] = 0;  // Modifying the copy does not change the original
original[0]   // =&gt; 1
</code></pre>

<p>展开运算符可以作用于任何可迭代对象。（可迭代对象是可以用 for/of 进行循环的对象；第一次在 §5.4.4 中提到，在第 12 章会看到更多关于它们的描述。）字符串是可迭代对象，所以可以使用展开操作符将字符串转换成单个字符的数组。</p>

<pre><code class="language-javascript">let digits = [...&quot;0123456789ABCDEF&quot;];
digits // =&gt; [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]
</code></pre>

<p>Set 对象（§11.1.1）是可迭代对象，所以数组去重有一种简单的方法是用展开运算符将数组转换成 set 然后再转成数组：</p>

<pre><code class="language-javascript">let letters = [...&quot;hello world&quot;];
[...new Set(letters)]  // =&gt; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;o&quot;,&quot; &quot;,&quot;w&quot;,&quot;r&quot;,&quot;d&quot;]
</code></pre>

<h3 id="toc_3">7.1.3 Array() 构造函数</h3>

<p>另一种创建数组的方法是使用 Array() 构造函数。可以用三种不同的方式调用这个构造函数：</p>

<p>调用时没有实参：</p>

<pre><code class="language-javascript">let a = new Array();
</code></pre>

<p>这个方法创建了一个没有元素的空数组，它等价于 [] 数组字面量。</p>

<p>调用时有一个数值实参，它指定了数组的长度：</p>

<pre><code class="language-javascript">let a = new Array(10);
</code></pre>

<p>该技术创建指定长度的数组。当预先知道所需元素个数时，这种形式的 Array() 构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性“0”、“1”等还未定义。</p>

<p>为数组显式指定两个或多个数组元素或者非数值元素：</p>

<pre><code class="language-javascript">let a = new Array(5, 4, 3, 2, 1, &quot;testing, testing&quot;);
</code></pre>

<p>以这种形式，构造函数的实参将会成为新数组的元素。使用数组字面量比这样使用 Array() 构造函数要简单多了。</p>

<h3 id="toc_4">7.1.4 Array.of()</h3>

<p>当 Array() 构造函数调用时有一个数值型实参，它会将实参作为数组的长度。但当调用时不止一个数值型实参时，它会将那些实参作为数组的元素创建。这意味着 Array() 构造函数不能创建只有一个数值型元素的数组。</p>

<p>在 ES6 中，Array.of() 函数修复了这个问题：它是一个将其实参值（无论有多少个实参）作为数组元素创建并返回一个新数组的工厂方法：</p>

<pre><code class="language-javascript">Array.of()        // =&gt; []; returns empty array with no arguments
Array.of(10)      // =&gt; [10]; can create arrays with a single numeric argument
Array.of(1,2,3)   // =&gt; [1, 2, 3]
</code></pre>

<h3 id="toc_5">7.1.5 Array.from()</h3>

<p>Array.from 是 ES6 中另外一个数组工厂方法。它期望一个可迭代或类数组对象作为它的第一个实参，并返回一个包含对象中元素的新数组。使用一个可迭代实参，Array.from(iterable) 工作方式类似于展开运算符 [...iterable]。它也可以简单的拷贝一个数组：</p>

<pre><code class="language-javascript">let copy = Array.from(original);
</code></pre>

<p>Array.from() 也很重要，因为它定义了一个将类数组对象拷贝成数组的方法。类数组对象是一个不是数组的对象，它有一个数值型的 length 属性，并且它的值碰巧保存在属性名为整数的属性中。当使用客户端 JavaScript 时，一些浏览器方法的返回值是类数组的，并且当将其转化成真正的数组后会更容易操作它们：</p>

<pre><code class="language-javascript">let truearray = Array.from(arraylike);
</code></pre>

<p>Array.from() 第二个实参为可选实参。如果传递一个函数作为第二个实参，那么当新数组被创建，每一个元素都会被作为实参传入这个指定函数中，并且这个函数的每个返回值保存在数组中代替原来的值。（这很像后面会介绍的数组 map() 方法，但是，它会更加高效的执行映射，因其为没有创建数组，而是直接进行映射到另外一个数组。）</p>

<h2 id="toc_6">7.2 数组元素的读和写</h2>

<p>使用 [] 运算符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的 JavaScript 语句：</p>

<pre><code class="language-javascript">let a = [&quot;world&quot;];     // Start with a one-element array
let value = a[0];      // Read element 0
a[1] = 3.14;           // Write element 1
let i = 2;
a[i] = 3;              // Write element 2
a[i + 1] = &quot;hello&quot;;    // Write element 3
a[a[i]] = a[0];        // Read elements 0 and 2, write element 3
</code></pre>

<p>数组特殊的是，当使用小于 2<sup>32</sup>–1 的非负整数属性名时，数组会自动维护 length 属性。例如，上文中我们创建了只有一个元素的数组 a。然后我们为其序列为 1、2 和 3 的元素进行赋值。数组 length 属性会自动改变：</p>

<pre><code class="language-javascript">a.length       // =&gt; 4
</code></pre>

<p>请记住，数组是对象的特殊形式。使用方括号访问数组元素就像用方括号访问对象的属性一样。JavaScript 将指定的数字索引值转换成字符串（索引值 1 变成“1”）然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做：</p>

<pre><code class="language-javascript">let o = {};    // Create a plain object
o[1] = &quot;one&quot;;  // Index it with an integer
o[&quot;1&quot;]         // =&gt; &quot;one&quot;; numeric and string property names are the same
</code></pre>

<p>清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有在 0～2<sup>32</sup>-2 之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的 length 属性值。</p>

<p>注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的：</p>

<pre><code class="language-javascript">a[-1.23] = true;  // This creates a property named &quot;-1.23&quot;
a[&quot;1000&quot;] = 0;    // This the 1001st element of the array
a[1.000] = 1;     // Array index 1. Same as a[1] = 1;
</code></pre>

<p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有“越界”错误的概念。当试图查询任何对象中不存在的属性时，都不会报错，只会得到 undefined 值。类似于对象，对于对象同样存在这种情况。</p>

<pre><code class="language-javascript">let a = [true, false]; // This array has elements at indexes 0 and 1
a[2]                   // =&gt; undefined; no element at this index.
a[-1]                  // =&gt; undefined; no property with this name.
</code></pre>

<h2 id="toc_7">7.3 稀疏数组（Sparse Arrays）</h2>

<p>稀疏数组就是包含从 0 开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array() 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。</p>

<pre><code class="language-javascript">let a = new Array(5); // No elements, but a.length is 5.
a = [];               // Create an array with no elements and length = 0.
a[1000] = 0;          // Assignment adds one element but sets length to 1001.
</code></pre>

<p>后面会看到你也可以用 delete 运算符来生产稀疏数组。</p>

<p>足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。</p>

<p>注意，当在数组字面量中省略值时（像 [1,,3] 中使用重复的逗号）返回的是稀疏数组，省略掉的值是不存在的：</p>

<pre><code class="language-javascript">let a1 = [,];           // This array has no elements and length 1
let a2 = [undefined];   // This array has one undefined element
0 in a1                 // =&gt; false: a1 has no element with index 0
0 in a2                 // =&gt; true: a2 has the undefined value at index 0
</code></pre>

<p>了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 undefined 元素。</p>

<h2 id="toc_8">7.4 数组长度</h2>

<p>每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，length 属性值代表数组中元素的个数。其值比数组中最大的索引大 1：</p>

<pre><code class="language-javascript">[].length             // =&gt; 0: the array has no elements
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].length  // =&gt; 3: highest index is 2, length is 3
</code></pre>

<p>当数组是稀疏的时，length 属性值大于元素的个数。而且关于此我们可以说数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。</p>

<p>第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于 n 的元素将从中删除：</p>

<pre><code class="language-javascript">a = [1,2,3,4,5];     // Start with a 5-element array.
a.length = 3;        // a is now [1,2,3].
a.length = 0;        // Delete all elements.  a is [].
a.length = 5;        // Length is 5, but no elements, like new Array(5)
</code></pre>

<p>还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个稀疏区域。</p>

<h2 id="toc_9">7.5 数组元素添加和删除</h2>

<p>我们已经见过添加数组元素最简单的方法：为新索引赋值：</p>

<pre><code class="language-javascript">let a = [];      // Start with an empty array.
a[0] = &quot;zero&quot;;   // And add elements to it.
a[1] = &quot;one&quot;;
</code></pre>

<p>也可以使用push()方法在数组末尾增加一个或多个元素：</p>

<pre><code class="language-javascript">let a = [];           // Start with an empty array
a.push(&quot;zero&quot;);       // Add a value at the end.  a = [&quot;zero&quot;]
a.push(&quot;one&quot;, &quot;two&quot;); // Add two more values.  a = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]
</code></pre>

<p>在数组尾部压入一个元素与给 a[a.length] 赋值是一样的。可以使用 unshift() 方法（§7.8 有描述）在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。pop() 方法与 push() 相反：它移除数组最后一个元素并返回这个元素，使数组 length 减 1。同样，shift() 方法移除并返回数组的第一个元素，使数组 length 减 1，并将其他元素依次移到低 1 的索引处。§7.8 有更多关于这些方法的描述。</p>

<p>可以像删除对象属性一样使用 delete 运算符来删除数组元素：</p>

<pre><code class="language-javascript">let a = [1,2,3];
delete a[2];   // a now has no element at index 2
2 in a         // =&gt; false: no array index 2 is defined
a.length       // =&gt; 3: delete does not affect array length
</code></pre>

<p>删除数组元素与为其赋 undefined 值是类似的（但有一些微妙的区别）。注意，对一个数组元素使用 delete 不会修改数组的 length 属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。</p>

<p>正如上面所看到的，也可以通过设置新的所需长度，即可从数组尾部删除元素。</p>

<p>最后，splice() 是一个通用的方法来插入、删除或替换数组元素。它会根据需要修改 length 属性并移动元素到更高或较低的索引处。详细内容见 §7.8。</p>

<h2 id="toc_10">7.6 数组遍历</h2>

<p>在 ES6 中，最容易遍历数组元素（或可迭代对象）的方法是 for/of 循环，在 §5.4.4 中详细介绍：</p>

<pre><code class="language-javascript">let letters = [...&quot;Hello world&quot;];  // An array of letters
let string = &quot;&quot;;
for(let letter of letters) {
    string += letter;
}
string  // =&gt; &quot;Hello world&quot;; we reassembled the original text
</code></pre>

<p>内置数组迭代器 for/of 循环按照升序返回数组元素。对于稀疏数组它没有特殊的行为，数组中不存在的元素只是单纯的返回 undefined。</p>

<p>如果使用 for/of 循环一个数组时还需要知道每个元素的索引，可以像这样将数组的 entries() 方法和解构语句一同使用：</p>

<pre><code class="language-javascript">let everyother = &quot;&quot;;
for(let [index, letter] of letters.entries()) {
    if (index % 2 === 0) everyother += letter;  // letters at even indexes
}
everyother  // =&gt; &quot;Hlowrd&quot;
</code></pre>

<p>另一种不错的遍历数组方法是用 forEach()。这不是 for 循环的新形式，而是提供数组遍历功能方法的数组方法。可以给数组的 forEach() 方法传递一个函数，forEach() 会对数组中每一个元素调用这个方法：</p>

<pre><code class="language-javascript">let uppercase = &quot;&quot;;
letters.forEach(letter =&gt; {  // Note arrow function syntax here
    uppercase += letter.toUpperCase();
});
uppercase  // =&gt; &quot;HELLO WORLD&quot;
</code></pre>

<p>正如期望的，forEach() 按顺序对数组进行计算，实际上它将数组索引作为第二个实参传递到函数，这有时很有用。与 for/of 循环不同，forEach() 能意识到稀疏数组，并且不会为不存在的元素调用函数。</p>

<p>§7.8.1 更详细地记录了 forEach() 方法。该部分还介绍演示了特定类型的数组遍历方法，如 map() 和 filter()。</p>

<p>也可以用一种非常老旧方式遍历数组的元素（§5.4.3）：</p>

<pre><code class="language-javascript">let vowels = &quot;&quot;;
for(let i = 0; i &lt; letters.length; i++) { // For each index in the array
    let letter = letters[i];              // Get the element at that index
    if (/[aeiou]/.test(letter)) {         // Use a regular expression test
        vowels += letter;                 // If it is a vowel, remember it
    }
}
vowels  // =&gt; &quot;eoo&quot;
</code></pre>

<p>在嵌套循环或其他性能至关重要的上下文中，有时可能会看到这样的数组遍历，以便数组长度仅被查一次，而不是在每次循环都去查询。以下两种形式都是符合习惯的 for 循环，虽然不是特别常用，而且对于现代 JavaScript 解释器，它们是否对性能有任何影响尚不清楚：</p>

<pre><code class="language-javascript">// Save the array length into a local variable
for(let i = 0, len = letters.length; i &lt; len; i++) {
    // loop body remains the same
}

// Iterate backwards from the end of the array to the start
for(let i = letters.length-1; i &gt;= 0; i--) {
    // loop body remains the same
}
</code></pre>

<p>这些示例假定数组是稠密的，并且所有元素都包含有效的数据。如果不是这样，应该在使用数组元素之前测试它们。如果要跳过 undefined 和不存在的元素，可以编写：</p>

<pre><code class="language-javascript">for(let i = 0; i &lt; a.length; i++) {
    if (a[i] === undefined) continue; // Skip undefined + nonexistent elements
    // loop body here
}
</code></pre>

<h2 id="toc_11">7.7 多维数组</h2>

<p>JavaScript 不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次 [] 操作符即可。例如，假设变量 matrix 是一个数组的数组，它的基本元素是数值，那么 matrix[x] 的每个元素是包含一个数值数组，访问数组中特定数值的代码为 matrix[x][y]。这里有一个具体的例子，它使用二维数组作为一个九九乘法表：</p>

<pre><code class="language-javascript">// Create a multidimensional array
let table = new Array(10);               // 10 rows of the table
for(let i = 0; i &lt; table.length; i++) {
    table[i] = new Array(10);            // Each row has 10 columns
}

// Initialize the array
for(let row = 0; row &lt; table.length; row++) {
    for(let col = 0; col &lt; table[row].length; col++) {
        table[row][col] = row*col;
    }
}

// Use the multidimensional array to compute 5*7
table[5][7]  // =&gt; 35
</code></pre>

<h2 id="toc_12">7.8 数组方法</h2>

<p>前面几节重点介绍了用于处理数组的基本 JavaScript 语法。但通常，由 Array 类定义的方法是最强大的。下一节将记录这些方法。在阅读有关这些方法时，请记住，其中一些方法修改了调用的数组，而其中一些方法使数组保持不变。许多方法返回数组：有时，这是一个新数组，原始数组保持不变。其他时候，方法将修改数组，并且返回对修改后数组的引用。</p>

<p>以下每个小节都涵盖一组相关的数组方法：</p>

<p>迭代器方法循环遍历数组的元素，通常调用在每个元素上指定的函数。</p>

<p>堆栈和队列方法在数组的开头和结尾添加和删除数组元素。</p>

<p>子数组方法用于提取、删除、插入、填充和复制一个更大数组中相邻的区域。</p>

<p>搜索和排序方法用于查找数组中的元素和排序数组的元素。</p>

<p>以下小节还介绍 Array 类的静态方法和一些用于连接数组和将数组转换为字符串的各种方法。</p>

<h3 id="toc_13">7.8.1 数组迭代器方法</h3>

<p>本节中介绍的方法通过将数组元素按顺序传递到所指定的函数来遍历数组，它们提供了迭代、映射、筛选、测试和减少数组的便捷方法。</p>

<p>然而，在详细解释这些方法之前，值得对它们进行一些概括。首先，所有这些方法都接受函数作为其第一个实参，并使用调用数组的每个元素（或某些元素）作为实参调用该函数。如果数组是稀疏的，则不会为不存在的元素调用传递的函数。在大多数情况下，提供的函数被调用时有三个实参：数组元素的值、数组元素的索引和数组本身。通常，只需要这些实参值中的第一个，并且可以忽略第二个和第三个值。</p>

<p>以下小节中描述的大多数迭代器方法都接受可选的第二个实参。如果指定，则调用函数就像它是第二个实参的方法一样。也就是说，传递的第二个实参将成为第一个函数实参内部的 this 值。传递的函数的返回值通常很重要，但不同的方法以不同的方式处理返回值。此处描述的方法都没有修改调用它们的数组（当然，传递的函数可以修改这个数组）。</p>

<p>这节的每个函数都调用它的第一个函数实参，并且通常将该函数内联定义为方法调用表达式的一部分，而不是使用在其他地方显示定义的函数。箭头函数语法（参见 §8.1.3）在这些方法中特别有效，我们将在下面的示例中使用它。</p>

<h4 id="toc_14">FOREACH()</h4>

<p>forEach() 方法遍历数组，调用为每个元素指定的函数。正如我们已经描述的那样，将函数作为第一个实参传递给 forEach()。forEach() 然后使用三个实参调用函数：数组元素的值、数组元素的索引和数组本身。如果只关心数组元素的值，则编写一个只有一个实参的函数（将忽略其他实参）：</p>

<pre><code class="language-javascript">let data = [1,2,3,4,5], sum = 0;
// Compute the sum of the elements of the array
data.forEach(value =&gt; { sum += value; });          // sum == 15

// Now increment each array element
data.forEach(function(v, i, a) { a[i] = v + 1; }); // data == [2,3,4,5,6]
</code></pre>

<p>请注意，forEach() 不提供在所有元素传递给函数之前终止迭代的方法。也就是说，没有等效于常规 for 循环的 break 语句可以使用。</p>

<h4 id="toc_15">MAP()</h4>

<p>map() 方法将调用数组的每个元素传递到指定的函数，并返回一个包含函数返回的值的数组。例如：</p>

<pre><code class="language-javascript">let a = [1, 2, 3];
a.map(x =&gt; x*x)   // =&gt; [1, 4, 9]: the function takes input x and returns x*x
</code></pre>

<p>传递到 map() 的函数的调用方式与传递给 forEach() 的函数相同。但是，对于 map() 方法，传递的函数应返回一个值。请注意，map() 返回一个新数组：它不会修改调用它的数组。如果该数组是稀疏的，则不会为缺失的元素调用函数，但返回的数组将稀疏，其确实元素与原始数组的位置相同：它将具有相同的长度和相同的缺失元素。</p>

<h4 id="toc_16">FILTER()</h4>

<p>filter() 方法返回一个数组，其中包含调用该数组的数组元素的子集。传递给它的函数应该是断言：返回真或假的函数。断言函数的调用就像 forEach() 和 map() 调用一样。如果返回值为 true，或者能转换为 true 的值，则传递给断言的元素是子集的成员，并将添加到将成为返回值的数组中。例子：</p>

<pre><code class="language-javascript">let a = [5, 4, 3, 2, 1];
a.filter(x =&gt; x &lt; 3)         // =&gt; [2, 1]; values less than 3
a.filter((x,i) =&gt; i%2 === 0) // =&gt; [5, 3, 1]; every other value
</code></pre>

<p>注意 filter() 跳过稀疏数组中的丢失元素并且返回值也总是稠密的。要缩小稀疏数组的间距，可以这样做：</p>

<pre><code class="language-javascript">let dense = sparse.filter(() =&gt; true);
</code></pre>

<p>要缩小间隙并移除 undefined 和 null 元素，可以用 filter 这样做：</p>

<pre><code class="language-javascript">a = a.filter(x =&gt; x !== undefined &amp;&amp; x !== null);
</code></pre>

<h4 id="toc_17">FIND() 和 FINDINDEX()</h4>

<p>find() 和 findIndex() 方法就像 filter()，因为它们在数组中迭代，查找断言函数返回真实值的元素。但是，与 filter()不同，这两种方法在断言首次查找元素到时停止遍历。发生这种情况时，find() 返回匹配元素，而 findIndex() 返回匹配元素的索引。如果未找到匹配元素，find() 返回 undefined，findIndex() 返回 -1：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.findIndex(x =&gt; x === 3)  // =&gt; 2; the value 3 appears at index 2
a.findIndex(x =&gt; x &lt; 0)    // =&gt; -1; no negative numbers in the array
a.find(x =&gt; x % 5 === 0)   // =&gt; 5: this is a multiple of 5
a.find(x =&gt; x % 7 === 0)   // =&gt; undefined: no multiples of 7 in the array
</code></pre>

<h4 id="toc_18">EVERY() 和 SOME()</h4>

<p>every() 和 some() 方法是数组断言：它们将指定的断言函数应用于数组的元素，然后返回 true 或 false。</p>

<p>every() 方法与数学全称量化符号 ∀ 相似：如果数组中所有元素执行断言函数返回值都为 true，则返回 true：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.every(x =&gt; x &lt; 10)      // =&gt; true: all values are &lt; 10.
a.every(x =&gt; x % 2 === 0) // =&gt; false: not all values are even.
</code></pre>

<p>some() 方法与数学存在限定符 ∃ 相同：如果数组中存在至少有一个元素调用断言函数返回 true 的返回 true，仅在断言全部返回 false 时返回 false：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.some(x =&gt; x%2===0)  // =&gt; true; a has some even numbers.
a.some(isNaN)         // =&gt; false; a has no non-numbers.
</code></pre>

<p>请注意，every() 和 some() 只要它们知道要返回的值，都停止对数组元素的遍历。some() 在断言函数第一次返回 true 时返回 true，并且只有在每个元素调用断言函数都返回 false 时，才会遍历整个数组 。every() 正好相反：它返回 false 时，您的谓词返回 false，并且仅在谓词始终返回 true 时，才会回注所有元素。另请注意，根据数学约定，every() 返回 true，有些返回 false，当在空数组上调用时，某些返回 false。</p>

<h4 id="toc_19">REDUCE() 和 REDUCERIGHT()</h4>

<p>reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。举例说明它是如何工作的：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.reduce((x,y) =&gt; x+y, 0)          // =&gt; 15; the sum of the values
a.reduce((x,y) =&gt; x*y, 1)          // =&gt; 120; the product of the values
a.reduce((x,y) =&gt; (x &gt; y) ? x : y) // =&gt; 5; the largest of the values
</code></pre>

<p>reduce() 需要两个实参。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的实参是一个传递给函数的初始值。</p>

<p>reduce() 使用的函数与 forEach() 和 map() 使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第 2～4 个实参传递给函数。第一个实参是到目前为止的化简操作累积的结果。第一次调用函数时，第一个实参是一个初始值，它就是传递给 reduce() 的第二个实参。在接下来的调用中，这个值就是上一次化简函数的返回值。在上面的第一个例子中，第一次调用化简函数时的实参是 0 和 1。将两者相加并返回 1。再次调用时的实参是 1 和 2，它返回 3。然后它计算 3+3=6、6+4=10， 最后计算 10+5=15。最后的值是 15，reduce() 返回这个值。</p>

<p>可能已经注意到了，上面第三次调用 reduce() 时只有一个实参：没有指定初始值。当不指定初始值调用 reduce() 时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个实参。在上面求和与求积的例子中，可以省略初始值实参。</p>

<p>在空数组上，不带初始值实参调用 reduce() 将导致类型错误异常。如果调用它的时候只有一个值（数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值）reduce() 只是简单地返回那个值而不会调用化简函数。</p>

<p>reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低（从右到左）处理数组，而不是从低到高。如果 reduction 操作的优先顺序是从右到左，你可能想使用它，例如：</p>

<pre><code class="language-javascript">// Compute 2^(3^4).  Exponentiation has right-to-left precedence
let a = [2, 3, 4];
a.reduceRight((acc,val) =&gt; Math.pow(val,acc)) // =&gt; 2.4178516392292583e+24
</code></pre>

<p>注意，reduce() 和 reduceRight() 都能接收一个可选的实参，它指定了化简函数调用时的 this 关键字的值。可选的初始值实参仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，请参看 Function.bind() 方法（§8.7.5）。</p>

<p>为了简单起见，到目前位置所展示的例子都是数值的，但数学计算不是 reduce() 和 reduceRight() 的唯一意图。任何想要将两个相同类型的值（例如两个对象）合并到一个值的函数都可以用化简函数。另一方面，使用数组化简的算法可能很快变得复杂且难以理解，可能会发现，如果使用常规循环构造来处理数组则更容易读、写和推理。</p>

<h3 id="toc_20">7.8.2 用 flat() 和 flatMap() 展平数组</h3>

<p>在 ES2019 中，flat() 方法创建并返回一个新的数组，该数组包含与调用的数组相同的元素，只不过作为数组的任何元素都&quot;展平&quot;到返回的数组中。例如：</p>

<pre><code class="language-javascript">[1, [2, 3]].flat()    // =&gt; [1, 2, 3]
[1, [2, [3]]].flat()  // =&gt; [1, 2, [3]]
</code></pre>

<p>当调用时没有实参，flat() 将平展一个级别的嵌套。作为数组的原始数组的元素被展平，但这些数组的数组元素不会展平。如果要展平更多级别，需要传递数字给 flat()：</p>

<pre><code class="language-javascript">let a = [1, [2, [3, [4]]]];
a.flat(1)   // =&gt; [1, 2, [3, [4]]]
a.flat(2)   // =&gt; [1, 2, 3, [4]]
a.flat(3)   // =&gt; [1, 2, 3, 4]
a.flat(4)   // =&gt; [1, 2, 3, 4]
</code></pre>

<p>flatMap() 方法的工作方式与 map() 方法（见“map()”）类似，只不过返回的数组会自动展平，就像传递到 flat()。也就是说，调用 a.flatMap(f) 与 a.map(f).flat()（但更高效）相同：</p>

<pre><code class="language-javascript">let phrases = [&quot;hello world&quot;, &quot;the definitive guide&quot;];
let words = phrases.flatMap(phrase =&gt; phrase.split(&quot; &quot;));
words // =&gt; [&quot;hello&quot;, &quot;world&quot;, &quot;the&quot;, &quot;definitive&quot;, &quot;guide&quot;];
</code></pre>

<p>可以将 flatMap() 视为 map() 的泛化，它允许输入数组的每个元素映射到输出数组的多个元素。特别的是，flatMap() 允许将输入元素映射到空数组，该数组在平展后不输出到数组中：</p>

<pre><code class="language-javascript">// Map non-negative numbers to their square roots
[-2, -1, 1, 2].flatMap(x =&gt; x &lt; 0 ? [] : Math.sqrt(x)) // =&gt; [1, 2**0.5]
</code></pre>

<h3 id="toc_21">7.8.3 用 concat() 添加数组</h3>

<p>concat() 方法创建并返回一个新数组，它的元素包括调用 concat() 的原始数组的元素和 concat() 的每个实参。如果这些实参中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat() 不会递归扁平化数组的数组。concat() 也不会修改调用的数组：</p>

<pre><code class="language-javascript">let a = [1,2,3];
a.concat(4, 5)          // =&gt; [1,2,3,4,5]
a.concat([4,5],[6,7])   // =&gt; [1,2,3,4,5,6,7]; arrays are flattened
a.concat(4, [5,[6,7]])  // =&gt; [1,2,3,4,5,[6,7]]; but not nested arrays
a                       // =&gt; [1,2,3]; the original array is unmodified
</code></pre>

<p>请注意，concat() 创建调用数组的新副本。在许多情况下，这是正确的做法，但它是一个昂贵的操作。如果您发现自己编写代码像 <code>a = a.concat(x)</code>，那么您应该考虑使用 push() 或 splice() 修改数组，而不是创建新的数组。</p>

<h3 id="toc_22">7.8.4  push()、pop()、shift() 和 unshift() 与堆栈和队列</h3>

<p>push() 和 pop() 方法允许将数组当做栈来使用。push() 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop() 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。注意，两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用 push() 和 pop() 能够用 JavaScript 数组实现先进后出的栈。例如：</p>

<pre><code class="language-javascript">let stack = [];       // stack == []
stack.push(1,2);      // stack == [1,2];
stack.pop();          // stack == [1]; returns 2
stack.push(3);        // stack == [1,3]
stack.pop();          // stack == [1]; returns 3
stack.push([4,5]);    // stack == [1,[4,5]]
stack.pop()           // stack == [1]; returns [4,5]
stack.pop();          // stack == []; returns 1
</code></pre>

<p>push() 方法不展平传入的数组，但如果想要将数组的元素全部压入另外一个数组，可以使用展开运算符（§8.3.4）来显示展开：</p>

<pre><code class="language-javascript">a.push(...values);
</code></pre>

<p>unshift() 和 shift() 方法的行为非常类似于 push() 和 pop()，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。unshift() 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。shift() 删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。可以使用 unshift() 和 shift() 实现栈，但它比使用 push() 和 pop() 的效率低，因为每次在数组头部添加或删除元素时，都需要向上或向下移动数组元素。但是，您可以使用 push() 在数组末尾添加元素并 shift() 从数组的头部删除它们来实现队列数据解构：</p>

<pre><code class="language-javascript">let q = [];            // q == []
q.push(1,2);           // q == [1,2]
q.shift();             // q == [2]; returns 1
q.push(3)              // q == [2, 3]
q.shift()              // q == [3]; returns 2
q.shift()              // q == []; returns 3
</code></pre>

<p>unshift() 有一个特性是值得一提的，你可能会觉得它令人惊讶。将多个实参传入 unshift() 时，它们将一次全部插入，这意味着它们最终在数组中的顺序与一次插入一个实参的顺序时不同的：</p>

<pre><code class="language-javascript">let a = [];            // a == []
a.unshift(1)           // a == [1]
a.unshift(2)           // a == [2, 1]
a = [];                // a == []
a.unshift(1,2)         // a == [1, 2]
</code></pre>

<h3 id="toc_23">7.8.5 slice()、splice()、fill() 和 copyWithin() 与子数组</h3>

<p>数组定义了许多在连续区域，子数组或数组的“片段”上工作的方法。 以下各节描述了提取，替换，填充和复制片段的方法。</p>

<h4 id="toc_24">SLICE()</h4>

<p>slice() 方法返回指定数组的一个片段或子数组。它的两个实参分别指定了片段的开始和结束的位置。返回的数组包含第一个实参指定的位置到（但不包含）第二个实参指定的位置之间的所有数组元素。如果只指定一个实参，返回的数组将包含从开始位置到数组结尾的所有元素。如实参中出现负数，它表示相对于数组 length 的位置。例如，实参 -1 指定了最后一个元素，而 -2 指定了它前面的元素。注意，slice() 不会修改调用的数组。下面有一些示例：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.slice(0,3);    // Returns [1,2,3]
a.slice(3);      // Returns [4,5]
a.slice(1,-1);   // Returns [2,3,4]
a.slice(-3,-2);  // Returns [3]
</code></pre>

<h4 id="toc_25">SPLICE()</h4>

<p>splice() 方法是在数组中插入或删除元素的通用方法。不同于 slice() 和 concat()，splice() 会修改调用的数组。注意，splice() 和 slice() 拥有非常相似的名字， 但它们的功能却有本质的区别。</p>

<p>splice() 能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。splice() 的第一个实参指定了插入和（或）删除的起始位置。第二个实参指定了应该从数组中删除的元素的个数。（注意这里是这两个方法的另外一个不同。slice() 的第二个实参是结束的位置。splice() 的第二个实参是长度。）如果省略第二个实参，从起始点开始到数组结尾的所有元素都将被删除。splice() 返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5,6,7,8];
a.splice(4)    // =&gt; [5,6,7,8]; a is now [1,2,3,4]
a.splice(1,2)  // =&gt; [2,3]; a is now [1,4]
a.splice(1,1)  // =&gt; [4]; a is now [1]
</code></pre>

<p>splice() 的前两个实参指定了需要删除的数组元素。紧随其后的任意个数的实参指定了需要插入到数组中的元素，从第一个实参指定的位置开始插入。例如：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.splice(2,0,&quot;a&quot;,&quot;b&quot;)  // =&gt; []; a is now [1,2,&quot;a&quot;,&quot;b&quot;,3,4,5]
a.splice(2,2,[1,2],3)  // =&gt; [&quot;a&quot;,&quot;b&quot;]; a is now [1,2,[1,2],3,3,4,5]
</code></pre>

<p>注意，不同于 concat()，splice() 插入数组本身，不是数组的元素。</p>

<h4 id="toc_26">FILL()</h4>

<p>fill() 方法将数组或数组片段的元素填充为指定值。它将对调用它的数组进行突变，并返回修改后的数组：</p>

<pre><code class="language-javascript">let a = new Array(5);   // Start with no elements and length 5
a.fill(0)               // =&gt; [0,0,0,0,0]; fill the array with zeros
a.fill(9, 1)            // =&gt; [0,9,9,9,9]; fill with 9 starting at index 1
a.fill(8, 2, -1)        // =&gt; [0,9,8,8,9]; fill with 8 at indexes 2, 3
</code></pre>

<p>fill() 的第一个实参是将数组元素填充的值。可选的第二个实参指定起始索引。如果省略，则填充将从索引 0 开始。可选的第三个实参指定结束索引，将填充到（但不包括）该索引的数组元素。 如果省略此实参，则从起始索引到末尾填充数组。可以通过传递负数来指定相对于数组末尾的索引，就像 slice() 一样。</p>

<h4 id="toc_27">COPYWITHIN()</h4>

<p>copyWithin() 将数组的一个片段复制到数组中的新位置。它在适当的位置修改数组并返回修改后的数组，但不会更改数组的长度。第一个实参指定将第一个元素复制到的目标索引。第二个实参指定被复制的第一个元素的索引。如果省略此第二个实参，则使用 0。第三个实参指定被复制的元素片段的结尾。如果省略，则使用数组的长度。从开始索引到结束索引（但不包括结束索引）的元素将被复制。可以通过传递负数来指定相对于数组末尾的索引，就像 slice() 一样：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.copyWithin(1)       // =&gt; [1,1,2,3,4]: copy array elements up one
a.copyWithin(2, 3, 5) // =&gt; [1,2,3,4,4]: copy last 2 elements to index 2
a.copyWithin(0, -2)   // =&gt; [4,4,3,4,4]: negative offsets work, too
</code></pre>

<p>copyWithin() 旨在作为一种高性能方法，对类型化数组特别有用（请参见 §11.2）。它模仿的 C 标准库中 memmove() 函数。 请注意，即使源区域和目标区域之间存在重叠，该拷贝也可以正常工作。</p>

<h3 id="toc_28">7.8.6 数组的查询和排序方法</h3>

<p>数组实现 indexOf()、lastIndexOf() 和 include() 方法，这些方法类似于名称相同的字符串方法。还有 sort() 和 reverse() 方法，用于对数组元素进行重新排序。这些方法在下面的小节中介绍。</p>

<h4 id="toc_29">INDEXOF() 和 LASTINDEXOF()</h4>

<p>indexOf() 和 lastIndexOf() 在数组中搜索具有指定值的元素，并返回找到的第一个元素的索引，如果未找到，则返回 -1。indexOf() 从头到尾搜索数组，lastIndexOf() 从尾到头搜索：</p>

<pre><code class="language-javascript">let a = [0,1,2,1,0];
a.indexOf(1)       // =&gt; 1: a[1] is 1
a.lastIndexOf(1)   // =&gt; 3: a[3] is 1
a.indexOf(3)       // =&gt; -1: no element has value 3
</code></pre>

<p>indexOf() 和 lastIndexOf() 使用 === 运算符将其实参与数组元素进行比较。如果数组包含对象而不是原始值，则这些方法将检查两个引用是否都指向完全相同的对象。如果要实际查看对象的内容，尝试将 find() 方法代替自定义的断言函数。</p>

<p>indexOf() 和 lastIndexOf() 采用可选的第二个实参，该实参指定开始搜索的数组索引。如果省略此参数，则 indexOf() 从开头开始，lastIndexOf() 从结尾开始。第二个参数允许使用负值，并将其视为距数组末端的偏移量，就像 slice() 方法一样：例如，值 –1 指定数组的最后一个元素。</p>

<p>以下函数在数组中搜索指定的值，并返回所有匹配索引的数组。这演示了如何使用 indexOf() 的第二个参数来查找第一个参数之外的匹配项。</p>

<pre><code class="language-javascript">// Find all occurrences of a value x in an array a and return an array
// of matching indexes
function findall(a, x) {
    let results = [],            // The array of indexes we&#39;ll return
        len = a.length,          // The length of the array to be searched
        pos = 0;                 // The position to search from
    while(pos &lt; len) {           // While more elements to search...
        pos = a.indexOf(x, pos); // Search
        if (pos === -1) break;   // If nothing found, we&#39;re done.
        results.push(pos);       // Otherwise, store index in array
        pos = pos + 1;           // And start next search at next element
    }
    return results;              // Return array of indexes
}
</code></pre>

<p>请注意，字符串具有 indexOf() 和 lastIndexOf() 方法，它们与这些数组方法一样工作，不同之处在于第二个实参是负数时被视为零。</p>

<h4 id="toc_30">INCLUDES()</h4>

<p>ES2016 的 includes() 方法采用单个实参，如果数组包含该值返回 true 否则 false。它不会告诉你值的索引，只告诉你该值是否存在。includes() 方法实际上是数组集的成员身份测试。但是请注意，数组不是 Set 的高效表示形式，如果使用多个元素，则应使用真正的 Set 对象（§11.1.1）。</p>

<p>includes() 方法在一个重要方面与 indexOf() 方法略有不同。indexOf() 与 === 运算符使用相同的算法测试相等性，并且这个相等算法认为非数字值与所有其他值（包括自身）不同。includes() 使用略有不同的相等算法，它认为 NaN 等于自身。这意味着 indexOf() 不会检测数组中的 NaN 值，但 includes() 可以：</p>

<pre><code class="language-javascript">let a = [1,true,3,NaN];
a.includes(true)            // =&gt; true
a.includes(2)               // =&gt; false
a.includes(NaN)             // =&gt; true
a.indexOf(NaN)              // =&gt; -1; indexOf can&#39;t find NaN
</code></pre>

<h4 id="toc_31">SORT()</h4>

<p>sort() 对数组的元素直接进行排序，并返回排序后的数组。当调用 sort() 时，它会按字母顺序对数组元素进行排序（如有必要，暂时将它们转换为字符串以执行比较）：</p>

<pre><code class="language-javascript">let a = [&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;];
a.sort(); // a == [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]
</code></pre>

<p>如果数组中包含 undefined 元素，它们会被放在数组的结尾。</p>

<p>若要将数组按字母顺序以外的顺序排序，必须将比较函数作为实参传递给 sort()。该函数决定了它的两个实参在排好序的数组中的先后顺序。假设第一个实参应该在前，比较函数应该返回一个小于 0 的数值。反之，假设第一个参数应该在后，函数应该返回一个大于 0 的数值。并且，假设两个值相等（也就是说，它们的顺序无关紧要），函数应该返回 0。例如，用数值大小而非字母表顺序进行数组排序，代码如下：</p>

<pre><code class="language-javascript">let a = [33, 4, 1111, 222];
a.sort();               // a == [1111, 222, 33, 4]; alphabetical order
a.sort(function(a,b) {  // Pass a comparator function
    return a-b;         // Returns &lt; 0, 0, or &gt; 0, depending on order
});                     // a == [4, 33, 222, 1111]; numerical order
a.sort((a,b) =&gt; b-a);   // a == [1111, 222, 33, 4]; reverse numerical order
</code></pre>

<p>另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将实参都转化为小写字符串（使用 toLowerCase() 方法），再开始比较：</p>

<pre><code class="language-javascript">let a = [&quot;ant&quot;, &quot;Bug&quot;, &quot;cat&quot;, &quot;Dog&quot;];
a.sort();    // a == [&quot;Bug&quot;,&quot;Dog&quot;,&quot;ant&quot;,&quot;cat&quot;]; case-sensitive sort
a.sort(function(s,t) {
    let a = s.toLowerCase();
    let b = t.toLowerCase();
    if (a &lt; b) return -1;
    if (a &gt; b) return 1;
    return 0;
});   // a == [&quot;ant&quot;,&quot;Bug&quot;,&quot;cat&quot;,&quot;Dog&quot;]; case-insensitive sort
</code></pre>

<h4 id="toc_32">REVERSE()</h4>

<p>reverse() 方法反转数组中元素的顺序并返回反转后的数组。它直接在数组中操作，换一种说法，它不创建一个新的数组，它不创建一个新的带有排序后的元素的数组，而是直接在已存在的数组中进行排序。</p>

<pre><code class="language-javascript">let a = [1,2,3];
a.reverse();   // a == [3,2,1]
</code></pre>

<h3 id="toc_33">7.8.7 数组转化字符串</h3>

<p>Array 类定义了三个方法来将数组转化为字符串，通常在创建日志和错误信息时会用到。（如果要以文本形式保存数组的内容供以后重用，请使用 JSON.stringify()（§6.8）序列化数组，而不是使用此处描述的方法。）</p>

<p>join() 方法将数组的所有元素转换为字符串并连接它们，返回生成的字符串。可以指定一个可选字符串来分隔生成的字符串中的元素。如果未指定分隔符字符串，则使用逗号：</p>

<pre><code class="language-javascript">let a = [1, 2, 3];
a.join()               // =&gt; &quot;1,2,3&quot;
a.join(&quot; &quot;)            // =&gt; &quot;1 2 3&quot;
a.join(&quot;&quot;)             // =&gt; &quot;123&quot;
let b = new Array(10); // An array of length 10 with no elements
b.join(&quot;-&quot;)            // =&gt; &quot;---------&quot;: a string of 9 hyphens
</code></pre>

<p>join() 方法是 String.split() 方法的反向方法，该方法通过将字符串拆分为多个片段来创建数组。</p>

<p>数组与所有 JavaScript 对象一样，具有 toString() 方法。对于数组，此方法的工作方式与没有参数的 join() 方法相同：</p>

<pre><code class="language-javascript">[1,2,3].toString()          // =&gt; &quot;1,2,3&quot;
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toString()  // =&gt; &quot;a,b,c&quot;
[1, [2,&quot;c&quot;]].toString()     // =&gt; &quot;1,2,c&quot;
</code></pre>

<p>请注意，输出不包括方括号或数组值周围的任何其他分隔符。</p>

<p>toLocaleString() 是 toString() 的本地化版本。它通过调用元素的 toLocaleString() 方法将每个数组元素转换为字符串，然后使用特定于区域设置（和实现定义）分隔符字符串连接生成的字符串。</p>

<h3 id="toc_34">7.8.8 Array 的静态方法</h3>

<p>除了我们已经记录的数组方法之外，Array 类还定义了三个静态函数，可以通过 Array 构造函数而不是数组调用。Array.of() 和 Array.from() 是用于创建新数组的工厂方法。它们记录在 §7.1.4 和 §7.1.5 中。</p>

<p>另外一个静态数组方法是 Array.isArray()，用来判断一个未知值是否是数组：</p>

<pre><code class="language-javascript">Array.isArray([])     // =&gt; true
Array.isArray({})     // =&gt; false
</code></pre>

<h2 id="toc_35">7.9 类数组对象</h2>

<p>我们已经看到，JavaScript 数组的有一些特性是其他对象所没有的：</p>

<ul>
<li>当有新的元素添加到列表中时，自动更新 length 属性。</li>
<li>length 设置为一个较小值将截断数组。</li>
<li>从 Array.prototype 中继承一些有用的方法。</li>
<li>数组传入 Array.isArray() 方法返回 true。</li>
</ul>

<p>这些特性让 JavaScript 数组和常规的对象有明显的区别。但是它们不是定义数组的本质特性。一种常常完全合理的看法是把拥有一个数值型 length 属性和对应非负整数属性的对象看作数组的同类。</p>

<p>实际上这些“类数组”对象在实践中偶尔出现，虽然不能通过它们直接调用数组方法或者期望 length 属性有什么特殊的行为，但是仍然可以用针对真正数组遍历代码来遍历它们。结论就是很多数组算法针对类数组对象同样奏效，就像针对真正的数组一样。尤其是这种情况，算法把数组看成只读的或者如果保持数组长度不变。</p>

<p>以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”：</p>

<pre><code class="language-javascript">let a = {};  // Start with a regular empty object

// Add properties to make it &quot;array-like&quot;
let i = 0;
while(i &lt; 10) {
    a[i] = i * i;
    i++;
}
a.length = i;

// Now iterate through it as if it were a real array
let total = 0;
for(let j = 0; j &lt; a.length; j++) {
    total += a[j];
}
</code></pre>

<p>在客户端 JavaScript 中，很多作用于 HTML documents 的方法（例如 document.querySelectorAll()）返回类数组对象。下面这个函数可能会用于测试对象是否可以用作类数组：</p>

<pre><code class="language-javascript">// Determine if o is an array-like object.
// Strings and functions have numeric length properties, but are
// excluded by the typeof test. In client-side JavaScript, DOM text
// nodes have a numeric length property, and may need to be excluded
// with an additional o.nodeType !== 3 test.
function isArrayLike(o) {
    if (o &amp;&amp;                            // o is not null, undefined, etc.
        typeof o === &quot;object&quot; &amp;&amp;        // o is an object
        Number.isFinite(o.length) &amp;&amp;    // o.length is a finite number
        o.length &gt;= 0 &amp;&amp;                // o.length is non-negative
        Number.isInteger(o.length) &amp;&amp;   // o.length is an integer
        o.length &lt; 4294967295) {        // o.length &lt; 2^32 - 1
        return true;                    // Then o is array-like.
    } else {
        return false;                   // Otherwise it is not.
    }
}
</code></pre>

<p>我们会在下一节看到字符串的行为像数组一样。尽管如此，对于数组这种测试（对字符串通常返回 false ）它们通常最好作为字符串处理，而不是作为数组处理。</p>

<p>大多数 JavaScript 数组方法都特意定义为泛型，以便它们在应用于除数组之外的类数组可以正常工作。由于类数组对象不会从 Array.prototype 继承，因此不能直接在它们上调用数组方法。但是，可以使用 Function.call 方法间接调用它们（详情请参阅 §8.7.4）：</p>

<pre><code class="language-javascript">let a = {&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;, length: 3}; // An array-like object
Array.prototype.join.call(a, &quot;+&quot;)                  // =&gt; &quot;a+b+c&quot;
Array.prototype.map.call(a, x =&gt; x.toUpperCase())  // =&gt; [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
Array.prototype.slice.call(a, 0)   // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]: true array copy
Array.from(a)                      // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]: easier array copy
</code></pre>

<p>此代码倒数第二行调用数组类对象上的 Array slice() 方法，以便将该对象的元素复制到真正的数组对象中。这是一个惯用的技巧，存在于许多旧代码中，但现在使用 Array.from() 要容易得多。</p>

<h2 id="toc_36">7.10 作为数组的字符串</h2>

<p>JavaScript 字符串的行为类似于 UTF-16 Unicode 字符的只读数组。可以使用方括号替代 charAt() 方法访问单个字符：</p>

<pre><code class="language-javascript">let s = &quot;test&quot;;
s.charAt(0)    // =&gt; &quot;t&quot;
s[1]           // =&gt; &quot;e&quot;
</code></pre>

<p>当然，字符串使用 typeof 运算符仍然返回 &quot;string&quot;，如果将字符串传递给 Array.isArray() 方法，则返回 false。</p>

<p>可索引字符串的主要好处是，我们可以用方括号替换对 charAt() 的调用，方括号更简洁、更可读，而且可能更高效。但是，字符串的行为类似于数组，也意味着我们可以对它们应用泛型数组方法。例如：</p>

<pre><code class="language-javascript">Array.prototype.join.call(&quot;JavaScript&quot;, &quot; &quot;)  // =&gt; &quot;J a v a S c r i p t&quot;
</code></pre>

<p>请记住，字符串是不可变值，因此当字符串被视为数组时，它们是只读数组。数组方法 push()、sort()、reverse() 和 splice() 直接修改数组，它们不能处理字符串。但是，尝试使用数组方法修改字符串不会引发异常：它只是静默失败。</p>

<h2 id="toc_37">7.11 总结</h2>

<p>本章深入介绍了 JavaScript 数组，包括有关稀疏数组和类数组对象的深奥细节。本章要点包括：</p>

<ul>
<li>数组字面量编写：方括号内逗号分隔值列表。</li>
<li>通过在方括号内指定所需的数组索引来访问单个数组元素。</li>
<li>for/of 循环和 ES6 中引入的 ... 展开运算符是遍历数组的特别有用的方法。</li>
<li>Array 类定义了一组用于操作数组的丰富方法，应该确保熟悉 Array API。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 8 章 函数]]></title>
    <link href="blog.2019919.top/16106664265983.html"/>
    <updated>2021-01-15T07:20:26+08:00</updated>
    <id>blog.2019919.top/16106664265983.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">8.1 函数定义</a>
<ul>
<li>
<a href="#toc_1">8.1.1 函数声明</a>
</li>
<li>
<a href="#toc_2">8.1.2 函数表达式</a>
</li>
<li>
<a href="#toc_3">8.1.3 箭头函数</a>
</li>
<li>
<a href="#toc_4">8.1.4 嵌套函数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">8.2 函数调用</a>
<ul>
<li>
<a href="#toc_6">8.2.1 函数调用</a>
<ul>
<li>
<a href="#toc_7">条件调用</a>
</li>
<li>
<a href="#toc_8">递归函数和栈</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">8.2.2 方法调用</a>
<ul>
<li>
<a href="#toc_10">方法链</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">8.2.3 构造函数调用</a>
</li>
<li>
<a href="#toc_12">8.2.4 间接调用</a>
</li>
<li>
<a href="#toc_13">8.2.5 函数隐式调用</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">8.3 函数的实参和形参</a>
<ul>
<li>
<a href="#toc_15">8.3.1 可选形参和默认值</a>
</li>
<li>
<a href="#toc_16">8.3.2 剩余参数和可变长实参列表</a>
</li>
<li>
<a href="#toc_17">8.3.3 实参对象</a>
</li>
<li>
<a href="#toc_18">8.3.4 函数调用时的展开运算符</a>
</li>
<li>
<a href="#toc_19">8.3.5 实参解构到形参中</a>
</li>
<li>
<a href="#toc_20">8.3.6 实参类型</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">8.4 函数作为值</a>
<ul>
<li>
<a href="#toc_22">8.4.1 自定义函数属性</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">8.5 函数作为命名空间</a>
</li>
<li>
<a href="#toc_24">8.6 闭包</a>
</li>
<li>
<a href="#toc_25">8.7 函数属性、方法、和构造函数</a>
<ul>
<li>
<a href="#toc_26">8.7.1 length 属性</a>
</li>
<li>
<a href="#toc_27">8.7.2 name 属性</a>
</li>
<li>
<a href="#toc_28">8.7.3 prototype 属性</a>
</li>
<li>
<a href="#toc_29">8.7.4 call() 和 apply() 方法</a>
</li>
<li>
<a href="#toc_30">8.7.5 bind() 方法</a>
</li>
<li>
<a href="#toc_31">8.7.6 toString() 方法</a>
</li>
<li>
<a href="#toc_32">8.7.7 Function() 构造函数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_33">8.8 函数式编程</a>
<ul>
<li>
<a href="#toc_34">8.8.1 用函数处理数组</a>
</li>
<li>
<a href="#toc_35">8.8.2 高阶函数</a>
</li>
<li>
<a href="#toc_36">8.8.3 局部应用函数</a>
</li>
<li>
<a href="#toc_37">8.8.4 记忆（Memoization）</a>
</li>
</ul>
</li>
<li>
<a href="#toc_38">8.9 总结</a>
</li>
</ul>


<p>本章介绍了 JavaScript 函数。函数是 JavaScript 程序的基本构建块，也是几乎所有编程语言的共同特性。你可能已经了解函数的概念，如子例程或过程。</p>

<p>函数是一个 JavaScript 代码块，只定义一次，但可以执行或调用任意次数。JavaScript 函数是参数化的：一个函数定义可以包含一个标识符列表，称为参数，作为函数体的局部变量。函数调用为函数的参数提供值或实参。函数通常使用它们的实参值来计算一个返回值，该返回值成为函数调用表达式的值。除了参数之外，每次调用都有另一个值——调用上下文——即 this 关键字的值。</p>

<p>如果函数挂载在一个对象上作为其属性，它就被称为方法。当该方法在对象中被调用或通过对象调用时，该对象就是该方法函数的调用上下文或 this 值。用于初始化新创建的对象的函数称为构造函数。构造函数在 §6.2 中有介绍，我们将在第9章中再次谈到它。</p>

<p>在 JavaScript 中，函数是对象，它们可以被程序操作。例如，JavaScript 可以将函数赋给变量，并将它们传递给其他函数。由于函数是对象，所以您可以给它们设置属性，甚至调用它们的方法。</p>

<p>JavaScript 函数可以嵌套在其他函数中定义，并且它们可以访问定义它们所处的作用域内任何变量。这意味着 JavaScript 函数是闭包，支持闭包是非常重要的，它是非常强大的编程技巧。</p>

<h2 id="toc_0">8.1 函数定义</h2>

<p>定义 JavaScript 函数最直接的方法是使用 function 关键字，它既可以用作声明又可以用作表达式。ES6 定义了一种不使用 function 关键字的重要新方法来定义的函数：“箭头函数”，它具有特别简洁语法，并且在将一个函数作为参数传递给另一个函数的场景中非常实用。接下来的小节将介绍这三种定义函数的方法。注意，关于函数定义语法包含的函数参数相关内容将在 §8.3 中介绍。</p>

<p>在对象字面量和类定义中，有一种方便的快捷语法来定义方法。这种简写语法在 §6.10.5 中有介绍，相当于通过对象字面量语法将函数定义表达式用最基本的属性名：属性值的方式赋值给对象的属性。在另一种特殊情况下，可以在对象字面量中使用关键字 get 和 set 来定义特殊的属性 getter 和 setter 方法。这个函数定义语法在 §6.10.6 中介绍过。</p>

<p>注意，函数也可以用 Function() 构造函数来定义，这是 §8.7.7 的主题。此外，JavaScript 还定义了一些特殊类型的函数。function* 定义函数生成器（见第12章）和 async function 定义异步函数（见第13章）。</p>

<h3 id="toc_1">8.1.1 函数声明</h3>

<p>函数声明由 function 关键字组成，后面跟着这些组件:</p>

<ul>
<li>函数名称标识符。名称是函数声明的必要部分:它用作变量的名称，并将新定义的函数对象赋值给该变量。</li>
<li>一对圆括号，其中包含由0个或者多个用逗号分隔的标识符组成的列表。这些标识符是函数的参数名，它们的行为类似于函数体中的局部变量。</li>
<li>一对花括号，其中包含由0条或者多条 JavaScript 语句。这些语句构成了函数体：每当函数调用时，就会执行这些语句。</li>
</ul>

<p>下面是一些函数声明的例子:</p>

<pre><code class="language-javascript">// Print the name and value of each property of o.  Return undefined.
function printprops(o) {
    for(let p in o) {
        console.log(`${p}: ${o[p]}\n`);
    }
}

// Compute the distance between Cartesian points (x1,y1) and (x2,y2).
function distance(x1, y1, x2, y2) {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return Math.sqrt(dx*dx + dy*dy);
}

// A recursive function (one that calls itself) that computes factorials
// Recall that x! is the product of x and all positive integers less than it.
function factorial(x) {
    if (x &lt;= 1) return 1;
    return x * factorial(x-1);
}
</code></pre>

<p>重中之重要理解函数声明是函数名变成一个变量，这个变量的值是函数本身。函数声明语句“被提前”到脚本、函数、块之前，因此这种方式定义的函数可以在它定义之前被调用。另一种说法是所有声明在 Javascript 代码块中的函数，在块内始终是有定义的，它们定义在 JavaScript 解释器开始解释执行块内任何语句之前。</p>

<p>distance() 和 factorial() 函数计算一个值，它们用 retrun 来将这个值返回给调用者。return 语句导致函数停止执行，并返回它的表达式的值（如果有的话）给调用者。如果 return 语句没有一个与之相关的表达式，则函数返回 undefined 值。</p>

<p>printprops() 函数不同：它负责输出对象属性的名称和值。没有返回值的必要，并且该函数也不包含一个 return 语句。 调用 printprops() 函数的返回值永远是 undefined。如果一个函数不包含一个 return 语句，它仅仅执行函数体内每一条语句直到结束，并返回 undefined 给调用者。</p>

<p>在 ES6 之前，函数只允许在 JavaScript 文件顶层或者其他函数中声明。然而一些实现违反规约，在循环体条件体或者其他块中定义函数。在 ES6 的严格模式下，函数允许在块内进行声明。一个定义在块内的函数只存在于该块内，块外是不可见的。</p>

<h3 id="toc_2">8.1.2 函数表达式</h3>

<p>函数表达式看起来很像函数声明，但是它出现在一个它的上层表达式或语句的上下文中，并且函数名称是可选项。</p>

<p>下面是一些函数表达式的例子：</p>

<pre><code class="language-javascript">// This function expression defines a function that squares its argument.
// Note that we assign it to a variable
const square = function(x) { return x*x; };

// Function expressions can include names, which is useful for recursion.
const f = function fact(x) { if (x &lt;= 1) return 1; else return x*fact(x-1); };

// Function expressions can also be used as arguments to other functions:
[3,2,1].sort(function(a,b) { return a-b; });

// Function expressions are sometimes defined and immediately invoked:
let tensquared = (function(x) {return x*x;}(10));
</code></pre>

<p>注意函数名称在函数表达式中是可选项，在大部分函数表达式中我们省略了它。函数声明实际上声明了一个变量并且将函数对象赋值给它。按照这个角度来看，函数表达式没有声明一个变量：可以根据它是否会多次调用由你自己决定是将新定义的函数对象赋值给一个常量还是变量。用 const 定义函数表达式是一个非常好的做法，你不会因为意外赋值而重写了你的函数。</p>

<p>可以给函数一个名称，就像 factorial 函数，它需要调用它自己。如果一个函数表达式包含一个名称，那这个函数的局部函数作用域内会包含一个属性名为该函数名的对象，其值绑定的是该函数。实际上，函数名变成这个函数的一个局部变量。大多数函数表达式不需要函数名称，这让它们的定义更简洁（但是并没有下面要讲的箭头函数简洁）。</p>

<p>在函数声明和函数表达式之间有一个非常重要的不同。当你用函数声明，该函数对象创建于该函数所在作用域的代码开始执行之前，也就是声明提前，所以你可以在函数定义之前调用他们。如果用函数表达式来定义一个函数，这样使用就是不对的：该函数不会存在，直到函数定义表达式真正被计算。因为，想要执行一个函数，你必须可以引用它，而一个函数表达式定义的函数一直到该函数赋值给一个变量后才能被引用，所以要使用函数表达式需要在函数被调用之前定义。</p>

<h3 id="toc_3">8.1.3 箭头函数</h3>

<p>在 ES6 之后，你可以用一个特别简洁的语法来定义函数，被称为“箭头函数”。这个语法联想到数学符号，用一个 =&gt; &quot;箭头&quot;来分隔函数的参数和函数体。function 关键字未使用，并且，由于箭头函数是表达式而不是声明语句，也不需要一个函数名称。一般箭头函数用圆括号包含一个逗号分隔的参数列表，接一个 =&gt; 箭头，后面是花括号包含的函数体。</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; { return x + y; };
</code></pre>

<p>但是箭头函数支持更加简洁的语法。如果函数体只有一个简单的 return 语句，你可以省略 return 关键字，分号和花括号都一起省略，将函数体写成一个计算返回值的表达式。</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; x + y;
</code></pre>

<p>而且，如果一个箭头函数只有一个参数，你可以省略参数列表的圆括号。</p>

<pre><code class="language-javascript">const polynomial = x =&gt; x*x + 2*x + 3;
</code></pre>

<p>注意，如果箭头函数没有参数，必须写一对空圆括号。</p>

<pre><code class="language-javascript">const constantFunc = () =&gt; 42;
</code></pre>

<p>注意，当写一个箭头函数时，函数参数和箭头之间不能换行。否则，可能会直接在赋值后中止，就像 <code>const polynomial = x</code>，因为它本身是一个语法上合法的赋值语句。</p>

<p>此外，如果箭头函数体是一个单一的 return 语句，而且他返回的是一个对象字面量，那必须将对象字面量用圆括号包起来，避免将对象字面量的大括号误解成函数体的大括号。</p>

<pre><code class="language-javascript">const f = x =&gt; { return { value: x }; };  // Good: f() returns an object
const g = x =&gt; ({ value: x });            // Good: g() returns an object
const h = x =&gt; { value: x };              // Bad: h() returns nothing
const i = x =&gt; { v: x, w: x };            // Bad: Syntax Error
</code></pre>

<p>这段代码的第三行，函数 h() 就有歧义：这段代码原本返回对象字面量被转化为一个标签语句，所以一个返回 undefined 的函数被创建。第四行，结构更复杂的对象字面量不是一个合法的语句，这段代码会抛出一个语法异常。</p>

<p>简洁的箭头函数可以完美的传递一个函数给另外一个函数，比如一些数组的常规操作方法 map()，filter() 和 reduce()（见 §7.8.1），例如：</p>

<pre><code class="language-javascript">// Make a copy of an array with null elements removed.
let filtered = [1,null,2,3].filter(x =&gt; x !== null); // filtered == [1,2,3]
// Square some numbers:
let squares = [1,2,3,4].map(x =&gt; x*x);               // squares == [1,4,9,16]
</code></pre>

<p>箭头函数不同于用关键字定义的函数：箭头函数从定义它们的环境继承 this 关键字，而不是像其他定义方式那样定义自己的调用上下文。这是箭头函数一个重要且特别实用的特性，我们会在这一章的后面再次提到它。箭头函数也不同于其他函数，它们没有有原型属性。这意味着它不能被当作一个构造函数去创建一个类（见 §9.2）。</p>

<h3 id="toc_4">8.1.4 嵌套函数</h3>

<p>在 JavaScript 中，函数可以嵌套在其他函数内。例如：</p>

<pre><code class="language-javascript">function hypotenuse(a, b) {
    function square(x) { return x*x; }
    return Math.sqrt(square(a) + square(b));
}
</code></pre>

<p>嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。例如，在上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b。这些作用域规则对嵌套函数非常重要，我们会在 §8.6 再深入了解它们。</p>

<h2 id="toc_5">8.2 函数调用</h2>

<p>构成函数主体的 JavaScript 代码在定义之时并不会执行，只有调用该函数时，它们才会执行。JavaScript 函数可以以五种方式被调用。</p>

<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造函数</li>
<li>通过它们的 call() 和 apply() 方法间接调用</li>
<li>隐式调用，不同于普通函数调，通过 JavaScript 语言特性调用函数。</li>
</ul>

<h3 id="toc_6">8.2.1 函数调用</h3>

<p>函数或方法通过调用表达式（§4.5）被调用。调用表达式由以下部分组成，计算函数对象的函数表达式，一个开放圆括号，逗号分隔的零个或多个实参表达式列表，一个闭合圆括号。如果函数表达式是属性访问表达式（函数是一个对象的属性或者一个数组的元素）那么它是一个方法调用表达式。这种情况会通过下面的例子说明，接下来这个代码包含了一些常规的函数调用表达式：</p>

<pre><code class="language-javascript">printprops({x: 1});
let total = distance(0,0,2,1) + distance(2,1,3,5);
let probability = factorial(5)/factorial(13);
</code></pre>

<p>在调用中，每个实参表达式（圆括号内的）执行计算，返回值作为函数的实参。这些值传给函数定义的参数。在函数体内，参数的引用指向对应实参的值。</p>

<p>对于常规的函数调用，函数返回值变成函数调用表达式的值。如果因解释器执行到函数结尾而返回，返回值就是 undefined。如果函数返回是因为解释器执行一个 return 语句，那么返回值是 return 后面的表达式的计算结果，如果 return 语句没有值也返回 undefined。</p>

<h4 id="toc_7">条件调用</h4>

<p>在 ES2020 中你可以通过在函数表达式和圆括号之间插入 ?. 符号，使函数只有在不为 null 和 undefined 时候再调用。表达式 f?.(x) 等价（假设没有副作用）于：</p>

<pre><code class="language-javascript">(f !== null &amp;&amp; f !== undefined) ? f(x) : undefined
</code></pre>

<p>详细的条件执行语法描述在 §4.5.1。</p>

<p>函数调用在非严格模式下，调用上下文（ this ）是全局对象。然而在严格模式下，调用上下文是 undefined。注意箭头语法定义的函数行为是不同的：实际上它们总是继承它们定义位置的 this 值。</p>

<p>以函数形式调用的函数通常不使用 this 关键字。不过，this 关键字可以用来判断当前是否是严格模式。</p>

<pre><code class="language-javascript">// Define and invoke a function to determine if we&#39;re in strict mode.
const strict = (function() { return !this; }());
</code></pre>

<h4 id="toc_8">递归函数和栈</h4>

<p>递归函数就像本章开始的 factorial() 函数，它调用它自己。某些算法（如涉及基于树的数据结构）可以使用递归函数特别优雅地实现。在写递归函数时，考虑内存分配是很重要的。当函数 A 调用函数 B，然后函数 B 又调用函数 C 时，Javascript 编译器需要知道在哪里重新执行函数 B，当函数 B 执行完成后它需要知道在哪里执行函数 A。你可以将执行上下文想象成一个栈。当一个函数调用另外一个函数时，一个新的执行上下文被压入栈中。当被调用函数返回，它的执行上下文对象从栈中弹出。如果一个函数递归调用100次，那么会有100个对象被压入栈中，然后这100个对象再依次从栈中弹出。这种调用非常耗内存。以现代的硬件递归调用100次通常没什么问题。但是如果一个函数递归上千次，它可能会失败并报错“Maximum call-stack size exceeded.”。</p>

<h3 id="toc_9">8.2.2 方法调用</h3>

<p>方法只不过是对象属性函数。如果有一个函数 f 和一个对象 o，可以用下面的代码给对象 o 定义一个名为 m 的方法：</p>

<pre><code class="language-javascript">o.m = f;
</code></pre>

<p>给对象 o 定义了方法 m()，用这种方式调用它：</p>

<pre><code class="language-javascript">o.m();
</code></pre>

<p>或者 m() 需要两个实参，可以这样调用它：</p>

<pre><code class="language-javascript">o.m(x, y);
</code></pre>

<p>例子中的代码是一个调用表达式：它包含一个函数表达式 o.m 和两个实参表达式 x 和 y。函数表达式本身是一个属性访问表达式，这意味着该函数被当作一个方法调用，而不是一个普通的函数。</p>

<p>对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即：调用上下文。属性访问表达式由两部分组成：一个对象（本例中的 o）和属性名称（m）。在像这样的方法调用表达式里，对象 o 成为调用上下文，函数体可以使用关键字this引用该对象。下面是一个具体的例子：</p>

<pre><code class="language-javascript">let calculator = { // An object literal
    operand1: 1,
    operand2: 1,
    add() {        // We&#39;re using method shorthand syntax for this function
        // Note the use of the this keyword to refer to the containing object.
        this.result = this.operand1 + this.operand2;
    }
};
calculator.add();  // A method invocation to compute 1+1.
calculator.result  // =&gt; 2
</code></pre>

<p>大多数方法调用使用点符号来访问属性，使用方括号（属性访问表达式）也可以进行属性访问操作。下面两个例子都是函数调用：</p>

<pre><code class="language-javascript">o[&quot;m&quot;](x,y);   // Another way to write o.m(x,y).
a[0](z)        // Also a method invocation (assuming a[0] is a function).
</code></pre>

<p>方法调用可能包括更复杂的属性访问表达式：</p>

<pre><code class="language-javascript">customer.surname.toUpperCase(); // Invoke method on customer.surname
f().m();                        // Invoke method m() on return value of f()
</code></pre>

<p>方法和 this 关键字是面向对象编程范式的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参对象，就是调用这个方法对象本身。通常来讲，方法执行就是对象的某种操作，方法调用的语法也清晰的表达了它是操作对象的函数，比较下面两行代码：</p>

<pre><code class="language-javascript">rect.setSize(width, height);
setRectSize(rect, width, height);
</code></pre>

<p>我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象 rect。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是 rect 对象，函数中的所有操作都将基于这个对象。</p>

<h4 id="toc_10">方法链</h4>

<p>当方法返回一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（或“链”）每次的调用结果都是另外一个表达式的组成部分。比如，基于 Promise 的异步操作（参见第13章），我们常常会这样写代码：</p>

<pre><code class="language-javascript">// Run three asynchronous operations in sequence, handling errors.
doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);
</code></pre>

<p>当方法并不需要返回值时，最好直接返回 this。如果在设计的 API 中一直采用这种方式，使用 API 就可以用方法链 <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 风格的编程，在这种编程风格中，只要指定一次要调用的对象即可，余下的方法都可以基于此进行调用：</p>

<pre><code class="language-javascript">new Square().x(100).y(100).size(50).outline(&quot;red&quot;).fill(&quot;blue&quot;).draw();
</code></pre>

<p>需要注意的是，this 是一个关键字，不是变量，也不是属性名。JavaScript 的语法不允许给 this 赋值。</p>

<p>关键字 this 没有变量作用域的限制，除了箭头函数，嵌套函数不会从包含它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套的函数作为函数调用（不包含箭头函数），其 this 值不是全局对象（非严格模式下）就是undefined（严格模式下）。很多人误以为在一个方法中的函数声明并以函数调用的方式去执行可以用 this 来获取方法的执行上下文。下面这个例子说明了这个问题：</p>

<pre><code class="language-javascript">let o = {                 // An object o.
    m: function() {       // Method m of the object.
        let self = this;  // Save the &quot;this&quot; value in a variable.
        this === o        // =&gt; true: &quot;this&quot; is the object o.
        f();              // Now call the helper function f().

        function f() {    // A nested function f
            this === o    // =&gt; false: &quot;this&quot; is global or undefined
            self === o    // =&gt; true: self is the outer &quot;this&quot; value.
        }
    }
};
o.m();                    // Invoke the method m on the object o.
</code></pre>

<p>嵌套函数 f() 中，this 关键之不等于对象 o。这被广泛的认为是 JavaScript 的一个缺陷，了解这一点是很是很重要的。上面的代码演示了一种常用的解决方案。在方法 m 中，将 this 值赋值给一个变量 self，在签到函数 f 中，可以用 self 代替 this 来引用包含它的对象。</p>

<p>在 ES6 之后，有另外一种解决方案来解决这个问题，将嵌套函数 f 转换成箭头函数，它会正确的继承 this 值：</p>

<pre><code class="language-javascript">const f = () =&gt; {
    this === o  // true, since arrow functions inherit this
};
</code></pre>

<p>函数表达式不像函数声明，声明提前，所以为了让这种解决方案定义的函数可以被调用，需要将 f 函数定义表达式放在方法 m 中，这样它才可以在它被调用时存在。</p>

<p>另外还可以用嵌套函数的 bind() 方法，在指定对象上隐式调用一个新的函数：</p>

<pre><code class="language-javascript">const f = (function() {
    this === o  // true, since we bound this function to the outer this
}).bind(this);
</code></pre>

<p>关于 bind() 方法将在 §8.7.5 中讲解。</p>

<h3 id="toc_11">8.2.3 构造函数调用</h3>

<p>如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用（构造函数调用在 §4.6 和 §6.2.2 节有简单介绍，第9章会对构造函数做更详细的讨论）。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。</p>

<p>如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，JavaScript 构造函数调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号，比如，下面这两行代码就是等价的：</p>

<pre><code class="language-javascript">o = new Object();
o = new Object;
</code></pre>

<p>构造函数调用创建一个新的空对象，这个对象继承自构造函数的 prototype 属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数内可以使用 this 关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式 new o.m() 中，调用上下文并不是 o。</p>

<p>构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会隐式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p>

<h3 id="toc_12">8.2.4 间接调用</h3>

<p>JavaScript 中的函数也是对象，和其他 JavaScript 对象没什么两样，函数对象也可以包含方法。其中的两个方法 call() 和 apply() 可以用来间接地调用函数。两个方法都允许显式指定调用所需的 this 值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。call() 方法使用它自有的实参列表作为函数的实参，apply() 方法则要求以数组的形式传入实参。§8.7.4 节会有关于 call() 和apply () 方法的详细讨论。</p>

<h3 id="toc_13">8.2.5 函数隐式调用</h3>

<p>有各种各样的 JavaScript 语言特性，它们看起来不像函数调用但是却能调用函数。额外小心编写函数时可能会隐式调用，因为在隐式函数调用中 bug、副作用和性能问题都比普通的函数更难诊断和修复。</p>

<p>可能引起函数隐式调用的语言特性包括：</p>

<p>如果一个对象定义了 getter 或者 setter 方法，获取或者设置它的属性值可能调用这些方法。见 §6.10.6 有更多相关描述。</p>

<p>当对象用作一个字符串文本时（例如对象和一个字符串连接），它的 toString() 方法会被调用。同样的，对象用作一个数值型文本时，它的 valueOf() 方法被调用。详见 §3.9.3。</p>

<p>当循环可迭代对象的元素时会产生很多方法调用。第12章介绍了迭代器在函数调用级别如何工作，并演示如何编写方法来定义自己的可迭代类型。</p>

<p>可以伪装在模板字面量中 。在 §14.5 中演示如何在模板字符串中调用函数。</p>

<p>Proxy 对象（在 §14.7 中描述）的行为完全由函数控制。它的任何一个操作都会导致函数调用。</p>

<h2 id="toc_14">8.3 函数的实参和形参</h2>

<p>JavaScript 中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JavaScript 函数调用甚至不检查传入形参的个数。下面几节将会讨论当调用函数时的实参个数和声明的形参个数不匹配时出现的状况，同样介绍了如何显式测试函数实参的类型，以避免非法的实参传入函数。</p>

<h3 id="toc_15">8.3.1 可选形参和默认值</h3>

<p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。所以一些参数设置成可选的是非常实用的。看下面这个例子：</p>

<pre><code class="language-javascript">// Append the names of the enumerable properties of object o to the
// array a, and return a.  If a is omitted, create and return a new array.
function getPropertyNames(o, a) {
    if (a === undefined) a = [];  // If undefined, use a new array
    for(let property in o) a.push(property);
    return a;
}

// getPropertyNames() can be invoked with one or two arguments:
let o = {x: 1}, p = {y: 2, z: 3};  // Two objects for testing
let a = getPropertyNames(o); // a == [&quot;x&quot;]; get o&#39;s properties in a new array
getPropertyNames(p, a);      // a == [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; add p&#39;s properties to it
</code></pre>

<p>第一行代码中可以使用 || 运算符来代替一个 if 语句，这是一种习惯用法：</p>

<pre><code class="language-javascript">a = a || [];
</code></pre>

<p>回忆一下，§4.10.2 介绍了“||”运算符，如果第一个实参是真值的话就返回第一个实参；否则返回第二个实参。在这个场景下，如果作为第二个实参传入任意对象，那么函数就会使用这个对象。如果省略掉第二个实参（或者传递 null 以及其他任何假值），那么就新创建一个空数组，并赋值给 a。</p>

<p>需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参，他们必须显地的将 undefined 传入作为第一个实参 。</p>

<p>在 ES6 之后，可以直接在函数的参数列表中为每个函数参数定义默认值。直接在参数名后面接一个等号再接一个默认值（用于没有实参提供给参数时参数的值）：</p>

<pre><code class="language-javascript">// Append the names of the enumerable properties of object o to the
// array a, and return a.  If a is omitted, create and return a new array.
function getPropertyNames(o, a = []) {
    for(let property in o) a.push(property);
    return a;
}
</code></pre>

<p>默认参数表达式只有在函数调用时进行计算，而不是在它定义时，所以每一次 getPropertyNames() 函数只传一个实参调用时，一个新的空数组被创建并传给参数。<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> 最容易理解的就是参数默认值是常量（或者字面量表达式 [] 和 {}）。但这并不是必须的：举个例子，你可以用变量或者函数调用，计算一个默认参数的值。一个很有趣的情况是，对于有多个参数的函数，可以用前面的参数值来定义后面的参数默认值。</p>

<pre><code class="language-javascript">// This function returns an object representing a rectangle&#39;s dimensions.
// If only width is supplied, make it twice as high as it is wide.
const rectangle = (width, height=width*2) =&gt; ({width, height});
rectangle(1)  // =&gt; { width: 1, height: 2 }
</code></pre>

<p>这段代码描述了箭头函数中的参数默认值。方法函数和其他形式的函数定义也是如此。</p>

<h3 id="toc_16">8.3.2 剩余参数和可变长实参列表</h3>

<p>调用函数时允许传入的实参比函数声明时指定的形参个数少。剩余参数允许相反的情况：它允许我们在调用函数时，传入比型参多任意个数的实参。下面是一个可以传入一个或多个数值型实参的例子，并且返回其中最大的数：</p>

<pre><code class="language-javascript">function max(first=-Infinity, ...rest) {
    let maxValue = first; // Start by assuming the first arg is biggest
    // Then loop through the rest of the arguments, looking for bigger
    for(let n of rest) {
        if (n &gt; maxValue) {
            maxValue = n;
        }
    }
    // Return the biggest
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6)  // =&gt; 1000
</code></pre>

<p>剩余参数由三个 . 开始，必须是函数声明的最后一个参数。调用有剩余参数的函数时，传递的实参先赋值给非剩余参数，然后其余所有的实参（也就是“剩余”实参）存储在一个数组中变成剩余参数的值，最后一点非常重要：在一个函数体中，剩余参数的值总是一个数组。这个数组可能是空的，但是剩余参数永远不会是 undefined。（因此，从不会给剩余参数设置默认值，并且这也是不合法的。）</p>

<p>类似这种函数可以接收任意个数的实参，这种函数也称为“不定实参函数”，这个术语源自古老的C语言。</p>

<p>不要混淆 ... 定义函数的剩余参数和 ... 展开运算符，将在 §8.3.4 描述展开运算符在函数调用中的应用。</p>

<h3 id="toc_17">8.3.3 实参对象</h3>

<p>剩余参数是在 ES6 中加入的概念。在这之前，不定实参函数是用 Arguments 对象实现的：在函数体中，标识符 Arguments 是指向实参对象的引用。Arguments 对象是一个类数组对象（参照 §7.9），这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。下面的 max() 函数就是以前用 Arguments 对象代替剩余参数的例子：</p>

<pre><code class="language-javascript">function max(x) {
    let maxValue = -Infinity;
    // Loop through the arguments, looking for, and remembering, the biggest.
    for(let i = 0; i &lt; arguments.length; i++) {
        if (arguments[i] &gt; maxValue) maxValue = arguments[i];
    }
    // Return the biggest
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6)  // =&gt; 1000
</code></pre>

<p>Arguments 对象可追溯到 JavaScript 的最早时代，并带有一些奇怪的历史包袱，这使得它效率低下且难以优化，尤其是不在严格模式下。可能还会遇到一些代码使用 Arguments 对象，但是在编写新代码时要避免使用，可以用 ... 剩余函数来替代。Arguments 对象还有部分令人遗憾的遗产，在严格模式下，arguments 被视为保留字，不能声明具有该名称的局部变量来定义函数的参数。</p>

<h3 id="toc_18">8.3.4 函数调用时的展开运算符</h3>

<p>当需要单个值时，... 展开运算符用来拆包，或者说将元素从数组（或者其他的任何和迭代对象，例如字符串）中“展开”到上下文。我们已经在 §7.1.2 见到了展开运算符在数组字面量上的使用。展开运算符可以在函数调用中以同样方式使用：</p>

<pre><code class="language-javascript">let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers)  // =&gt; -1
</code></pre>

<p>注意 ... 不是一个真正的运算符，因为它不能通过计算来提供一个值。它是一个可以用在数组字面量和函数调用中的特殊的 JavaScript 语法。</p>

<p>在函数定义和函数调用中使用相同的 ... 语法时，和展开运算符有着相仿的效果。在 §8.3.2 中我们看到函数定义使用 ... 将复数个函数实参合并到一个数组中。剩余参数和展开运算符经常一同使用，就像下面这个函数：</p>

<pre><code class="language-javascript">// This function takes a function and returns a wrapped version
function timed(f) {
    return function(...args) {  // Collect args into a rest parameter array
        console.log(`Entering function ${f.name}`);
        let startTime = Date.now();
        try {
            // Pass all of our arguments to the wrapped function
            return f(...args);  // Spread the args back out again
        }
        finally {
            // Before we return the wrapped return value, print elapsed time.
            console.log(`Exiting ${f.name} after ${Date.now()-startTime}ms`);
        }
    };
}

// Compute the sum of the numbers between 1 and n by brute force
function benchmark(n) {
    let sum = 0;
    for(let i = 1; i &lt;= n; i++) sum += i;
    return sum;
}

// Now invoke the timed version of that test function
timed(benchmark)(1000000) // =&gt; 500000500000; this is the sum of the numbers
</code></pre>

<h3 id="toc_19">8.3.5 实参解构到形参中</h3>

<p>用实参列表调用函数时，实参的值最终赋值给函数定义的参数。函数调用初始化阶段非常像变量赋值。所以我们不必惊讶于可以将解构赋值（见 §3.10.3）用于函数。</p>

<p>如果一个函数的参数带有方括号，就说明函数要给每一个方括号传一个数组。在一个调用进程中，数组实参会被拆包传递给对应的参数。例如，假设我们将 2D 矢量表示为两个数字的数组，其中第一个元素是 X 坐标，第二个元素是 Y 坐标。用这个简单的数据结构，编写下面这个函数计算两个矢量的和：</p>

<pre><code class="language-javascript">function vectorAdd(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
}
vectorAdd([1,2], [3,4])  // =&gt; [4,6]
</code></pre>

<p>如果下面这种方式解构这两个矢量实参，这段代码将更容易理解：</p>

<pre><code class="language-javascript">function vectorAdd([x1,y1], [x2,y2]) { // Unpack 2 arguments into 4 parameters
    return [x1 + x2, y1 + y2];
}
vectorAdd([1,2], [3,4])  // =&gt; [4,6]
</code></pre>

<p>同样，如果定义一个函数时需要对象实参，你能对这个对象进行参数解构。再次实用矢量的例子，这一次，我们用 x 和 y 参数包装成对象来描述矢量：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} by a scalar value
function vectorMultiply({x, y}, scalar) {
    return { x: x*scalar, y: y*scalar };
}
vectorMultiply({x: 1, y: 2}, 2)  // =&gt; {x: 2, y: 4}
</code></pre>

<p>这个例子将一个简单的对象实参解构成两个参数是很简单的，因为参数的名字和我们在对象中使用的属性名是匹配的。当您需要将同一个名称的属性解构为具有不同名称的参数时，语法更加冗长和难懂。下面是一个矢量加法的例子，基于对象矢量的实现：</p>

<pre><code class="language-javascript">function vectorAdd(
    {x: x1, y: y1}, // Unpack 1st object into x1 and y1 params
    {x: x2, y: y2}  // Unpack 2nd object into x2 and y2 params
)
{
    return { x: x1 + x2, y: y1 + y2 };
}
vectorAdd({x: 1, y: 2}, {x: 3, y: 4})  // =&gt; {x: 4, y: 6}
</code></pre>

<p>像 {x:x1, y:y1} 的解构语法棘手的是记住哪一个是属性名哪一个是参数名。牢记解构赋值和解构函数调用的规则，声明的变量或参数在对象字面量中的位置固定。属性名总是在冒号的左边，参数（或变量）名在右边。</p>

<p>可以使用解构参数定义参数默认值。下面是适用于 2D 或 3D 矢量的矢量乘法：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} or {x,y,z} by a scalar value
function vectorMultiply({x, y, z=0}, scalar) {
    return { x: x*scalar, y: y*scalar, z: z*scalar };
}
vectorMultiply({x: 1, y: 2}, 2)  // =&gt; {x: 2, y: 4, z: 0}
</code></pre>

<p>一些语言（像 Python）允许函数的调用者以 <code>name=value</code> 型式指定实参，这在有很多可选实参或者参数列表长到难以记住正确的顺序时是非常方便的。JavaScript 不允许直接这样做，但可以通过解构对象实参到函数参数中。构思一个函数将指定数量的元素从一个数组复制到另一个数组中，可以随意地为每个数组指定起始偏移量。如下有五个可传入参数，其中一些有默认值，并且调用者很难记住参数的顺序来传递实参，可以像这样定义和调用 arraycopy() 方法：</p>

<pre><code class="language-javascript">function arraycopy({from, to=from, n=from.length, fromIndex=0, toIndex=0}) {
    let valuesToCopy = from.slice(fromIndex, fromIndex + n);
    to.splice(toIndex, 0, ...valuesToCopy);
    return to;
}
let a = [1,2,3,4,5], b = [9,8,7,6,5];
arraycopy({from: a, n: 3, to: b, toIndex: 4}) // =&gt; [9,8,7,6,1,2,3,5]
</code></pre>

<p>当解构一个数组，在其被拆包时，可以定义一个剩余参数将其余值放在数组中。 在方括号中的剩余参数和真正的函数中的剩余参数是完全不同的：</p>

<pre><code class="language-javascript">// This function expects an array argument. The first two elements of that
// array are unpacked into the x and y parameters. Any remaining elements
// are stored in the coords array. And any arguments after the first array
// are packed into the rest array.
function f([x, y, ...coords], ...rest) {
    return [x+y, ...rest, ...coords];  // Note: spread operator here
}
f([1, 2, 3, 4], 5, 6)   // =&gt; [3, 5, 6, 3, 4]
</code></pre>

<p>在 ES2018，也可以用剩余参数解构对象。剩余参数是一个没有解构的属性的对象。对象剩余参数经常与对象展开运算符连用，这是 ES2018 的新特性：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} or {x,y,z} by a scalar value, retain other props
function vectorMultiply({x, y, z=0, ...props}, scalar) {
    return { x: x*scalar, y: y*scalar, z: z*scalar, ...props };
}
vectorMultiply({x: 1, y: 2, w: -1}, 2)  // =&gt; {x: 2, y: 4, z: 0, w: -1}
</code></pre>

<p>最后，请记住，除了可以解构实参对象和数组，也可以解构数组对象，对象有数组属性，并且对象还有对象的属性。构思一个将圆表示为具有 x、y、半径和颜色属性的对象的图形代码，颜色属性是一个数组由 RGB 组成。你可以定义一个函数，该函数希望将单个圆对象传递给它，但其解构为六个单独的参数：</p>

<pre><code class="language-javascript">function drawCircle({x, y, radius, color: [r, g, b]}) {
    // Not yet implemented
}
</code></pre>

<p>如果函数实参解构比这更复杂，代码会变得更难读，而不是更简单。有时，显示地对对象属性访问和数组索引会让代码更清晰。</p>

<h3 id="toc_20">8.3.6 实参类型</h3>

<p>JavaScript 方法的形参并未声明类型，在形参传入函数体之前也未做任何类型检查。可以采用语义化的单词来给函数实参命名，并在函数注释给每一个实参详细描述，以此使代码自文本化。</p>

<p>§3.9 已经提到，JavaScript 在必要时会进行类型转换。因此如果函数期 望接收一个字符串实参，而调用函数时传入其他类型的值，所传入的值会在函数体内将其用做字符串的地方转换为字符串类型。所有的原始类型都可以转换为字符串，所有的对象都包含 toString() 方法（尽管不一定有用），所以这种场景下是不会有任何错误的。</p>

<p>然而事情不总是这样，回头看一下刚才提到的 arraycopy() 方法。这个方法期望获得一个或两个实参，并且这些实参的类型错误会导致函数执行失败。除非所写的私有函数只会被附近的代码调用，你应当添加类似的实参类型检查逻辑。因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错，相比而言，逻辑执行时的报错消息不甚清晰且更难处理。下面这个例子中的函数就做了这种类型检查：</p>

<pre><code class="language-javascript">// Return the sum of the elements an iterable object a.
// The elements of a must all be numbers.
function sum(a) {
    let total = 0;
    for(let element of a) { // Throws TypeError if a is not iterable
        if (typeof element !== &quot;number&quot;) {
            throw new TypeError(&quot;sum(): elements must be numbers&quot;);
        }
        total += element;
    }
    return total;
}
sum([1,2,3])    // =&gt; 6
sum(1, 2, 3);   // !TypeError: 1 is not iterable
sum([1,2,&quot;3&quot;]); // !TypeError: element 2 is not a number
</code></pre>

<h2 id="toc_21">8.4 函数作为值</h2>

<p>函数可以定义，也可以调用，这是函数最重要的特性。函数定义和调用是  JavaScript 的词法特性，对于其他大多数编程语言来说亦是如此。然而在 JavaScript 中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup></p>

<p>To understand how functions can be JavaScript data as well as JavaScript syntax, consider this function definition:</p>

<blockquote>
<p>为了便于理解 JavaScript 中的函数是如何用做 Javascript 数据以及 JavaScript 语法的，来看一下这样一个函数定义：</p>
</blockquote>

<pre><code class="language-javascript">function square(x) { return x*x; }
</code></pre>

<p>这个定义创建一个新的函数对象，并将其赋值给变量 square。函数的名字实际上是无形的，它（square）仅仅是变量的名称，这个变量是函数对象的引用。函数还可以赋值给其他的变量，并且仍可以正常工作：</p>

<pre><code class="language-javascript">let s = square;  // Now s refers to the same function that square does
square(4)        // =&gt; 16
s(4)             // =&gt; 16
</code></pre>

<p>除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性。当函数作为对象的属性调用时，函数就称为“方法”：</p>

<pre><code class="language-javascript">let o = {square: function(x) { return x*x; }}; // An object literal
let y = o.square(16);                          // y == 256
</code></pre>

<p>函数甚至不需要带名字，就像把它们赋值给数组元素：</p>

<pre><code class="language-javascript">let a = [x =&gt; x*x, 20]; // An array literal
a[0](a[1])              // =&gt; 400
</code></pre>

<p>上面的例子看起来很奇怪，但的确是合法的函数调用表达式！</p>

<p>举一个例子来说明将函数当作值来对待的益处，考虑下 Array.sort() 方法。这个方法用来对数组元素进行排序。因为排序的规则有很多（基于数值大小、字母表顺序、日期大小、从小到大、从大到小等），sort() 方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单：对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。这个函数参数使得 Array.sort() 具有更完美的通用性和无限可扩展性，它可以对任何类型的数据进行任意排序。§7.8.6 有示例代码。</p>

<p>例 8-1 展示了将函数用做值时的一些例子，这段代码可能会难读一些，但注释解释了代码的具体含义：</p>

<p>例 8-1：用函数做值</p>

<pre><code class="language-javascript">// We define some simple functions here
function add(x,y) { return x + y; }
function subtract(x,y) { return x - y; }
function multiply(x,y) { return x * y; }
function divide(x,y) { return x / y; }

// Here&#39;s a function that takes one of the preceding functions
// as an argument and invokes it on two operands
function operate(operator, operand1, operand2) {
    return operator(operand1, operand2);
}

// We could invoke this function like this to compute the value (2+3) + (4*5):
let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));

// For the sake of the example, we implement the simple functions again,
// this time within an object literal;
const operators = {
    add:      (x,y) =&gt; x+y,
    subtract: (x,y) =&gt; x-y,
    multiply: (x,y) =&gt; x*y,
    divide:   (x,y) =&gt; x/y,
    pow:      Math.pow  // This works for predefined functions too
};

// This function takes the name of an operator, looks up that operator
// in the object, and then invokes it on the supplied operands. Note
// the syntax used to invoke the operator function.
function operate2(operation, operand1, operand2) {
    if (typeof operators[operation] === &quot;function&quot;) {
        return operators[operation](operand1, operand2);
    }
    else throw &quot;unknown operator&quot;;
}

operate2(&quot;add&quot;, &quot;hello&quot;, operate2(&quot;add&quot;, &quot; &quot;, &quot;world&quot;)) // =&gt; &quot;hello world&quot;
operate2(&quot;pow&quot;, 10, 2)  // =&gt; 100
</code></pre>

<h3 id="toc_22">8.4.1 自定义函数属性</h3>

<p>JavaScript 中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。比如，假设你想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，为了做到这一点，函数必须能够跟踪它每次返回的值，而且这些值的信息需要在不同的函数调过程中持久化。可以将这些信息存放到全局变量中，但这并不是必需的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中，下面这个例子就实现了这样一个函数，每次调用函数都会返回一个唯一的整数：</p>

<pre><code class="language-javascript">// Initialize the counter property of the function object.
// Function declarations are hoisted so we really can
// do this assignment before the function declaration.
uniqueInteger.counter = 0;

// This function returns a different integer each time it is called.
// It uses a property of itself to remember the next value to be returned.
function uniqueInteger() {
    return uniqueInteger.counter++;  // Return and increment counter property
}
uniqueInteger()  // =&gt; 0
uniqueInteger()  // =&gt; 1
</code></pre>

<p>来看另外一个例子，下面这个函数 factorial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：</p>

<pre><code class="language-javascript">// Compute factorials and cache results as properties of the function itself.
function factorial(n) {
    if (Number.isInteger(n) &amp;&amp; n &gt; 0) {           // Positive integers only
        if (!(n in factorial)) {                  // If no cached result
            factorial[n] = n * factorial(n-1);    // Compute and cache it
        }
        return factorial[n];                      // Return the cached result
    } else {
        return NaN;                               // If input was bad
    }
}
factorial[1] = 1;  // Initialize the cache to hold this base case.
factorial(6)  // =&gt; 720
factorial[5]  // =&gt; 120; the call above caches this value
</code></pre>

<h2 id="toc_23">8.5 函数作为命名空间</h2>

<p>变量声明在函数内对于函数体外是不可见的。因此，有时定义函数作为临时命名空间非常有用，您可以在其中定义变量而不弄乱全局命名空间。</p>

<p>比如，假设你写了一段 JavaScript 模块代码，这段代码将要用在不同的 JavaScript 程序中（对于客户端 JavaScript 来讲通常是用在各种各样的网页中）。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量：</p>

<pre><code class="language-javascript">function chunkNamespace() {
    // Chunk of code goes here
    // Any variables defined in the chunk are local to this function
    // instead of cluttering up the global namespace.
}
chunkNamespace();  // But don&#39;t forget to invoke the function!
</code></pre>

<p>这段代码仅仅定义了一个单独的全局变量：名为 chunkNamespace 的函数。如果还是太麻烦，可以用一个单独的表达式定义一个匿名函数并调用它：</p>

<pre><code class="language-javascript">(function() {  // chunkNamespace() function rewritten as an unnamed expression.
    // Chunk of code goes here
}());          // End the function literal and invoke it now.
</code></pre>

<p>这种定义匿名函数并立即在单个表达式中调用它的写法非常常见，并给它起了个名字“匿名调用函数表达式”。注意上面代码的圆括号的用法，function 之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript 解释器会试图将关键字 function 解析为函数声明语句。使用圆括号 JavaScript 解释器才会正确地将其解析为函数定义表达式。使用前导括号也有助于人类阅读时区分函数定义是立即执行还是供以后使用。</p>

<p>函数用作命名空间很常用，在命名空间函数中定义一个或多个函数使用其中的变量，然后将他们作为函数命名空间的返回值。这样的函数称为闭包，它们是下一节的主题。</p>

<h2 id="toc_24">8.6 闭包</h2>

<p>和其他大多数现代编程语言一样，JavaScript 也采用词法作用域。也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须包括对函数定义出现的作用域的引用。将函数对象可和作用域相互关联起来（一对变量的绑定），函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p>

<p>从技术的角度讲，所有的 JavaScript 函数都是闭包，但是大多数函数调用和定义在同一个作用域内，通常不会注意这里有涉及到闭包。当调用函数不和其定义处于同一作用域内时，事情就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在 JavaScript 中非常常见。当你第一次碰到闭包时可能会觉得非常让人费解，一旦你理解掌握了闭包之后，就能非常自如地使用它了，了解这一点至关重要。</p>

<p>理解闭包首先要了解嵌套函数的词法作用域规则。看一下这段代码：</p>

<pre><code class="language-javascript">let scope = &quot;global scope&quot;;          // A global variable
function checkscope() {
    let scope = &quot;local scope&quot;;       // A local variable
    function f() { return scope; }   // Return the value in scope here
    return f();
}
checkscope()                         // =&gt; &quot;local scope&quot;
</code></pre>

<p>checkscope() 函数声明了一个局部变量，然后定义并执行了一个函数 f() ，函数 f() 返回了这个变量的值，最后将函数 f() 的执行结果返回。你应当非常清楚为什么调用 checkscope() 会返回 local scope。现在我们对这段代码做一点改动。你知道这段代码返回什么吗？</p>

<pre><code class="language-javascript">let scope = &quot;global scope&quot;;          // A global variable
function checkscope() {
    let scope = &quot;local scope&quot;;       // A local variable
    function f() { return scope; }   // Return the value in scope here
    return f;
}
let s = checkscope()();              // What does this return?
</code></pre>

<p>在这段代码中，我们将函数内的一对圆括号移动到了 checkscope() 之后。checkscope() 现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？</p>

<p>回想一下词法作用域的基本规则：JavaScript 函数的执行用到了作用域，这个作用域是函数定义的时候创建的。嵌套的函数 f() 定义在变量 scope 绑定的值是“local scope”的作用域里，这个绑定无论 f 函数在何处调用都依然有效。因此最后一行代码返回“local scope”，而不是“global scope”。简言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到它们的外部函数所绑定的局部变量（和参数）。</p>

<p>在 §8.4.1 中定义了 uniqueInteger() 函数，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致 uniquenterger() 函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用做私有状态。下面是如何用立即调用函数表达式重写 uniqueInteger() 来定义命名空间和闭包来保持其状态私有化：</p>

<pre><code class="language-javascript">let uniqueInteger = (function() {  // Define and invoke
    let counter = 0;               // Private state of function below
    return function() { return counter++; };
}());
uniqueInteger()  // =&gt; 0
uniqueInteger()  // =&gt; 1
</code></pre>

<p>你需要仔细阅读这段代码才能理解其含义。粗略来看，第一行代码看起来像将函数赋值给一个变量 uniqueInteger，实际上，这段代码定义了一个立即调用的函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量 uniqueInteger。现在，我们来看函数体，这个函数的返回值是另外一个函数。这是一个嵌套的函数，我们将它赋值给变量 uniqueInteger。嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的 counter 变量。当外部函数返回之后，其他任何代码都无法访问 counter 变量：只有内部的函数才能访问到它。</p>

<p>像 counter 一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域，看一下这段代码：</p>

<pre><code class="language-javascript">function counter() {
    let n = 0;
    return {
        count: function() { return n++; },
        reset: function() { n = 0; }
    };
}

let c = counter(), d = counter();   // Create two counters
c.count()                           // =&gt; 0
d.count()                           // =&gt; 0: they count independently
c.reset();                          // reset() and count() methods share state
c.count()                           // =&gt; 0: because we reset c
d.count()                           // =&gt; 1: d was not reset
</code></pre>

<p>counter() 函数返回了一个“计数器”对象，这个对象包含两个方法：count() 返回下一个整数，reset() 重置内部状态。首先要理解，这两个方法都可以访问私有变量n。再者，每次调用 counter() 都会创建一个新的作用域链和一个新的私有变量。因此，如果调用 counter() 两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的 count() 或 reset() 不会影响到另外一个对象。</p>

<p>从技术角度看，其实可以将这个闭包合并为属性存取器方法 getter 和 setter。下面这段代码所示的 counter() 函数的版本是 §6.10.6 中代码的变种，所不同的是，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现：</p>

<pre><code class="language-javascript">function counter(n) {  // Function argument n is the private variable
    return {
        // Property getter method returns and increments private counter var.
        get count() { return n++; },
        // Property setter doesn&#39;t allow the value of n to decrease
        set count(m) {
            if (m &gt; n) n = m;
            else throw Error(&quot;count can only be set to a larger value&quot;);
        }
    };
}

let c = counter(1000);
c.count            // =&gt; 1000
c.count            // =&gt; 1001
c.count = 2000;
c.count            // =&gt; 2000
c.count = 2000;    // !Error: count can only be set to a larger value
</code></pre>

<p>需要注意的是，这个版本的 counter() 函数并未声明局部变量，而只是使用参数 n 来保存私有状态并与属性存取器方法共享。这样的话，调用 counter() 的函数就可以指定私有变量的初始值了。</p>

<p>例 8-2是这种使用闭包技术来共享的私有状态的通用做法。这个例子定义了 addPrivateProperty() 函数，这个函数定义了一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值。它将这些嵌套函数添加为所指定对象的方法：</p>

<p>例 8-2：利用闭包实现的私有属性存取器方法</p>

<pre><code class="language-javascript">// This function adds property accessor methods for a property with
// the specified name to the object o. The methods are named get&lt;name&gt;
// and set&lt;name&gt;. If a predicate function is supplied, the setter
// method uses it to test its argument for validity before storing it.
// If the predicate returns false, the setter method throws an exception.
//
// The unusual thing about this function is that the property value
// that is manipulated by the getter and setter methods is not stored in
// the object o. Instead, the value is stored only in a local variable
// in this function. The getter and setter methods are also defined
// locally to this function and therefore have access to this local variable.
// This means that the value is private to the two accessor methods, and it
// cannot be set or modified except through the setter method.
function addPrivateProperty(o, name, predicate) {
    let value;  // This is the property value

    // The getter method simply returns the value.
    o[`get${name}`] = function() { return value; };

    // The setter method stores the value or throws an exception if
    // the predicate rejects the value.
    o[`set${name}`] = function(v) {
        if (predicate &amp;&amp; !predicate(v)) {
            throw new TypeError(`set${name}: invalid value ${v}`);
        } else {
            value = v;
        }
    };
}

// The following code demonstrates the addPrivateProperty() method.
let o = {};  // Here is an empty object

// Add property accessor methods getName and setName()
// Ensure that only string values are allowed
addPrivateProperty(o, &quot;Name&quot;, x =&gt; typeof x === &quot;string&quot;);

o.setName(&quot;Frank&quot;);       // Set the property value
o.getName()               // =&gt; &quot;Frank&quot;
o.setName(0);             // !TypeError: try to set a value of the wrong type
</code></pre>

<p>我们已经看到了很多例子，在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包，了解这一点也很重要。看一下下面这段代码：</p>

<pre><code class="language-javascript">// This function returns a function that always returns v
function constfunc(v) { return () =&gt; v; }

// Create an array of constant functions:
let funcs = [];
for(var i = 0; i &lt; 10; i++) funcs[i] = constfunc(i);

// The function at array element 5 returns the value 5.
funcs[5]()    // =&gt; 5
</code></pre>

<p>这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：</p>

<pre><code class="language-javascript">// Return an array of functions that return the values 0-9
function constfuncs() {
    let funcs = [];
    for(var i = 0; i &lt; 10; i++) {
        funcs[i] = () =&gt; i;
    }
    return funcs;
}

let funcs = constfuncs();
funcs[5]()    // =&gt; 10; Why doesn&#39;t this return 5?
</code></pre>

<p>上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量 i。当 constfuncs() 返回时，变量 i 的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域都是“活动的”，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照。从根本上讲，这里的问题是，使用 var 声明的变量，它的定义贯穿整个函数。我们的 for 循环使用 var i 声明循环变量，因此变量 i 在整个函数中都有定义，而不是更狭义地作用于循环的主体。该代码演示了 ES6 之前的常见 Bug 类别，但在 ES6 中引入块级变量作用域解决了这个问题。如果我们只是用 let 或 const 替换 var， 那么问题就消失了。由于 let 和 const 是块级作用域，因此循环的每个迭代都定义了一个独立于所有其他迭代的作用域，并且每个作用域都有其自己的独立绑定 i。</p>

<p>书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，而不是变量。正如之前讨论的，箭头函数从包含它们的函数中继承 this 值，但是用 function 关键字定义的函数不是。所以如果写一个闭包需要使用包含它的函数的 this 值，要在闭包返回之前使用箭头函数或者用调用 bind()，或者将 this 值赋值给一个变量，这样你的闭包会继承它：</p>

<pre><code class="language-javascript">const self = this;  // Make the this value available to nested functions
</code></pre>

<h2 id="toc_25">8.7 函数属性、方法、和构造函数</h2>

<p>我们看到在 JavaScript 程序中，函数是值。对函数执行 typeof 运算会返回字符串“function”，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用 Function() 构造函数来创建新的函数对象。接下来几节就会着重介绍函数 length、name 和 prototype 属性；call()、 apply()、 bind() 和 toString() 方法；以及 Function() 构造函数。</p>

<h3 id="toc_26">8.7.1 length 属性</h3>

<p>函数的只读属性 length 指定函数参数个数--声明在其参数列表中的参数个数，大多数函数期望的实参个数。如果一个函数有一个剩余函数，它的参数个数不被计算入 length 属性。（经测试，可选参数也不计算 length。）</p>

<h3 id="toc_27">8.7.2 name 属性</h3>

<p>如果使用名称定义函数，只读属性 name 指定函数定义时用的名称，或未命名函数表达式在首次创建时分配给的变量或属性的名称。此属性在编写调试或错误消息时很有用。</p>

<h3 id="toc_28">8.7.3 prototype 属性</h3>

<p>所有函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做原型对象。每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。§6.2.3 讨论了原型和 prototype 属性，在第9章里会有进一步讨论。</p>

<h3 id="toc_29">8.7.4 call() 和 apply() 方法</h3>

<p>我们可以将 call() 和 apply () 看做是某个对象的方法，通过调用方法的形式来间接调用（见 §8.2.4）函数。call() 和 apply() 的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内变成 this 关键字的值。要想以对象 o 的方法来调用函数 f()（没有实参传递），可以这样使用 call() 和 apply()：</p>

<pre><code class="language-javascript">f.call(o);
f.apply(o);
</code></pre>

<p>每行代码和下面代码的功能类似（假设对象 o 中预先不存在名为 m 的属性）:</p>

<pre><code class="language-javascript">o.m = f;     // Make f a temporary method of o.
o.m();       // Invoke it, passing no arguments.
delete o.m;  // Remove the temporary method.
</code></pre>

<p>不要忘了，箭头函数从它定义的位置的上下文继承 this 值。这不能被 call() 和 apply() 方法重写。如果通过箭头函数调用它俩任何一个方法，第一个实参实际上都被忽略。</p>

<p>对于 call() 来说，除了第一个作为调用上下文实参，之后的所有实参就是要传入待调用函数的值（并且，这部分实参对于箭头函数来说不被忽略）。比如，以对象 o 的方法的形式调用函数 f()，并传入两个数，可以使用这样的代码：</p>

<pre><code class="language-javascript">f.call(o, 1, 2);
</code></pre>

<p>apply() 方法和 call() 类似，但传入实参的形式和 call() 有所不同，它的实参都放入一个数组中：</p>

<pre><code class="language-javascript">f.apply(o, [1,2]);
</code></pre>

<p>如果一个函数的实参可以是任意数量，用 apply() 方法允许你传入的参数数组可以是任意长度的。在 ES6 之后，我们可以用展开运算符，但是在 ES5 的代码中你可以看到这种情况是用 apply() 来替代。比如，不用展开运算符找出数组中最大的数值元素，调用 Math.max() 方法的时候可以给  apply() 传入一个包含任意个元素的数组：</p>

<pre><code class="language-javascript">let biggest = Math.max.apply(Math, arrayOfNumbers);
</code></pre>

<p>下面定义的 trace() 与 §8.3.4 中定义的 timed() 函数类似，但是它对方法有效而不是函数。它使用 apply() 方法而不是展开运算符，通过这样做，它能够调用具有相同参数和与被包装方法相同的 this 值的包装方法。</p>

<pre><code class="language-javascript">// Replace the method named m of the object o with a version that logs
// messages before and after invoking the original method.
function trace(o, m) {
    let original = o[m];         // Remember original method in the closure.
    o[m] = function(...args) {   // Now define the new method.
        console.log(new Date(), &quot;Entering:&quot;, m);      // Log message.
        let result = original.apply(this, args);      // Invoke original.
        console.log(new Date(), &quot;Exiting:&quot;, m);       // Log message.
        return result;                                // Return result.
    };
}
</code></pre>

<h3 id="toc_30">8.7.5 bind() 方法</h3>

<p>The primary purpose of bind() is to bind a function to an object. When you invoke the bind() method on a function f and pass an object o, the method returns a new function. Invoking the new function (as a function) invokes the original function f as a method of o. Any arguments you pass to the new function are passed to the original function. For example:</p>

<blockquote>
<p>bind() 方法的主要作用就是将函数绑定至某个对象。当在函数 f() 上调用 bind() 方法并传入一个对象 o 作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数 f() 当做 o 的方法来调用。传入新函数的任何实参都将传入原始函数，比如：</p>
</blockquote>

<pre><code class="language-javascript">function f(y) { return this.x + y; } // This function needs to be bound
let o = { x: 1 };                    // An object we&#39;ll bind to
let g = f.bind(o);                   // Calling g(x) invokes f() on o
g(2)                                 // =&gt; 3
let p = { x: 10, g };                // Invoke g() as a method of this object
p.g(2)                               // =&gt; 3: g is still bound to o, not p.
</code></pre>

<p>箭头函数从它们定义的上下文中继承 this 值，并且其不可被 bind() 方法重写，所以如果上面的代码用箭头函数定义函数 f()，这个绑定不会生效。调用 bind() 方法的最常用场景是让不带箭头的函数的行为像箭头函数一样，所以实际上绑定箭头函数的 this 局限性并不是一个问题。</p>

<p>但是 bind() 方法不仅仅是将函数绑定至一个对象。它还附带一些其他应用：除了第一个实参之外，传入 bind() 的实参也会绑定至 this 值。这个附带的应用在箭头函数上也同样生效。是一种常见的函数式编程技术，有时也被称为“柯里化”。参照下面这个例子中的 bind() 方法的实现：</p>

<pre><code class="language-javascript">let sum = (x,y) =&gt; x + y;      // Return the sum of 2 args
let succ = sum.bind(null, 1);  // Bind the first argument to 1
succ(2)  // =&gt; 3: x is bound to 1, and we pass 2 for the y argument

function f(y,z) { return this.x + y + z; }
let g = f.bind({x: 1}, 2);     // Bind this and y
g(3)     // =&gt; 6: this.x is bound to 1, y is bound to 2 and z is 3
</code></pre>

<p>bind() 返回函数的名称属性是调用 bind() 的函数的名称属性前面加上前缀为单词&quot;bound&quot;。</p>

<h3 id="toc_31">8.7.6 toString() 方法</h3>

<p>和所有的 JavaScript 对象一样，函数也有 toString() 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的 toString() 方法的实现都返回函数的完整源码。内置函数往往返回一个类似”[native code]”的字符串作为函数体。</p>

<h3 id="toc_32">8.7.7 Function() 构造函数</h3>

<p>因为函数是对象，有一个 Function() 构造函数可以用来创建新的函数：</p>

<pre><code class="language-javascript">const f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);
</code></pre>

<p>这一行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价：</p>

<pre><code class="language-javascript">const f = function(x, y) { return x*y; };
</code></pre>

<p>Function() 构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体——即可。</p>

<p>注意，Function() 构造函数并不需要通过传入实参以指定函数名。就像函数字面量一样，Function() 构造函数创建一个匿名函数。</p>

<p>关于 Function() 构造函数有几点需要特别注意：</p>

<p>Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数。</p>

<p>每次调用 Function() 构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。</p>

<p>最后一点，也是关于 Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，如下面代码所示：</p>

<pre><code class="language-javascript">let scope = &quot;global&quot;;
function constructFunction() {
    let scope = &quot;local&quot;;
    return new Function(&quot;return scope&quot;);  // Doesn&#39;t capture local scope!
}
// This line returns &quot;global&quot; because the function returned by the
// Function() constructor does not use the local scope.
constructFunction()()  // =&gt; &quot;global&quot;
</code></pre>

<p>我们可以将 Function() 构造函数认为是在全局作用域中执行的 eval()（见  §4.12.2），eval() 可以在自己的私有作用域内定义新变量和函数，Function() 构造函数在实际编程过程中很少会用到。</p>

<h2 id="toc_33">8.8 函数式编程</h2>

<p>和 Lisp、Haskell 不同，JavaScript 并非函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术。数组方法诸如 map() 和 reduce() 就可以非常适合用于函数式编程风格。接下来的几节将会着重介绍 JavaScript 中的函数式编程技术。函数式编程旨在扩展对 JavaScript 函数功能功能的探索，而不是为了良好的编程风格。</p>

<h3 id="toc_34">8.8.1 用函数处理数组</h3>

<p>假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样：</p>

<pre><code class="language-javascript">let data = [1,1,3,5,5];  // This is our array of numbers

// The mean is the sum of the elements divided by the number of elements
let total = 0;
for(let i = 0; i &lt; data.length; i++) total += data[i];
let mean = total/data.length;  // mean == 3; The mean of our data is 3

// To compute the standard deviation, we first sum the squares of
// the deviation of each element from the mean.
total = 0;
for(let i = 0; i &lt; data.length; i++) {
    let deviation = data[i] - mean;
    total += deviation * deviation;
}
let stddev = Math.sqrt(total/(data.length-1));  // stddev == 2
</code></pre>

<p>可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其简洁（参照 §7.8.1 来查看这些方法）：</p>

<pre><code class="language-javascript">// First, define two simple functions
const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;

// Then use those functions with Array methods to compute mean and stddev
let data = [1,1,3,5,5];
let mean = data.reduce(sum)/data.length;  // mean == 3
let deviations = data.map(x =&gt; x-mean);
let stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1));
stddev  // =&gt; 2
</code></pre>

<p>这个新版本的代码看起来跟第一版有很大不同，但是它仍然调用对象的方法，所以它还是面向对象编程。接下来用函数版本的 map() 和 reduce() 方法：</p>

<pre><code class="language-javascript">const map = function(a, ...args) { return a.map(...args); };
const reduce = function(a, ...args) { return a.reduce(...args); };
</code></pre>

<p>用这两个函数定义了 map() 和 reduce()，我们计算平均值和标准差变成这样：</p>

<pre><code class="language-javascript">const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;

let data = [1,1,3,5,5];
let mean = reduce(data, sum)/data.length;
let deviations = map(data, x =&gt; x-mean);
let stddev = Math.sqrt(reduce(map(deviations, square), sum)/(data.length-1));
stddev  // =&gt; 2
</code></pre>

<h3 id="toc_35">8.8.2 高阶函数</h3>

<p>所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数。来看这个例子：</p>

<pre><code class="language-javascript">// This higher-order function returns a new function that passes its
// arguments to f and returns the logical negation of f&#39;s return value;
function not(f) {
    return function(...args) {             // Return a new function
        let result = f.apply(this, args);  // that calls f
        return !result;                    // and negates its result.
    };
}

const even = x =&gt; x % 2 === 0; // A function to determine if a number is even
const odd = not(even);         // A new function that does the opposite
[1,1,3,5,5].every(odd)         // =&gt; true: every element of the array is odd
</code></pre>

<p>上面的 not() 函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的 mapper() 函数，它也是接收一个函数作为实参，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的 map() 函数，但要首先理解这两个函数有哪里不 同，理解这一点至关重要：</p>

<pre><code class="language-javascript">// Return a function that expects an array argument and applies f to
// each element, returning the array of return values.
// Contrast this with the map() function from earlier.
function mapper(f) {
    return a =&gt; map(a, f);
}

const increment = x =&gt; x+1;
const incrementAll = mapper(increment);
incrementAll([1,2,3])  // =&gt; [2,3,4]
</code></pre>

<p>这里是一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())：</p>

<pre><code class="language-javascript">// Return a new function that computes f(g(...)).
// The returned function h passes all of its arguments to g, then passes
// the return value of g to f, then returns the return value of f.
// Both f and g are invoked with the same this value as h was invoked with.
function compose(f, g) {
    return function(...args) {
        // We use call for f because we&#39;re passing a single value and
        // apply for g because we&#39;re passing an array of values.
        return f.call(this, g.apply(this, args));
    };
}

const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;
compose(square, sum)(2,3)  // =&gt; 25; the square of the sum
</code></pre>

<p>本章后续几节中定义了 partial() 和 memoize() 函数，这两个函数是非常重要的高阶函数。</p>

<h3 id="toc_36">8.8.3 局部应用函数</h3>

<p>函数 f()（见 §8.7.5）的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数“绑定至”对象并传入一部分参数。bind() 方法只是将实参放在（完整实参列表的）左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在（完整实参列表的）右侧：</p>

<pre><code class="language-javascript">// The arguments to this function are passed on the left
function partialLeft(f, ...outerArgs) {
    return function(...innerArgs) { // Return this function
        let args = [...outerArgs, ...innerArgs]; // Build the argument list
        return f.apply(this, args);              // Then invoke f with it
    };
}

// The arguments to this function are passed on the right
function partialRight(f, ...outerArgs) {
    return function(...innerArgs) {  // Return this function
        let args = [...innerArgs, ...outerArgs]; // Build the argument list
        return f.apply(this, args);              // Then invoke f with it
    };
}

// The arguments to this function serve as a template. Undefined values
// in the argument list are filled in with values from the inner set.
function partial(f, ...outerArgs) {
    return function(...innerArgs) {
        let args = [...outerArgs]; // local copy of outer args template
        let innerIndex=0;          // which inner arg is next
        // Loop through the args, filling in undefined values from inner args
        for(let i = 0; i &lt; args.length; i++) {
            if (args[i] === undefined) args[i] = innerArgs[innerIndex++];
        }
        // Now append any remaining inner arguments
        args.push(...innerArgs.slice(innerIndex));
        return f.apply(this, args);
    };
}

// Here is a function with three arguments
const f = function(x,y,z) { return x * (y - z); };
// Notice how these three partial applications differ
partialLeft(f, 2)(3,4)         // =&gt; -2: Bind first argument: 2 * (3 - 4)
partialRight(f, 2)(3,4)        // =&gt;  6: Bind last argument: 3 * (4 - 2)
partial(f, undefined, 2)(3,4)  // =&gt; -6: Bind middle argument: 3 * (2 - 4)
</code></pre>

<p>利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数，参照下面这个例子：</p>

<pre><code class="language-javascript">const increment = partialLeft(sum, 1);
const cuberoot = partialRight(Math.pow, 1/3);
cuberoot(increment(26))  // =&gt; 3
</code></pre>

<p>当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了 not() 函数，它用到了刚才提到的不完全调用：</p>

<pre><code class="language-javascript">const not = partialLeft(compose, x =&gt; !x);
const even = x =&gt; x % 2 === 0;
const odd = not(even);
const isNumber = not(isNaN);
odd(3) &amp;&amp; isNumber(2)  // =&gt; true
</code></pre>

<p>我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程：</p>

<pre><code class="language-javascript">// sum() and square() functions are defined above. Here are some more:
const product = (x,y) =&gt; x*y;
const neg = partial(product, -1);
const sqrt = partial(Math.pow, undefined, .5);
const reciprocal = partial(Math.pow, undefined, neg(1));

// Now compute the mean and standard deviation.
let data = [1,1,3,5,5];   // Our data
let mean = product(reduce(data, sum), reciprocal(data.length));
let stddev = sqrt(product(reduce(map(data,
                                     compose(square,
                                             partial(sum, neg(mean)))),
                                 sum),
                          reciprocal(sum(data.length,neg(1)))));
[mean, stddev]  // =&gt; [3, 2]
</code></pre>

<p>注意，这段代码计算平均值和标准差完全是函数调用;没有涉及运算符，并且括号的数量增长如此之大让 JavaScript 开始看起来像 Lisp 代码。同样，这不是我提倡的 JavaScript 编程风格，但它是一个有趣的练习，看看 JavaScript 代码的功能有多深。</p>

<h3 id="toc_37">8.8.4 记忆（Memoization）</h3>

<p>在 §8.4.1 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数:</p>

<pre><code class="language-javascript">// Return a memoized version of f.
// It only works if arguments to f all have distinct string representations.
function memoize(f) {
    const cache = new Map();  // Value cache stored in the closure.

    return function(...args) {
        // Create a string version of the arguments to use as a cache key.
        let key = args.length + args.join(&quot;+&quot;);
        if (cache.has(key)) {
            return cache.get(key);
        } else {
            let result = f.apply(this, args);
            cache.set(key, result);
            return result;
        }
    };
}
</code></pre>

<p>memorize() 函数创建一个新的对象，这个对象被当做缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用 memorize()：</p>

<pre><code class="language-javascript">// Return the Greatest Common Divisor of two integers using the Euclidian
// algorithm: http://en.wikipedia.org/wiki/Euclidean_algorithm
function gcd(a,b) {  // Type checking for a and b has been omitted
    if (a &lt; b) {           // Ensure that a &gt;= b when we start
        [a, b] = [b, a];   // Destructuring assignment to swap variables
    }
    while(b !== 0) {       // This is Euclid&#39;s algorithm for GCD
        [a, b] = [b, a%b];
    }
    return a;
}

const gcdmemo = memoize(gcd);
gcdmemo(85, 187)  // =&gt; 17

// Note that when we write a recursive function that we will be memoizing,
// we typically want to recurse to the memoized version, not the original.
const factorial = memoize(function(n) {
    return (n &lt;= 1) ? 1 : n * factorial(n-1);
});
factorial(5)      // =&gt; 120: also caches values for 4, 3, 2 and 1.
</code></pre>

<h2 id="toc_38">8.9 总结</h2>

<p>本章关键点总结如下：</p>

<ul>
<li>可以用函数关键字和 ES6 =&gt; 箭头函数来定义函数。</li>
<li>可以以方法和构造函数的方式调用函数。</li>
<li>一些 ES6 特性，允许参数设定默认值，可以用剩余参数将多个参数搜集到一个数组中，可以解构对象和数组实参到函数参数中。</li>
<li>可以用 ... 展开运算符传递数组元素或者其他可迭代对象到函数调用。</li>
<li>封闭函数内部定义并返回的函数保留对其词法作用域的访问，因此可以读取和写入外部函数内定义的变量。用这种方式使用的函数称为闭包，这是一种值得理解的技术。</li>
<li>函数是可由 JavaScript 操作的对象，这使 JavaScript 支持函数式编程。</li>
</ul>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>这个术语最初是由 Martin Fowler 提出的，参见<a href="http://martinfowler.com/dslwip/MethodChaining.html%E3%80%82">http://martinfowler.com/dslwip/MethodChaining.html。</a>&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>这看起来不足为奇，但如果你对 Python 很熟悉，你会发现 Python 中的函数是程序的一 部分，但无法被程序操作。&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>这似乎并不是一个特别有趣的点，除非你熟悉更多的静态语言，其中函数是程序的一部分，但不能由程序操作。&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 9 章 类]]></title>
    <link href="blog.2019919.top/16118386693796.html"/>
    <updated>2021-01-28T20:57:49+08:00</updated>
    <id>blog.2019919.top/16118386693796.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">9.1 类和原型</a>
</li>
<li>
<a href="#toc_1">9.2 类和构造函数</a>
<ul>
<li>
<a href="#toc_2">9.2.1 构造函数、类标识和 instanceof</a>
</li>
<li>
<a href="#toc_3">9.2.2 constructor 属性</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">9.3 使用 class 关键字的类</a>
<ul>
<li>
<a href="#toc_5">9.3.1 静态方法</a>
</li>
<li>
<a href="#toc_6">9.3.2 Getter、Setter 和其他方法</a>
</li>
<li>
<a href="#toc_7">9.3.3 公有、私有和静态字段</a>
</li>
<li>
<a href="#toc_8">9.3.4 示例：一个复数类</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">9.4 为类添加方法</a>
</li>
<li>
<a href="#toc_10">9.5 子类</a>
<ul>
<li>
<a href="#toc_11">9.5.1 子类和原型</a>
</li>
<li>
<a href="#toc_12">9.5.2 子类与 extends 和 super</a>
</li>
<li>
<a href="#toc_13">9.5.3 委托代替继承</a>
</li>
<li>
<a href="#toc_14">9.5.4 Hierarchies 类和抽象类</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">9.6 总结</a>
</li>
</ul>


<p>第 6 章详细介绍了 JavaScript 对象，每个 JavaScript 对象都是一个属性集合，相互之间没有任何联系。在 JavaScript 中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。例如，假设有一个名为 Complex 的类用来表示复数，同时还定义了一些复数运算。一个 Complex 实例应当包含复数的实部和虚部（状态），同样 Complex 类还会定义复数的加法和乘法操作（行为）。</p>

<p>在 JavaScript 中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。JavaScript 原型和继承在 §6.2.3 和 §6.3.2 节中有详细讨论，为了更好地理解本章的内容，请务必首先阅读这两个章节。本章将会在 §9.1 中对原型做进一步讨论。</p>

<p>如果两个对象继承自同一个原型，往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。我们已经在 §4.6、§6.2.2 和 §8.2.3 节中详细讲解了构造函数，§9.2 会有进一步讨论。</p>

<p>JavaScript 一直允许定义类。ES6 引入了全新的语法（包括 class 关键字），使创建类更加容易。这些新的 JavaScript 类的工作方式与旧式类相同，本章首先解释创建类的旧方法，因为这更清楚地展示了类是如何工作的。一旦我们解释了这些基本原理，我们将改变并开始使用新的、简化的类定义语法。</p>

<p>如果你对诸如 Java 和 C++ 这种强类型的面向对象编程比较熟悉，你会发现 JavaScript 中的类和 Java 以及 C++ 中的类有很大不同。尽管在写法上类似，而且在 JavaScript 中也能“模拟”出很多经典的类的特性，但是最好要理解 JavaScript 的类和基于原型的继承机制，以及和传统的 Java（当然还有类似 Java 的语言）的类和基于类的继承机制的不同之处。</p>

<h2 id="toc_0">9.1 类和原型</h2>

<p>在 JavaScript 中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在示例 6-1 中定义了 inherit() 函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过 inherit() 函数创建一个继承自它的对象，这样就定义了一个 JavaScript 类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象，参照示例 9-1。示例 9-1 给一个表示“值的范围”的类定义了原型对象，还定义了一个“工厂”函数用以创建并初始化类的实例。</p>

<p>示例 9-1：一个简单的 JavaScript 类</p>

<pre><code class="language-javascript">// This is a factory function that returns a new range object.
function range(from, to) {
    // Use Object.create() to create an object that inherits from the
    // prototype object defined below.  The prototype object is stored as
    // a property of this function, and defines the shared methods (behavior)
    // for all range objects.
    let r = Object.create(range.methods);

    // Store the start and end points (state) of this new range object.
    // These are noninherited properties that are unique to this object.
    r.from = from;
    r.to = to;

    // Finally return the new object
    return r;
}

// This prototype object defines methods inherited by all range objects.
range.methods = {
    // Return true if x is in the range, false otherwise
    // This method works for textual and Date ranges as well as numeric.
    includes(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; },

    // A generator function that makes instances of the class iterable.
    // Note that it only works for numeric ranges.
    *[Symbol.iterator]() {
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
    },

    // Return a string representation of the range
    toString() { return &quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;; }
};

// Here are example uses of a range object.
let r = range(1,3);      // Create a range object
r.includes(2)            // =&gt; true: 2 is in the range
r.toString()             // =&gt; &quot;(1...3)&quot;
[...r]                   // =&gt; [1, 2, 3]; convert to an array via iterator
</code></pre>

<p>在示例 9-1 的代码中有一下几点值得注意：</p>

<p>这段代码定义了一个工厂函数 range() 用来创建一个新的 Range 对象。</p>

<p>用 range() 函数的 methods 属性来存放定义类的原型对象。只是将原型对象随意的放在一个地方，并不是一个规约或者习惯。</p>

<p>range() 函数在每个 Range 对象中都定义 from 和 to 属性。它们是非共享、非继承属性，是每个独立的 Range 对象的独特自有状态。</p>

<p>range.methods 对象应用了 ES6 的速记语法来定义方法，这是为什么没有看到 function 关键字的原因。（参照 §6.10.5 来复习对象字面量速记方法语法。）</p>

<p>原型中的一个方法 Symbol.iterator 使用了计算属性名（§6.10.2），表明它是为 Range 对象定义一个迭代器。方法名称带有一个前缀 *，标识它是一个生成器函数而不是普通的函数。迭代器和生成器在第 12 章会详细描述。现在，只需要知道 Range 类的实例可以用 for/of 循环和可以用 ... 展开运算符。</p>

<p>定义在 range.methods 中的共享继承方法都使用在 range() 工厂函数初始化的 from 和 to 属性。在这些方法被调用时，为了引用 from 和 to 属性，都使用 this 关键字来获取对象的引用。this 这种用法是任何类中方法的基本特征。</p>

<h2 id="toc_1">9.2 类和构造函数</h2>

<p>示例 9-1 展示了一个简单方式来定义一个 JavaScript 类。但是这种方法并不常用，因为它没有定义一个构造函数。构造函数是用来初始化新建对象的。如 §8.2.3 中所述构造函数用 new 关键字来调用。使用 new 调用构造函数会自动创建一个新对象，因此构造函数本身只需初始化这个新对象的状态即可。§6.2.3 介绍并强调了虽然所有对象都有原型，但是只有一部分对象有一个 prototype 属性。最后，我们可以澄清这一点：是函数对象具有 prototype 属性。这意味着所有用同一构造函数创建的对象继承同一个对象，因此它们是同一类的成员。示例 9-2 说明了如何使用一个构造函数来替代示例 9-1 中的工厂函数来修改 Range 类。示例 9-2 演示了在不支持 ES6 class 关键字版本的 JavaScript 中创建一个类的通用方法。即使是 class 已经很好支持的今天，仍然有很多旧 JavaScript 代码用这种方式定义类，并且你必须熟悉这种习惯用法，以便于阅读旧代码，也能够在使用 class 关键字时明白在底层中发生了什么。</p>

<p>示例 9-2：使用构造函数的 Range 类</p>

<pre><code class="language-javascript">// This is a constructor function that initializes new Range objects.
// Note that it does not create or return the object. It just initializes this.
function Range(from, to) {
    // Store the start and end points (state) of this new range object.
    // These are noninherited properties that are unique to this object.
    this.from = from;
    this.to = to;
}

// All Range objects inherit from this object.
// Note that the property name must be &quot;prototype&quot; for this to work.
Range.prototype = {
    // Return true if x is in the range, false otherwise
    // This method works for textual and Date ranges as well as numeric.
    includes: function(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; },

    // A generator function that makes instances of the class iterable.
    // Note that it only works for numeric ranges.
    [Symbol.iterator]: function*() {
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
    },

    // Return a string representation of the range
    toString: function() { return &quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;; }
};

// Here are example uses of this new Range class
let r = new Range(1,3);   // Create a Range object; note the use of new
r.includes(2)             // =&gt; true: 2 is in the range
r.toString()              // =&gt; &quot;(1...3)&quot;
[...r]                    // =&gt; [1, 2, 3]; convert to an array via iterator
</code></pre>

<p>将示例 9-1 和示例 9-2 中的代码做一个仔细的对比，可以发现两种类定义技术的差别。首先，注意当工厂函数 range() 转化为构造函数时被重命名为 Range()。这里遵循了一个常见的编程约定：从某种意义上讲，定义构造函数即是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。</p>

<p>再者，注意 Range() 构造函数是通过 new 关键字调用的（在示例代码的末尾）， 而 range() 工厂函数则不必使用 new。示例 9-1 通过调用普通函数（§8.2.1）来创建新对象，示例 9-2 则使用构造函数调用（§8.2.3）来创建新对象。由于 Range() 构造函数是通过 new 关键字调用的，因此不必调用 Object.create() 或其他什么逻辑来创建新对象。在调用构造函数之前就已经创建了新对象，并且通过 this 关键字可以获取这个新对象。Range() 构造函数只不过是初始化 this 而已。构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。构造函数调用与常规函数调用如此不同，实际上，这是我们为构造函数命名以大写字母为名的另一个原因。构造函数就是用来“构造新对象”的，它必须通过关键字 new 调用，如果将构造函数用做普通函数的话，往往不会正常工作。开发者可以通过命名规约来（构造函数首字母大写，普通方法首字母小写）判断是否应当在函数之前冠以关键字 new。</p>

<p><strong>构造函数和 new.target</strong></p>

<p>在函数正文中，可以使用特殊的表达式 new.target 来判断函数是否以构造函数的方式调用。如果定义了该表达式的值，那么这个函数是通过 new 关键字调用的构造函数。当我们在 §9.5 中讨论子类时，我们会看到 new.target 不总是其所在的构造函数的引用：它可能还引用子类的构造函数。</p>

<p>如果 new.target 是 undefined，那么包含它的函数是作为函数调用的，没有使用 new 关键字。JavaScript 很多异常构造函数可以不使用 new 来调用，如果想模仿这个特性可以这样写：</p>

<pre><code class="language-javascript">function C() {
    if (!new.target) return new C();
    // initialization code goes here
}
</code></pre>

<p>这个老式技巧只在构造函数定义时生效。类使用 class 关键字创建，不允许不使用 new 调用它的构造函数。</p>

<p>示例 9-1 和 9-2 之间的另一个关键区别是原型对象的命名方式。在第一个示例中，原型是 range.methods。这是一个方便和描述性的名称，但随意。在第二个示例中，原型为 Range.prototype，此名称是规定的。Range() 构造函数的调用自动使用 Range.prototype 作为新 Range 对象的原型。</p>

<p>最后，还要注意示例 9-1 和 9-2 之间不变的部分：对两个类来说，range 方法以相同的方式定义和调用。由于示例 9-2 演示了在 ES6 之前在 JavaScript 版本中创建类的惯用方法，因此它没原型对象中使用 ES6 速记方法语法，并且使用 function 关键字显式拼出方法名。但是，可以看到，在这两个示例中，方法的实现是相同的。</p>

<p>请注意，在定义构造函数或方法时，两个 range 示例都没使用箭头函数。回想一下，从 §8.1.3 中，用这种方式定义的函数没有原型属性，因此不能用作构造函数。此外，箭头函数从定义它们的上下文中继承 this 关键字，而不是基于调用它们的对象设置 this 值，这使得箭头函数对方法毫无用处，因为方法的定义特征是方法使用 this 关键字来引用调用方法的实例。</p>

<p>幸运的是，新的 ES6 类语法不允许使用 arrow 函数定义方法，因此这不是使用该语法时可能会意外犯的错误。我们将很快介绍 ES6 类关键字，但首先，有更多关于构造函数的详细信息。</p>

<h3 id="toc_2">9.2.1 构造函数、类标识和 instanceof</h3>

<p>正如我们所看到的，原型对象是类的基本标识：只有两个对象继承同一原型对象时，这两个对象是同一类实例。构造函数的关键点不是初始化新创建对象的状态：两个构造函数可能具有指向同一原型对象的原型属性。那么，两个构造函数都可用于创建同一类的实例。</p>

<p>尽管构造函数不像原型那样重要，但是构造函数充当 class 的大众脸。最明显的是，构造函数的名称通常用作类的名称。例如，我们说 Range() 构造函数创建 Range 对象。然而，更重要的是测试类中对象的成员关系，构造函数在右边被用作 instanceof 运算符的操作数。如果有一个对象 r，并且想知道它是不是一个 Range 对象，可以这样写：</p>

<pre><code class="language-javascript">r instanceof Range   // =&gt; true: r inherits from Range.prototype
</code></pre>

<p>instanceof 运算符在 §4.9.4 中有描述。左边的操作数是想要测试的对象，右边的操作数是命名类的构造函数。表达式 <code>o instanceof C</code> 计算结果为 true 时，o 继承自 C.prototype。不需要直接继承：如果 o 继承于一个继承了 C.prototype 的对象，表达式的计算结果也仍会是 true。</p>

<p>从技术上讲，在上一个代码示例中，instanceof 运算符的实例没有检查 r 是否实际由 Range 构造函数初始化。相反，它是检查 r 是否继承 Range.prototype。如果我们定义一个函数 Strange() 并将其原型设置与 Range.prototype 相同，则使用新 Strange() 创建的对象用 instanceof 运算符将算作 Range 对象（但是，它们实际上不会作为 Range 对象工作，因为它们的 from 和 to 属性尚未初始化）：</p>

<pre><code class="language-javascript">function Strange() {}
Strange.prototype = Range.prototype;
new Strange() instanceof Range   // =&gt; true
</code></pre>

<p>实际上即使 instanceof 不能验证使用了构造函数，它仍然使用构造函数作为其右侧，因为构造函数是类的公共标识。</p>

<p>如果要为特定原型测试对象的原型链，并且不想将构造函数用作媒介，可以使用 isPrototypeOf() 方法。例如，在示例 9-1 中，我们定义了一个没有构造函数的类，因此无法将 instanceof 与该类一起使用。但是，我们可以测试对象 r 是否是具有此代码的无构造函数类的成员：</p>

<pre><code class="language-javascript">range.methods.isPrototypeOf(r);  // range.methods is the prototype object.
</code></pre>

<h3 id="toc_3">9.2.2 constructor 属性</h3>

<p>在示例 9-2 中，将 Range.prototype 定义为一个新对象，这个对象包含类所需要的方法。其实没有必要新创建一个对象，用单个对象字面量的属性就可以方便地定义原型上的方法。任何普通 JavaScript 函数（除箭头函数、生成器函数和异步函数之外）都可以用做构造函数，并且调用构造函数是需要一个 prototype 属性的。因此，每个 JavaScript 函数都自动拥有一个 prototype 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor。constructor 属性的值是一个函数对象：</p>

<pre><code class="language-javascript">let F = function() {}; // This is a function object.
let p = F.prototype;   // This is the prototype object associated with F.
let c = p.constructor; // This is the function associated with the prototype.
c === F                // =&gt; true: F.prototype.constructor === F for any F
</code></pre>

<p>可以看到构造函数的原型中存在预先定义好的 constructor 属性，这意味着对象通常继承的 constructor 是它们的构造函数的引用。由于构造函数是类的“公共标识”， 因此这个 constructor 属性为对象提供了类。</p>

<pre><code class="language-javascript">let o = new F();      // Create an object o of class F
o.constructor === F   // =&gt; true: the constructor property specifies the class
</code></pre>

<p>如图 9-1 所示，图 9-1 展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例。</p>

<p>图 9-1：构造函数，原型，实例</p>

<p><img src="media/16101520446472/16118384534713.jpg" alt="图 9-1：构造函数，原型，实例"/></p>

<p>需要注意的是，图 9-1 用 Range() 构造函数作为示例。但实际上，示例 9-2 中定义的 Range 类使用它自身的一个新对象重写了预定义的 Range.prototype 对象。这个新定义的原型对象不含有 constructor 属性。因此 Range 类的实例也不含有 constructor 属性。我们可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：</p>

<pre><code class="language-javascript">Range.prototype = {
    constructor: Range,  // Explicitly set the constructor back-reference

    /* method definitions go here */
};
</code></pre>

<p>另一种常见的解决办法是使用预定义的原型对象，预定义的原型对象包含 constructor 属性，然后依次给原型对象添加方法：</p>

<pre><code class="language-javascript">// Extend the predefined Range.prototype object so we don&#39;t overwrite
// the automatically created Range.prototype.constructor property.
Range.prototype.includes = function(x) {
    return this.from &lt;= x &amp;&amp; x &lt;= this.to;
};
Range.prototype.toString = function() {
    return &quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;;
};
</code></pre>

<h2 id="toc_4">9.3 使用 class 关键字的类</h2>

<p>类自第一个版本以来一直是 JavaScript 的一部分，但在 ES6 中，它们最终引入 class 关键字得到了自己的语法。示例 9-3 显示了使用此新语法编写 Range 类的实现。</p>

<p>示例 9-3：使用 class 编写 Range 类</p>

<pre><code class="language-javascript">class Range {
    constructor(from, to) {
        // Store the start and end points (state) of this new range object.
        // These are noninherited properties that are unique to this object.
        this.from = from;
        this.to = to;
    }

    // Return true if x is in the range, false otherwise
    // This method works for textual and Date ranges as well as numeric.
    includes(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; }

    // A generator function that makes instances of the class iterable.
    // Note that it only works for numeric ranges.
    *[Symbol.iterator]() {
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
    }

    // Return a string representation of the range
    toString() { return `(${this.from}...${this.to})`; }
}

// Here are example uses of this new Range class
let r = new Range(1,3);   // Create a Range object
r.includes(2)             // =&gt; true: 2 is in the range
r.toString()              // =&gt; &quot;(1...3)&quot;
[...r]                    // =&gt; [1, 2, 3]; convert to an array via iterator
</code></pre>

<p>重要的是要了解，在示例 9-2 和 9-3 中定义的类的工作方式完全相同。将 class 关键字引入语言并不会改变 JavaScript 基于原型的类的基本性质。尽管示例 9-3 使用 class 关键字，但生成的 Range 对象是一个构造函数，就像示例 9-2 中定义的版本一样。新的 class 语法更清洁方便，但是最好将其看作示例 9-2 所示的基本类定义机制的语法糖。</p>

<p>注意在示例 9-3 中关于 class 语法的一下几点：</p>

<p>用 class 关键字声明类，后面接一个类名，最后是花括号包含类的正文。</p>

<p>类正文包括使用对象字面量方法速记定义的方法（我们在示例 9-1 中也使用了），其中省略了函数关键字。但是，与对象字面量不同，没有用逗号将方法彼此分开。（虽然类正文表面上与对象字面量相似，但它们不是一回事。与对象不同，类不支持具有名/值对的属性的定义。</p>

<p>关键字 constructor 用于定义类的构造函数。但是，定义的函数实际上并不命名为 constructor。类声明语句定义一个新的变量 Range，并将此特殊构造函数的值分配给该变量。</p>

<p>如果类不需要执行任何初始化，可以省略构造函数关键字及其正文，并将隐式创建一个空构造函数。</p>

<p>如果要定义子类（或继承来自另一个类的类），可以使用 extends 关键字与 class 关键字：</p>

<pre><code class="language-javascript">// A Span is like a Range, but instead of initializing it with
// a start and an end, we initialize it with a start and a length
class Span extends Range {
    constructor(start, length) {
        if (length &gt;= 0) {
            super(start, start + length);
        } else {
            super(start + length, start);
        }
    }
}
</code></pre>

<p>创建子类是完整的一节。我们将在 §9.5 重新讲到它，并解释这里的 extends 和 super 关键字。</p>

<p>与函数声明一样，类声明同时具有语句和表达式形式。正如我们可以写：</p>

<pre><code class="language-javascript">let square = function(x) { return x * x; };
square(3)  // =&gt; 9
we can also write:

let Square = class { constructor(x) { this.area = x * x; } };
new Square(3).area  // =&gt; 9
</code></pre>

<p>与函数定义表达式一样，类定义表达式可以包含可选类名。如果提供这样的名称，则该名称仅在类正文本身中有定义。</p>

<p>尽管函数表达式很常见（尤其是使用箭头函数），但 JavaScript 编程中，类定义表达式可能并不是经常使用，除非正在编写一个以类为实参并返回子类的函数。</p>

<p>结束对 class 关键字的介绍前，最后提几个重要但是不易注意的类语法：</p>

<p>类声明正文中的所有代码都隐式采用严格模式（§5.6.3），即使未出现&quot;use strict&quot;指令。例如，这意味着不能在类正文中使用八进制整数字面量或 with 语句，并且如果在使用变量之前忘记声明变量，则更有可能出现语法错误。</p>

<p>与函数声明不同，类声明不是&quot;声明提前&quot;的。回想一下 §8.1.1 中，函数定义的行为就像它们被移动到封闭文件的顶部或封闭函数的顶部一样，这意味着可以在函数实际定义之前的代码中调用函数。尽管类声明在某些方面与函数声明一样，但它们不共享这种提前行为：在声明类之前，不能实例化类。</p>

<h3 id="toc_5">9.3.1 静态方法</h3>

<p>可以通过使用 static 关键字作为方法声明前缀来定义类正文中的静态方法。静态方法定义为构造函数的属性，而不是原型对象的属性。</p>

<p>例如，假设我们将以下代码添加到示例 9-3 中：</p>

<pre><code class="language-javascript">static parse(s) {
    let matches = s.match(/^\((\d+)\.\.\.(\d+)\)$/);
    if (!matches) {
        throw new TypeError(`Cannot parse Range from &quot;${s}&quot;.`)
    }
    return new Range(parseInt(matches[1]), parseInt(matches[2]));
}
</code></pre>

<p>此代码定义的方法是 Range.parse()， 而不是 Range.prototype.parse()， 必须通过构造函数而不是通过实例调用它：</p>

<pre><code class="language-javascript">let r = Range.parse(&#39;(1...10)&#39;); // Returns a new Range object
r.parse(&#39;(1...10)&#39;);             // TypeError: r.parse is not a function
</code></pre>

<p>有时会看到静态方法称为类方法，因为它们是使用类/构造函数的名称调用的。使用此术语时，将类方法与在类实例上调用的常规实例方法进行对比，由于静态方法在构造函数上调用，而不是在任何特定实例上调用，因此在静态方法中使用 this 关键字几乎从来就没有意义。</p>

<p>我们将在示例 9-4 中看到静态方法的示例。</p>

<h3 id="toc_6">9.3.2 Getter、Setter 和其他方法</h3>

<p>在类正文中，可以定义 getter 和 setter 方法（§6.10.6），就像在对象字面量中一样。唯一的区别是，在类正文中，不会将逗号放在 getter 或 setter 之后。示例 9-4 包括类中 getter 方法的实际示例。</p>

<p>通常，对象字面量中允许的所有速记方法定义语法也允许在类正文中使用。这包括生成器方法（用 * 标记）和名称为方括号中表达式值的方法。事实上，已经看到了（在示例 9-3 中）具有计算名称的生成器方法，该方法使 Range 类可重复：</p>

<pre><code class="language-javascript">*[Symbol.iterator]() {
    for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
}
</code></pre>

<h3 id="toc_7">9.3.3 公有、私有和静态字段</h3>

<p>在此处对使用 class 关键字定义的类的讨论中，我们只描述了类正文中方法的定义。ES6 标准只允许创建方法（包括 getter、setter 和生成器）和静态方法；它不包括用于定义字段的语法。如果要在类实例上定义字段（这只是面向对象中&quot;属性&quot;的同义词），则必须在构造函数函数或其中一个方法中这样做。必须在类正文之外类定义后，才能为类定义静态字段。示例 9-4 包括这各种字段的示例。</p>

<p>但是，对于允许以公有和私有形式定义实例和静态字段的扩展类语法正在进行标准化。本节其余部分中显示的代码在 2020 年初还不是标准 JavaScript，但在 Chrome 中已经支持，并且 Firefox 中已部分支持（仅使公有实例字段）。使用 React 框架和 Babel 编译器的 JavaScript 程序员常用公有实例字段的语法。</p>

<p>假设你正在编写一个这样的类，其中一个构造函数初始化了三个字段：</p>

<pre><code class="language-javascript">class Buffer {
    constructor() {
        this.size = 0;
        this.capacity = 4096;
        this.buffer = new Uint8Array(this.capacity);
    }
}
</code></pre>

<p>使用可能标准化的新实例字段语法，可以这样编写：</p>

<pre><code class="language-javascript">class Buffer {
    size = 0;
    capacity = 4096;
    buffer = new Uint8Array(this.capacity);
}
</code></pre>

<p>字段初始化代码已移出构造函数，现在直接显示在类正文中。（当然，该代码仍作为构造函数的一部分运行。如果不定义构造函数，则字段初始化为隐式创建的构造函数的一部分。赋值左侧的 this. 前缀消失，但请注意即使是在初始化赋值的右侧，仍必须使用 this. 前缀引用这些字段。这种方式初始化实例字段的优点是，此语法允许（但不需要）将初始化放在类定义的顶部，使读者清楚地了解字段在每个实例将保存的状态。可以通过字段名后面跟一个分号来只声明不初始化一个字段。如果这样做，字段的初始值将是 undefined。显式设定初始化字段的值是比较好的风格。</p>

<p>在添加字段语法之前，类正文看起来很像使用快捷方法语法的对象字面量，只不过逗号被删除。字段语法（使用等号和分号代替冒号和逗号）清楚地表明类正文与对象字面量不完全相同。</p>

<p>标准化中的实例字段同时也定义了私有实例字段。如果使用上例中所示的实例字段初始化语法来定义其名称以 # 开头的字段（在 JavaScript 标识符中通常不是合法字符），则该字段在类正文中可用（使用 # 前缀），但对类正文之外的任何代码不可见且不可访问（因此不可变）。如果对于前面的 Buffer 类，要确保类的用户不会无意中修改实例的 size 字段，可以改为使用私有 #size 字段，然后定义 getter 函数以提供对值的只读访问：</p>

<pre><code class="language-javascript">class Buffer {
    #size = 0;
    get size() { return this.#size; }
}
</code></pre>

<p>请注意，必须先使用新字段语法声明私有字段，然后才能使用它们。你不能只在类的构造函数中写 <code>this.#size = 0;</code>，除非直接在类正文中包含字段的&quot;声明&quot;。</p>

<p>最后，在标准化过程中相关建议字段使用 static 关键字。如果在公有或私有字段声明之前添加静态字段，这些字段将创建为构造函数的属性，而不是实例的属性。思考我们定义的静态 Range.parse() 方法。它包括一个相当复杂的正则表达式，将其拆分到它自有的静态字段中可能会更好。使用建议的新静态字段语法，我们可以这编写：</p>

<pre><code class="language-javascript">static integerRangePattern = /^\((\d+)\.\.\.(\d+)\)$/;
static parse(s) {
    let matches = s.match(Range.integerRangePattern);
    if (!matches) {
        throw new TypeError(`Cannot parse Range from &quot;${s}&quot;.`)
    }
    return new Range(parseInt(matches[1]), matches[2]);
}
</code></pre>

<p>如果我们希望此静态字段只能在类中访问，我们可以使用像 #pattern 这样的名称将其私有化。</p>

<h3 id="toc_8">9.3.4 示例：一个复数类</h3>

<p>示例 9-4 定义了一个表示复数的类。该类相对简单，但它包括实例方法（包括 getters）、静态方法、实例字段和静态字段。它包括一些注释掉的代码，演示如何使用尚未加入标准的语法定义类正文中的实例字段和静态字段。</p>

<p>示例 9-4：Complex.js：一个复数类</p>

<pre><code class="language-javascript">/**
 * Instances of this Complex class represent complex numbers.
 * Recall that a complex number is the sum of a real number and an
 * imaginary number and that the imaginary number i is the square root of -1.
 */
class Complex {
    // Once class field declarations are standardized, we could declare
    // private fields to hold the real and imaginary parts of a complex number
    // here, with code like this:
    //
    // #r = 0;
    // #i = 0;

    // This constructor function defines the instance fields r and i on every
    // instance it creates. These fields hold the real and imaginary parts of
    // the complex number: they are the state of the object.
    constructor(real, imaginary) {
        this.r = real;       // This field holds the real part of the number.
        this.i = imaginary;  // This field holds the imaginary part.
    }

    // Here are two instance methods for addition and multiplication
    // of complex numbers. If c and d are instances of this class, we
    // might write c.plus(d) or d.times(c)
    plus(that) {
        return new Complex(this.r + that.r, this.i + that.i);
    }
    times(that) {
        return new Complex(this.r * that.r - this.i * that.i,
                           this.r * that.i + this.i * that.r);
    }

    // And here are static variants of the complex arithmetic methods.
    // We could write Complex.sum(c,d) and Complex.product(c,d)
    static sum(c, d) { return c.plus(d); }
    static product(c, d) { return c.times(d); }

    // These are some instance methods that are defined as getters
    // so they&#39;re used like fields. The real and imaginary getters would
    // be useful if we were using private fields this.#r and this.#i
    get real() { return this.r; }
    get imaginary() { return this.i; }
    get magnitude() { return Math.hypot(this.r, this.i); }

    // Classes should almost always have a toString() method
    toString() { return `{${this.r},${this.i}}`; }

    // It is often useful to define a method for testing whether
    // two instances of your class represent the same value
    equals(that) {
        return that instanceof Complex &amp;&amp;
            this.r === that.r &amp;&amp;
            this.i === that.i;
    }

    // Once static fields are supported inside class bodies, we could
    // define a useful Complex.ZERO constant like this:
    // static ZERO = new Complex(0,0);
}

// Here are some class fields that hold useful predefined complex numbers.
Complex.ZERO = new Complex(0,0);
Complex.ONE = new Complex(1,0);
Complex.I = new Complex(0,1);
</code></pre>

<p>定义了示例 9-4 的 Complex 类后，我们可以将构造函数、实例字段、实例方法、类字段和类方法如下使用：</p>

<pre><code class="language-javascript">let c = new Complex(2, 3);     // Create a new object with the constructor
let d = new Complex(c.i, c.r); // Use instance fields of c
c.plus(d).toString()           // =&gt; &quot;{5,5}&quot;; use instance methods
c.magnitude                    // =&gt; Math.hypot(2,3); use a getter function
Complex.product(c, d)          // =&gt; new Complex(0, 13); a static method
Complex.ZERO.toString()        // =&gt; &quot;{0,0}&quot;; a static property
</code></pre>

<h2 id="toc_9">9.4 为类添加方法</h2>

<p>JavaScript 基于原型的继承机制是动态的：对象从其原型继承属性，即使原型的属性在创建对象后发生更改。这意味着我们只需向原型对象添加新方法，即可扩展 JavaScript 类。</p>

<p>例如，下面是将计算共轭复数的方法添加到示例 9-4 的 Complex 类的代码：</p>

<pre><code class="language-javascript">// Return a complex number that is the complex conjugate of this one.
Complex.prototype.conj = function() { return new Complex(this.r, -this.i); };
</code></pre>

<p>JavaScript 类内置的原型对象也是这样展现的，这意味着我们可以向数字、字符串、数组、函数等添加方法。这对于在旧版本的语言中实现新特性非常有用：</p>

<pre><code class="language-javascript">// If the new String method startsWith() is not already defined...
if (!String.prototype.startsWith) {
    // ...then define it like this using the older indexOf() method.
    String.prototype.startsWith = function(s) {
        return this.indexOf(s) === 0;
    };
}
</code></pre>

<p>这是另外一个例子：</p>

<pre><code class="language-javascript">// Invoke the function f this many times, passing the iteration number
// For example, to print &quot;hello&quot; 3 times:
//     let n = 3;
//     n.times(i =&gt; { console.log(`hello ${i}`); });
Number.prototype.times = function(f, context) {
    let n = this.valueOf();
    for(let i = 0; i &lt; n; i++) f.call(context, i);
};
</code></pre>

<p>向这样在内置类型的原型添加方法通常被认为是一个坏主意，因为如果新版本的 JavaScript 定义具有相同名称的方法，将来就会造成混淆和兼容性问题。甚至可以向 Object.prototype 添加方法，使它们可作用于所有对象。但这从来就不是一件好事，因为添加到 Object.prototype 的属性对 for/in 循环可见（尽管可以使用 Object.defineProperty()（§14.1）来使新属性不可枚举来避免这种情况）。</p>

<h2 id="toc_10">9.5 子类</h2>

<p>在面向对象的编程中，B 类可以扩展 A 类或成为 A 类子类。我们称 A 是父类，B 是子类。B 的实例继承 A 的方法。B 类可以定义自有方法，使用相同名称可以重写类 A 中的方法。如果 B 的方法重写 A 方法，则 B 中的重写方法通常需要调用 A 中的重写方法。同样，子类构造函数 B() 通常必须调用父类构造函数 A()，以确保实例完全初始化。</p>

<p>本节首先演示 ES6 之前如何定义子类，然后演示使用 class 和 extends 关键字的子类和使用 super 关键字调用父类构造函数。再接下来一节是关于避免使用子类而依靠对象组合代替继承。本章最后结束于一个扩展的示例，定义 Set 类的层次结构和演示如何使用抽象类将接口与实现分离。</p>

<h3 id="toc_11">9.5.1 子类和原型</h3>

<p>假设我们想要给示例 9-2 中 Range 类定义 Span 子类。此子类的工作方式与 Range 一样，但我们初始化改为指定开始和范围，而不是制定开始和结束。Span 类的实例也是父类 Range 的实例。Span 实例从 Span.prototype 继承自定义的 toString() 方法，但为了成为 Range 的子类，它还必须从 Range.prototype 继承方法（如 includes()）。</p>

<p>实例 9-5：Span.js：Range 一个简单的子类</p>

<pre><code class="language-javascript">// This is the constructor function for our subclass
function Span(start, span) {
    if (span &gt;= 0) {
        this.from = start;
        this.to = start + span;
    } else {
        this.to = start;
        this.from = start + span;
    }
}

// Ensure that the Span prototype inherits from the Range prototype
Span.prototype = Object.create(Range.prototype);

// We don&#39;t want to inherit Range.prototype.constructor, so we
// define our own constructor property.
Span.prototype.constructor = Span;

// By defining its own toString() method, Span overrides the
// toString() method that it would otherwise inherit from Range.
Span.prototype.toString = function() {
    return `(${this.from}... +${this.to - this.from})`;
};
</code></pre>

<p>为了使 Span 成为 Range 的子类，我们需要使 Span.prototype 从 Range.prototype 继承。前面示例中的关键代码行是此代码行，如果能理解子类使如何工作的，它是非常有意义的：</p>

<pre><code class="language-javascript">Span.prototype = Object.create(Range.prototype);
</code></pre>

<p>使用 Span() 构造函数创建的对象将从 Span.prototype 对象继承。但是，我们创建了该对象并继承 Range.prototype，因此 Span 对象将同时从 Span.prototype 和 Range.prototype 继承。</p>

<p>可能会注意到，我们的 Span() 构造函数设置与 Range() 构造函数相同的 from 和 to 属性，因此不需要调用 Range() 构造函数来初始化新对象。同样，Span 的 toString() 方法完全重新实现字符串转换，而无需调用 Range 版本的 toString()。这使得 Span 成为特例，我们必须摆脱这种子类，因为这种情况是我们知道父类的实现细节。一个健壮的子类机制需要允许类调用其父类的方法和构造函数，但在 ES6 之前，JavaScript 没有一个简单的方法来执行这些操作。</p>

<p>幸运的是，ES6 用 super 关键字作为类语法一部分解决了这些问题。下一节演示它是如何工作的。</p>

<h3 id="toc_12">9.5.2 子类与 extends 和 super</h3>

<p>在 ES6 之后，可以简单的在类声明时接一个 extends 从句添加一个父类，即使对于内置类也可以这样做：</p>

<pre><code class="language-javascript">// A trivial Array subclass that adds getters for the first and last elements.
class EZArray extends Array {
    get first() { return this[0]; }
    get last() { return this[this.length-1]; }
}

let a = new EZArray();
a instanceof EZArray  // =&gt; true: a is subclass instance
a instanceof Array    // =&gt; true: a is also a superclass instance.
a.push(1,2,3,4);      // a.length == 4; we can use inherited methods
a.pop()               // =&gt; 4: another inherited method
a.first               // =&gt; 1: first getter defined by subclass
a.last                // =&gt; 3: last getter defined by subclass
a[1]                  // =&gt; 2: regular array access syntax still works.
Array.isArray(a)      // =&gt; true: subclass instance really is an array
EZArray.isArray(a)    // =&gt; true: subclass inherits static methods, too!
</code></pre>

<p>EZArray 子类定义了两个简单的 getter 方法。EZArray 实例的行为类似于普通数组，我们可以使用继承的方法和属性，如 push()、pop() 和 length。但是，我们也可以使用子类中定义的 first 和 last getter 方法。不仅继承实例方法如 pop() ，也继承 Array.isArray 等静态方法。这是 ES6 类语法启用的新特性：EZArray() 是一个函数，但它从 Array() 继承：</p>

<pre><code class="language-javascript">// EZArray inherits instance methods because EZArray.prototype
// inherits from Array.prototype
Array.prototype.isPrototypeOf(EZArray.prototype) // =&gt; true

// And EZArray inherits static methods and properties because
// EZArray inherits from Array. This is a special feature of the
// extends keyword and is not possible before ES6.
Array.isPrototypeOf(EZArray) // =&gt; true
</code></pre>

<p>EZArray 子类太简单了，没有教育意义。示例 9-6 是一个更充实的示例。它定义了内置 Map 类的 TypedMap 子类，该子类添加类型检查以确保映射的键和值是指定的类型（根据 typeof）。重要的是，此示例演示了使用 super 关键字来调用父类的构造函数和方法。</p>

<p>示例 9-6：TypedMap.js：一个检测 key 和 value 类型的 Map 子类</p>

<pre><code class="language-javascript">class TypedMap extends Map {
    constructor(keyType, valueType, entries) {
        // If entries are specified, check their types
        if (entries) {
            for(let [k, v] of entries) {
                if (typeof k !== keyType || typeof v !== valueType) {
                    throw new TypeError(`Wrong type for entry [${k}, ${v}]`);
                }
            }
        }

        // Initialize the superclass with the (type-checked) initial entries
        super(entries);

        // And then initialize this subclass by storing the types
        this.keyType = keyType;
        this.valueType = valueType;
    }

    // Now redefine the set() method to add type checking for any
    // new entries added to the map.
    set(key, value) {
        // Throw an error if the key or value are of the wrong type
        if (this.keyType &amp;&amp; typeof key !== this.keyType) {
            throw new TypeError(`${key} is not of type ${this.keyType}`);
        }
        if (this.valueType &amp;&amp; typeof value !== this.valueType) {
            throw new TypeError(`${value} is not of type ${this.valueType}`);
        }

        // If the types are correct, we invoke the superclass&#39;s version of
        // the set() method, to actually add the entry to the map. And we
        // return whatever the superclass method returns.
        return super.set(key, value);
    }
}
</code></pre>

<p>TypedMap() 构造函数的前两个实参是所需的键和值类型。这些实参应该是字符串，如&quot;number&quot;和&quot;boolean&quot;，这些字符串应该是 typeof 运算符的返回值。还可以指定第三个实参：指定 map 中初始条目的 [key,value] 数组（或任何可迭代对象）。如果指定任何初始条目，则构造函数要做的第一件事是验证其类型是否正确。接下来，构造函数调用父类构造函数，使用 super 关键字，就像它是一个函数名称一样。Map() 构造函数采用一个可选实参：可迭代对象 [key,value] 的数组。因此，TypedMap() 构造函数的第三个可选实参是 Map() 构造函数的第一个可选实参，我们用 <code>super(entries)</code> 将它传递给父类的构造函数。</p>

<p>调用父类构造函数初始化父类状态后，接下来 TypedMap() 构造函数初始化其自己的子类状态 this.keyType 和 this.valueType。它需要设置这些属性，以便它可以在 set() 方法中再次使用它们。</p>

<p>在构造函数中使用 super() 需要了解一些重要规则：</p>

<p>如果使用 extends 关键字定义类，则类的构造函数必须使用 super() 调用父类构造函数。</p>

<p>如果未在子类中定义构造函数，将自动为你定义一个构造函数。此隐式定义的构造函数只将传递给它值传递给 super()。</p>

<p>在使用 super() 调用父类构造函数之前，不能在构造函数中使用 this 关键字。这个强制规则确保父类先于子类初始化。</p>

<p>在未使用 new 关键字调用的函数中，new.target 表达式是 undefined。但是，在构造函数中，new.target 是引用调用的构造函数。当调用子类构造函数并使用 super() 调用父类构造函数时，该父类构造函数将看到子类构造函数作为 new.target 的值。虽然设计良好的父类不需要知道它是否有子类，但，在日志记录消息的场景中使用 new.target.name 会很有用。</p>

<p>在构造函数之后，示例 9-6 的下一部分是名为 set() 的方法。Map 父类定义了名为 set() 的方法，以向 Map 添加新条目。TypedMap 中的 set() 方法将重写其父类的 set() 方法。这个简单的 TypedMap 子类对向 Map 添加新条目一无所知，但它知道如何检查类型，因此它首先会这样做，验证要添加到地图中的键和值的类型是否正确，如果它们不正确则抛出异常。此 set() 方法无法将键和值添加到 Map 本身，但这就是父类 set() 方法的用途。因此，我们再次使用 super 关键字来调用父类版本的 set() 方法。在此上下文中，super 的工作方式与 this 关键字的工作方式非常相似：它引用当前对象，但允许访问在父级类中定义的被重写方法。</p>

<p>在构造函数中，需要先调用父类构造函数，然后才能访问 this 和初始化新对象。但重写方法时没有此类规则。调用重写父类方法时不需要调用父类方法。如果它确实使用 super 来调用父类中的重写方法（或任何方法），它可以在重写方法的开头、中间或末尾调用。</p>

<p>最后，在将 TypedMap 示例抛在脑后之前，值得注意的是，此类是使用私有字段的理想场景。现在编写类时，用户可以更改 keyType 或 valueType 属性以破坏类型检查。一旦支持私有字段，我们可以将这些属性改为 #keyType 和 #valueType，以便它们不能从外部更改。</p>

<h3 id="toc_13">9.5.3 委托代替继承</h3>

<p>extends 关键字便于创建子类。但这并不意味着应该创建大量的子类。如果要编写某些其他类共享的行为的类，可以尝试通过创建子类来继承该行为。但是，通常将期望的行为编写在类中比用类创建其他类的实例并根据需要委托给该实例更简单也更灵活。创建新类不将其作为子类，而是通过包装或&quot;组合&quot;其他类。这种委托方法通常称为&quot;组合&quot;，它是一种面向对象编程经常被引用的座右铭&quot;倾向于组合而不是继承&quot;。<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<p>例如，假设我们想要一个行为类似于 JavaScript 的 Set 类的 Histogram 类，只不过，它不只是跟踪是否给集合添加了值，还维护该值添加次数的计数。由于 Histogram 类的 API 与 Set 类似，因此我们可以考虑 Set 子类并添加 count() 方法。另一方面，一旦我们开始考虑如何实现 count() 方法，我们可能会意识到 Histogram 类更像是一个 Map 而不是一个 Set，因为它需要维护值与添加它们次数之间的映射。因此，我们可以创建一个类，该类定义一个类似 Set 的 API，但委托内部 Map 对象来实现这些方法，而不是创建 Set 的子类。示例 9-7 显示了我们如何做到这一点。</p>

<p>示例 9-7：Histogram.js：使用委托实现一个类似 Set 的类</p>

<pre><code class="language-javascript">/**
 * A Set-like class that keeps track of how many times a value has
 * been added. Call add() and remove() like you would for a Set, and
 * call count() to find out how many times a given value has been added.
 * The default iterator yields the values that have been added at least
 * once. Use entries() if you want to iterate [value, count] pairs.
 */
class Histogram {
    // To initialize, we just create a Map object to delegate to
    constructor() { this.map = new Map(); }

    // For any given key, the count is the value in the Map, or zero
    // if the key does not appear in the Map.
    count(key) { return this.map.get(key) || 0; }

    // The Set-like method has() returns true if the count is non-zero
    has(key) { return this.count(key) &gt; 0; }

    // The size of the histogram is just the number of entries in the Map.
    get size() { return this.map.size; }

    // To add a key, just increment its count in the Map.
    add(key) { this.map.set(key, this.count(key) + 1); }

    // Deleting a key is a little trickier because we have to delete
    // the key from the Map if the count goes back down to zero.
    delete(key) {
        let count = this.count(key);
        if (count === 1) {
            this.map.delete(key);
        } else if (count &gt; 1) {
            this.map.set(key, count - 1);
        }
    }

    // Iterating a Histogram just returns the keys stored in it
    [Symbol.iterator]() { return this.map.keys(); }

    // These other iterator methods just delegate to the Map object
    keys() { return this.map.keys(); }
    values() { return this.map.values(); }
    entries() { return this.map.entries(); }
}
</code></pre>

<p>在示例 9-7 中，Histogram() 构造函数创建一个 Map 对象。大多数方法都是单行，它们只是委托给 Map 的方法，使得实现变得非常简单。因为我们使用委托而不是继承，所以 Histogram 对象不是 Set 或 Map 的实例。但是，Histogram 实现了许多常用的 Set 方法，并没有过多的使用额外的 JavaScript，这通常足够好：有条理的继承关系有时是不错，但通常是可选的。</p>

<h3 id="toc_14">9.5.4 Hierarchies 类和抽象类</h3>

<p>示例 9-6 演示了如创建 Map 的子类。示例 9-7 演示了如何在不创建子类的情况下将委托给 Map 对象。使用 JavaScript 类封装数据和模块化代码通常是一种很好的技术，你可能会发现自己经常使用类关键字。但是，你可能会发现，你更喜欢组合而不是继承，而且很少需要使用 extends（除非使用需要扩展的库或框架）。</p>

<p>但是，在某些情况下，多个级别的子类是合适的，我们将举一个扩展示例来结束本章，通过描述不同种类的集合来演示类的层次结构。（示例 9-8 中定义的类跟 JavaScript 中的内置 Set 类很相似，但不完全兼容。）</p>

<p>示例 9-8 定义了大量子类，但它也演示了如何定义抽象类（不包括完整实现的类）作为一组相关子类的通用父类。抽象父类可以定义所有子类继承和共享的部分实现。因此，子类只需要通过实现父类定义的抽象方法（没有实现）来定义它们自己的独特行为。请注意，JavaScript 对抽象方法或抽象类没有任何正式定义；我只是将这个名字用于未实现的方法和不完全实现的类。</p>

<p>示例 9-8 评论良好，并且独立。我鼓励你把它作为本章关于类的顶级示例。示例 9-8 用 &amp;、| 和 ~ 运算符执行大量位操作，可以在 §4.8.3 中查看这些运算符。</p>

<p>示例 9-8：Sets.js：抽象类和实体类的层次</p>

<pre><code class="language-javascript">/**
 * The AbstractSet class defines a single abstract method, has().
 */
class AbstractSet {
    // Throw an error here so that subclasses are forced
    // to define their own working version of this method.
    has(x) { throw new Error(&quot;Abstract method&quot;); }
}

/**
 * NotSet is a concrete subclass of AbstractSet.
 * The members of this set are all values that are not members of some
 * other set. Because it is defined in terms of another set it is not
 * writable, and because it has infinite members, it is not enumerable.
 * All we can do with it is test for membership and convert it to a
 * string using mathematical notation.
 */
class NotSet extends AbstractSet {
    constructor(set) {
        super();
        this.set = set;
    }

    // Our implementation of the abstract method we inherited
    has(x) { return !this.set.has(x); }
    // And we also override this Object method
    toString() { return `{ x| x ∉ ${this.set.toString()} }`; }
}

/**
 * Range set is a concrete subclass of AbstractSet. Its members are
 * all values that are between the from and to bounds, inclusive.
 * Since its members can be floating point numbers, it is not
 * enumerable and does not have a meaningful size.
 */
class RangeSet extends AbstractSet {
    constructor(from, to) {
        super();
        this.from = from;
        this.to = to;
    }

    has(x) { return x &gt;= this.from &amp;&amp; x &lt;= this.to; }
    toString() { return `{ x| ${this.from} ≤ x ≤ ${this.to} }`; }
}

/*
 * AbstractEnumerableSet is an abstract subclass of AbstractSet.  It defines
 * an abstract getter that returns the size of the set and also defines an
 * abstract iterator. And it then implements concrete isEmpty(), toString(),
 * and equals() methods on top of those. Subclasses that implement the
 * iterator, the size getter, and the has() method get these concrete
 * methods for free.
 */
class AbstractEnumerableSet extends AbstractSet {
    get size() { throw new Error(&quot;Abstract method&quot;); }
    [Symbol.iterator]() { throw new Error(&quot;Abstract method&quot;); }

    isEmpty() { return this.size === 0; }
    toString() { return `{${Array.from(this).join(&quot;, &quot;)}}`; }
    equals(set) {
        // If the other set is not also Enumerable, it isn&#39;t equal to this one
        if (!(set instanceof AbstractEnumerableSet)) return false;

        // If they don&#39;t have the same size, they&#39;re not equal
        if (this.size !== set.size) return false;

        // Loop through the elements of this set
        for(let element of this) {
            // If an element isn&#39;t in the other set, they aren&#39;t equal
            if (!set.has(element)) return false;
        }

        // The elements matched, so the sets are equal
        return true;
    }
}

/*
 * SingletonSet is a concrete subclass of AbstractEnumerableSet.
 * A singleton set is a read-only set with a single member.
 */
class SingletonSet extends AbstractEnumerableSet {
    constructor(member) {
        super();
        this.member = member;
    }

    // We implement these three methods, and inherit isEmpty, equals()
    // and toString() implementations based on these methods.
    has(x) { return x === this.member; }
    get size() { return 1; }
    *[Symbol.iterator]() { yield this.member; }
}

/*
 * AbstractWritableSet is an abstract subclass of AbstractEnumerableSet.
 * It defines the abstract methods insert() and remove() that insert and
 * remove individual elements from the set, and then implements concrete
 * add(), subtract(), and intersect() methods on top of those. Note that
 * our API diverges here from the standard JavaScript Set class.
 */
class AbstractWritableSet extends  AbstractEnumerableSet {
    insert(x) { throw new Error(&quot;Abstract method&quot;); }
    remove(x) { throw new Error(&quot;Abstract method&quot;); }

    add(set) {
        for(let element of set) {
            this.insert(element);
        }
    }

    subtract(set) {
        for(let element of set) {
            this.remove(element);
        }
    }

    intersect(set) {
        for(let element of this) {
            if (!set.has(element)) {
                this.remove(element);
            }
        }
    }
}

/**
 * A BitSet is a concrete subclass of AbstractWritableSet with a
 * very efficient fixed-size set implementation for sets whose
 * elements are non-negative integers less than some maximum size.
 */
class BitSet extends AbstractWritableSet {
    constructor(max) {
        super();
        this.max = max;  // The maximum integer we can store.
        this.n = 0;      // How many integers are in the set
        this.numBytes = Math.floor(max / 8) + 1;   // How many bytes we need
        this.data = new Uint8Array(this.numBytes); // The bytes
    }

    // Internal method to check if a value is a legal member of this set
    _valid(x) { return Number.isInteger(x) &amp;&amp; x &gt;= 0 &amp;&amp; x &lt;= this.max; }

    // Tests whether the specified bit of the specified byte of our
    // data array is set or not. Returns true or false.
    _has(byte, bit) { return (this.data[byte] &amp; BitSet.bits[bit]) !== 0; }

    // Is the value x in this BitSet?
    has(x) {
        if (this._valid(x)) {
            let byte = Math.floor(x / 8);
            let bit = x % 8;
            return this._has(byte, bit);
        } else {
            return false;
        }
    }

    // Insert the value x into the BitSet
    insert(x) {
        if (this._valid(x)) {               // If the value is valid
            let byte = Math.floor(x / 8);   // convert to byte and bit
            let bit = x % 8;
            if (!this._has(byte, bit)) {    // If that bit is not set yet
                this.data[byte] |= BitSet.bits[bit]; // then set it
                this.n++;                            // and increment set size
            }
        } else {
            throw new TypeError(&quot;Invalid set element: &quot; + x );
        }
    }

    remove(x) {
        if (this._valid(x)) {              // If the value is valid
            let byte = Math.floor(x / 8);  // compute the byte and bit
            let bit = x % 8;
            if (this._has(byte, bit)) {    // If that bit is already set
                this.data[byte] &amp;= BitSet.masks[bit];  // then unset it
                this.n--;                              // and decrement size
            }
        } else {
            throw new TypeError(&quot;Invalid set element: &quot; + x );
        }
    }

    // A getter to return the size of the set
    get size() { return this.n; }

    // Iterate the set by just checking each bit in turn.
    // (We could be a lot more clever and optimize this substantially)
    *[Symbol.iterator]() {
        for(let i = 0; i &lt;= this.max; i++) {
            if (this.has(i)) {
                yield i;
            }
        }
    }
}

// Some pre-computed values used by the has(), insert() and remove() methods
BitSet.bits = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
BitSet.masks = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~128]);
</code></pre>

<h2 id="toc_15">9.6 总结</h2>

<p>本章说明了 JavaScript 类的主要功能：</p>

<ul>
<li>同一类的成员对象从同一原型对象继承属性。原型对象是 JavaScript 类的关键特性，只有 Object.create() 方法可以定义类。</li>
<li>在 ES6 之前，典型的类定义先定义构造函数。使用 function 关键字创建的函数具有原型属性，this 属性的值是使用 new 将函数用作构造函数调用时创建的对象的原型对象。通过初始化此原型对象，可以定义类的共享方法。虽然原型对象是类的关键特性，但构造函数是类的公共标识。</li>
<li>ES6 引入了一个 class 关键字，它使定义类更加容易，但它只是个语法糖，构造函数和原型机制保持不变。</li>
<li>子类使用类声明中的 extends 关键字定义。</li>
<li>子类可以使用 super 关键字调用其父类的构造函数或父类的重写方法。</li>
</ul>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>例如，见《Design Patterns (Addison-Wesley Professional)》作者 Erich Gamma 等，或者《Effective Java (Addison-Wesley Professional)》作者 Joshua Bloch。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
</feed>
