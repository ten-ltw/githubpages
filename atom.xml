<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[十]]></title>
  <link href="2019919.xyz/atom.xml" rel="self"/>
  <link href="2019919.xyz/"/>
  <updated>2021-03-25T18:30:48+08:00</updated>
  <id>2019919.xyz/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Angular 中的 DI]]></title>
    <link href="2019919.xyz/16166681233612.html"/>
    <updated>2021-03-25T18:28:43+08:00</updated>
    <id>2019919.xyz/16166681233612.html</id>
    <content type="html"><![CDATA[
<p>我们都知道创建一个服务，并通过 <code>@Injectable</code> 装饰器或者在 Module 中的 providers 中注册，并在组件的构造方法中通过如下方式依赖注入：</p>

<pre><code class="language-typescript">import { AuthService } from &#39;../user/auth.service&#39;;
export class NavBarComponent {
    constructor(public auth:AuthService){
    }
}
</code></pre>

<p>首先，必须先从其文件中导入 AuthService，并在构造函数中以参数的形式将其注入，参数的类型与文件内导出的 Class 一致，这个 Class 是 ES6 的语法糖，它实际上就是一个构造函数。 </p>

<p>但是我们在这里是想得到一个 AuthService 的实例，我们并是想要得到 AuthService Class 或者 AuthService 函数，这就是 Angular 所做的：创建了一个实例并给我们这个实例。当我们注册了 AuthService Class，Angular 会创建这个 Class 的实例，并在任何引用它的构造函数中给我们这个实例，而创建这个实例就发生在我们将 AuthService 注册在 Module 的 providers 中。</p>

<p>那 Angular 是如何知道我们想要的是 AuthService 而不是其他 service 呢？</p>

<h2 id="toc_0">Angular 如何知道我们要的是哪个 service 的实例呢？</h2>

<p>Angular 通过截获组件构造函数中的声明，通过 TypeScript 的类型声明（这里就是 AuthService），在服务中寻找。所以实际上，它是通过 Class 作为一个 key 来寻找正确的对象，在上面的例子中，AuthService 实例就是在 AuthService 的 DI 注册时被创建的。</p>

<h3 id="toc_1">Angular 与 Angular Js 的 DI 的区别</h3>

<pre><code class="language-javascript">angular.module(&#39;app&#39;).service(&#39;auth&#39;,AuthService)
</code></pre>

<p>在 Angular Js 中，服务是通过上面的方式注册的，service() 方法有两个参数，第一个参数是一个字符串，第二个参数是我们想要的对象。所以 Angular Js 的依赖注入是通过字符串来匹配的。</p>

<p>当我们想要这个服务的实例时，我们需要创建一个同名的参数。而在我们编写代码时，常常因为单纯 miss 导致服务注入的失败，不得不在检查我们的代码。</p>

<p>而 Angular 中，我们使用 Class 或者 Type 作为我们的 key 或者换个词 token。</p>

<p>在 Angular 中，构造函数参数的类型 AuthService 起到两个作用：其一是用来给 TypeScript 识别变量类型，让我们在编写代码时 IDE 可以通过 . 来访问其中的成员。其二就是就是 Angular 通过这个 Type 声明在依赖注入注册中寻找匹配的对象。</p>

<p>所以在 Angular 中，我们创建一个 service 就直接创建一个 Class。</p>

<h2 id="toc_2">如何使用 InjectionToken</h2>

<p>我们通过使用一个消息通知库来学习如何使用 InjectionToken。</p>

<h3 id="toc_3">如何在 Angular 中使用 toastr</h3>

<p><a href="https://www.npmjs.com/package/toastr">toastr</a> 是一个通知 Jquery 库，目前已经有支持 Angular 版本的 <a href="https://www.npmjs.com/package/ngx-toastr">ngx-toastr</a> 提供使用，但是如果想使用原生的 toastr 我们该如何做呢。</p>

<p>根据官方的方法安装 toastr 库到我们的工程中，那如何在 Angular 中使用呢？</p>

<p>首先在 Angular 的 webpack 文件中导入 toastr 的 style 和 script：</p>

<pre><code class="language-javascript">&quot;styles&quot;: [
    &quot;node_modules/toastr/build/toastr.min.css&quot;,
    &quot;src/styles.css&quot;
],
&quot;scripts&quot;: [
    &quot;node_modules/jquery/dist/jquery.min.js&quot;,
    &quot;node_modules/toastr/build/toastr.min.js&quot;
]
</code></pre>

<p>此时编译后的 SPA 中已经有了我们需要的 toastr 对象，我们可以在页面的控制台中查看 window.toastr 对象：</p>

<p><img src="media/16166681233612/16166682192597.jpg" alt=""/></p>

<p>但是这时候在使用 toastr 对象时，IDE 会报错：</p>

<p><img src="media/16166681233612/16166682041574.jpg" alt=""/></p>

<p>原因很简单，是因为 TypeScript 并不知道我们的 toastr 对象，这时候需要声明一下这个对象：</p>

<pre><code class="language-typescript">declare let toastr: any;
</code></pre>

<p>这时候就可以顺利使用 toastr 库中的成员方法来弹出我们的消息提示框了。</p>

<h3 id="toc_4">添加 toastr 服务</h3>

<p>在一个工程中，我们肯定会不止一次的进行 HTTP 请求或者其他一些需要弹出消息提示框的情况，但每次都需要声明一个 toastr 对象有点太麻烦了，我们可以创建下面这个类注册为我们的服务：</p>

<pre><code class="language-typescript">import { Injectable } from &#39;@angular/core&#39;;

declare let toastr: any;

@Injectable()
export class ToastrService {
    success(message: string, title?: string) {
        toastr.success(message, title);
    }
    info(message: string, title?: string) {
        toastr.info(message, title);
    }
    warning(message: string, title?: string) {
        toastr.warning(message, title);
    }
    error(message: string, title?: string) {
        toastr.error(message, title);
    }
}
</code></pre>

<p>这样我们也能过滤掉 toastr 中其他不必要的成员方法，方便项目中的同事使用。</p>

<h3 id="toc_5">InjectionToken 注册服务</h3>

<p>回顾一下上文中 Angular 的服务：</p>

<blockquote>
<p>我们创建一个 service 就直接创建一个 Class</p>
</blockquote>

<p>我们并没有创建一个可导出 toastr Class，并没有去用它作为 key 在我们的 Module 中注册它，我们不能在 Module 中导入 toastr，并将其添加到 providers 数组中。</p>

<p>因此我们如下修改我们的 toastr.service.ts：</p>

<pre><code class="language-typescript">import { InjectionToken } from &quot;@angular/core&quot;;

export let TOASTR_TOKEN = new InjectionToken&lt;Toastr&gt;(&#39;toastr&#39;);

export interface Toastr {
    success(msg: string, title?: string): void;
    info(msg: string, title?: string): void;
    warning(msg: string, title?: string): void;
    error(msg: string, title?: string): void;
}
</code></pre>

<p>使用 InjectionToken 构造函数 new 一个 TOASTR_TOKEN 对象，并指定其接口构造。这样就创建了我们的 InjectionToken。</p>

<p>然后在我们的 Module 中注册 toastr 服务：</p>

<pre><code class="language-typescript">import { IToastr, TOASTR_TOKEN } from &#39;./common/toastr.service&#39;;

declare let toastr: IToastr;

@NgModule({
  ...
  providers: [
    { provide: TOASTR_TOKEN, useValue: toastr }
  ]
  ...
})
</code></pre>

<p>首先导入我们的 IToastr 接口和 TOASTR_TOKEN InjectionToken，声明 toastr 对象，在 providers 数组中注册，这里注册时没有像之前的 AuthService 服务，只使用了类型。AuthService 的注册其实只是 <code>{ provide: AuthService , useClass: AuthService }</code> 的简写（关于 useClass 和 userValue 后面再详细对比）。provide 的值就是 token，而 useValue 的值就是 Angular 为我们创建的实例。</p>

<h3 id="toc_6">注入 InjectionToken 服务</h3>

<p>接下来我们看看 InjectionToken 注册的服务如何使用。</p>

<pre><code class="language-typescript">import { Component, OnInit, Inject } from &#39;@angular/core&#39;;
import { IToastr, TOASTR_TOKEN } from &#39;../common/toastr.service&#39;;
constructor(
  private auth: AuthService,
  private router: Router,
  @Inject(TOASTR_TOKEN) private toastr: IToastr) {
}
</code></pre>

<p>除了导入我们的接口 IToastr 和 TOASTR_TOKEN Token 之外，还需要从 <code>@angular/core</code> 中导入 Inject。</p>

<pre><code class="language-typescript">/**
 * Type of the Inject metadata.
 *
 * @publicApi
 */
export declare interface Inject {
    /**
     * A [DI token](guide/glossary#di-token) that maps to the dependency to be injected.
     */
    token: any;
}
</code></pre>

<p>我们可以看到 Inject 的参数是 token，当我们注入参数 toastr 时，IToastr 并不是我们依赖注入的 Token，而只是用来智能感知。真正指定了 Token 的是装饰器 @Inject()。</p>

<p>这样我就可以在我们的类中拿到 toastr 实例，像普通的 service 一样使用它：</p>

<pre><code class="language-typescript">  saveProfile(profileFormValue) {
    if (this.profileForm.valid) {
      this.auth.updateUser(profileFormValue.firstName, profileFormValue.lastName);
      this.toastr.success(&#39;Profile Saved&#39;);
      this.router.navigate([&#39;/events&#39;]);
    }
  }
</code></pre>

<h2 id="toc_7">四种 Provider</h2>

<p>上面我们已经见过两种 provider，useValue 和 useClass。</p>

<p>在 Angular 的 DI 中一共有四种 provider：</p>

<ul>
<li><a href="https://angular.io/api/core/ValueProvider">ValueProvider</a></li>
<li><a href="https://angular.io/api/core/ClassProvider">ClassProvider</a></li>
<li><a href="https://angular.io/api/core/ExistingProvider">ExistingProvider</a></li>
<li><a href="https://angular.io/api/core/FactoryProvider">FactoryProvider</a></li>
</ul>

<p>它们分别使用四种方式为 Token 提供一个实例。</p>

<h2 id="toc_8">总结</h2>

<p>Angular 是在注册时产生的实例，这样产生的实例将在注册所在作用域内存在。</p>

<p>Angular 依赖注入时是通过 Token 来查找实例。</p>

<p>常用的服务注入实际上是使用 ClassProvider 提供的实例，而其 Token 就是它的 Class，在依赖注入时，Angular 截获其 Class 并以它为 Token 寻找实例。</p>

<p>相信我们都明了依赖注入的设计模式，也明确它的优势。可是在我们之前从 AngularJs 开始到 Angular 板砖的路程中没有过仔细学习 Angular 依赖注入的本质。这让我们在开发中只会复制粘贴代码，导致报错时让我们无从下手时，只能通过查阅文档的案例，来对比自己的代码中具体有哪些错误。但是当知道原理后，我们不但能清晰的写出依赖注入的代码，还可以灵活选用不同的 Provider，写出更漂亮的代码。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Angular 变更检测——它到底是如何工作的？]]></title>
    <link href="2019919.xyz/16164996860696.html"/>
    <updated>2021-03-23T19:41:26+08:00</updated>
    <id>2019919.xyz/16164996860696.html</id>
    <content type="html"><![CDATA[
<p>原文：<a href="https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/">Angular Change Detection - How Does It Really Work?</a></p>

<p>与 AngularJs 中的等效方法相比，Angular 变更检测机制更加透明且易于推理。但是，在某些情况下（例如进行性能优化时），我们的确需要了解底层做了什么。因此，让我们通过研究以下主题来更深入地研究变更检测：</p>

<ul>
<li>变更检测是如何实现的？</li>
<li>Angular 变更检测器是什么样的，我能看到它吗？</li>
<li>默认变更检测机制如何工作</li>
<li>打开 / 关闭变更检测，并手动触发</li>
<li>避免变更检测循环：生产与开发模式</li>
<li><code>OnPush</code> 变更检测模式到底做了什么？</li>
<li>使用 Immutable.js 简化 Angular 应用程序的构建</li>
<li>总结</li>
</ul>

<p>如果你在寻找更多关于 <code>OnPush</code> 变更检测的信息，看一下这篇文章 <a href="https://blog.angular-university.io/onpush-change-detection-how-it-works">Angular OnPush Change Detection and Component Design - Avoid Common Pitfalls</a>。</p>

<h2 id="toc_0">变更检测是如何实现的</h2>

<p>Angular 可以检测组件数据何时变更，然后自动重新渲染视图以反映该变更。但是，如何在诸如单击按钮之类的低级事件发生之后做到这一点，这可以在页面任何地方发生吗？</p>

<p>要了解它是如何工作的，我们首先需要意识到在 JavaScript 中整个运行时可以被设计重写。如果需要，我们可以重写 <code>String</code> 或 <code>Number</code> 中的函数。</p>

<h3 id="toc_1">重写浏览器默认机制</h3>

<p>Angular 在启动时会修补几个低级浏览器 API，例如 <code>addEventListener</code>，这是用于注册所有浏览器事件（包括单击处理程序）的浏览器功能。Angular 会用下面等效的新版本替换 <code>addEventListener</code>：</p>

<pre><code class="language-javascript">// this is the new version of addEventListener
function addEventListener(eventName, callback) {
     // call the real addEventListener
     callRealAddEventListener(eventName, function() {
        // first call the original callback
        callback(...);     
        // and then run Angular-specific functionality
        var changed = angular.runChangeDetection();
         if (changed) {
             angular.reRenderUIPart();
         }
     });
}
</code></pre>

<p>新版本的 <code>addEventListener</code> 为任何事件处理程序增加了更多功能：其不仅调用已注册的回调，而且 Angular 还可以运行变更检测并更新 UI。</p>

<h3 id="toc_2">低级运行时补丁是如何工作的？</h3>

<p>浏览器 API 的低级补丁是由 Angular 的 <a href="https://github.com/angular/zone.js/">Zone.js</a> 库完成的。了解什么是 zone 很重要。</p>

<p>zone 无非是一个执行上下文，它可以在多个 JavaScript VM <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>执行回合后幸存下来。这是一种通用机制，我们可以用来向浏览器添加额外的功能。Angular 用 Zone 来触发变更检测，但另一种可能的用途是进行应用程序性能分析，或跟踪跨多个 VM 轮次运行的长堆栈跟踪。</p>

<h3 id="toc_3">支持浏览器异步 API</h3>

<p>修补以下常用的浏览器机制，以支持变更检测：</p>

<ul>
<li>全部浏览器事件（click、mouseover、keyup 等）</li>
<li><code>setTimeout()</code>  和 <code>setInterval()</code></li>
<li>Ajax HTTP 请求</li>
</ul>

<p>实际上，Zone.js 修补了许多其他浏览器 API，以明了地触发 Angular 变更检测，例如 Websockets。看看<a href="https://github.com/angular/zone.js/tree/master/test/patch"> Zone.js 测试说明</a>来了解当前支持的功能。</p>

<p>这种机制的局限性之一在于，如果由于某些原因 Zone.js 不支持异步浏览器 API，那么将不会触发变更检测。例如，IndexedDB 回调就是这种情况。</p>

<p>这就解释了变更检测是如何触发的，但是一旦触发，它实际上如何工作？</p>

<h3 id="toc_4">变更检测树</h3>

<p>每个 Angular 组件都有一个关联的创建于应用程序启动时的变更检测器。例如下面 <code>TodoItem</code> 组件：</p>

<pre><code class="language-javascript">@Component({
    selector: &#39;todo-item&#39;,
    template: `&lt;span class=&quot;todo noselect&quot; 
       (click)=&quot;onToggle()&quot;&gt;{{todo.owner.firstname}} - {{todo.description}}
       - completed: {{todo.completed}}&lt;/span&gt;`
})
export class TodoItem {
    @Input()
    todo:Todo;

    @Output()
    toggle = new EventEmitter&lt;Object&gt;();

    onToggle() {
        this.toggle.emit(this.todo);
    }
}
</code></pre>

<p>如果切换 Todo 状态，则此组件将接收 Todo 对象作为输入并发生事件。为了使示例更有趣，<a href="https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo.ts#L11">Todo 类</a>包含嵌套对象：</p>

<pre><code class="language-javascript">export class Todo {
    constructor(public id: number, 
        public description: string, 
        public completed: boolean, 
        public owner: Owner) {
    }
}
</code></pre>

<p>我们可以看到 Todo 有一个属性 <code>owner</code>，它本身是一个具有两个属性的对象：firstname 和 lastname。</p>

<h3 id="toc_5">Todo Item 变更检测器是什么样子的？</h3>

<p>我们实际上可以在运行时看到变更检测器的外观！ 可以通过访问某个属性查看它，只需在 Todo 类中添加一些代码以<a href="https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo%20.ts%EF%BC%83L11">触发断点</a>。</p>

<p>执行到断点时，我们可以遍历堆栈跟踪并查看实际的变更检测：</p>

<p><img src="https://raw.githubusercontent.com/jhades/blog.angular-university.io/master/ng2-change-detection/images/change.jpg" alt="What does an Angular change detector look like"/></p>

<p>不用担心，你将永远不必调试此代码！也不涉及任何魔术，它只是在应用程序启动时构建的普通 JavaScript 方法。但是它是做什么的呢？</p>

<h2 id="toc_6">默认变更检测机制如何工作？</h2>

<p>乍一看，此方法可能看起来很奇怪，并且其全部变量命名奇怪。但是，通过更深入地研究它，我们发现它的操作非常简单：对于模板中使用的每个表达式，它会将表达式中使用的属性的当前值与该属性的先前值进行比较。</p>

<p>如果前后的属性值不同，它将把 isChanged 设置为 true，就是这样！差不多了，它是通过使用名为 <code>looseNotIdentical()</code> 的方法进行值比较，使用 <code>===</code> 比较但指定 NaN 相等逻辑（请参阅 <a href="https://github.com/angular/angular/blob/50548fb5655bca742d1056ea91217a3b8460db08/modules/%20angular2%20/%20src%20/%20facade%20/%20lang.ts%EF%BC%83L367">here</a>）。</p>

<h3 id="toc_7">嵌套对象的 <code>owner</code> 如何处理？</h3>

<p>我们可以在变更检测器代码中看到 <code>owner</code> 嵌套对象的属性同样被检测差异。但是只比较 firstname 属性，不比较 lastname 属性。</p>

<p>这是因为组件模板中未使用 lastname （请参阅 <a href="https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo_item.ts#L7">here</a>）！ 同样，出于相同原因，未比较 Todo 的顶级 id 属性。这样，我们可以放心地说：</p>

<blockquote>
<p>默认情况下，Angular 变更检测通过检测模板表达式的值是否已更改来工作。这是针对所有组件都做的处理。</p>
</blockquote>

<p>我们还可以得出以下结论：</p>

<blockquote>
<p>默认情况下，Angular 不会进行深度对象比较来检测变更，它仅考虑模板使用的属性。</p>
</blockquote>

<h3 id="toc_8">为什么默认情况下变更检测如此工作？</h3>

<p>Angular 的主要目标之一是更加透明和易于使用，从而使框架用户不必费劲地调试框架并了解内部机制，就能够有效地使用它。</p>

<p>如果你熟悉 AngularJs，想象一下 <code>$digest()</code> 和 <code>$apply()</code> 以及何时使用它们或不使用它们的所有陷阱。Angular 的主要目标之一就是避免这种情况。</p>

<h3 id="toc_9">引用如何比较?</h3>

<p>事实上 Javascript 对象是可变的，Angular 希望为这些对象提供开箱即用的全面支持。</p>

<p>想象一下，如果 Angular 默认变更检测机制将基于组件输入的引用比较而不是默认机制，那将会是什么样子？ 即使是像 TODO 应用程序这样简单的东西，构建起来也很棘手：开发人员必须非常小心地创建新的 Todo，而不是简单地更新属性。</p>

<p>但是，正如我们将看到的，如果我们确实需要的话，仍然可以自定义 Angular 变更检测。</p>

<h3 id="toc_10">性能如何？</h3>

<p>请注意，todo list 组件的变更检测器如何显式引用 <code>todos</code> 属性。</p>

<p>做到这一点的另一种方法是在组件的属性之间动态循环，从而使代码通用而不是特定于组件。这样，我们就不必在启动时为每个组件构建一个变更检测器！ 那么这是怎样一回事呢？</p>

<h3 id="toc_11">快速浏览虚拟机内部</h3>

<p>所有这些都与 Javascript 虚拟机的工作方式有关。尽管通常 VM 即时编译器无法轻易地将用于动态比较属性的代码优化为本机代码。</p>

<p>这与变更检测器的特定代码不同，变更检测器确实显式访问每个组件输入属性。该代码非常类似于我们手工编写的代码，并且很容易被虚拟机转换为本地代码。</p>

<p>使用生成的显式的检测器的最终结果是一种变化检测机制，该机制非常快（比 AngularJs 更快），可预测且易于推理。</p>

<p>但是，如果遇到性能困境，是否有一种方法可以优化变更检测？</p>

<h2 id="toc_12">OnPush 变更检测模式</h2>

<p>如果我们的 Todo list 真的很大，我们可以配置 <a href="https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo_list.ts">TodoList</a> 组件仅在 Todo list 变更时才进行更新。这可以通过将组件变更检测策略改为 <code>OnPush</code> 来完成：</p>

<pre><code class="language-javascript">@Component({
    selector: &#39;todo-list&#39;,
    changeDetection: ChangeDetectionStrategy.OnPush,
    template: ...
})
export class TodoList {
    ...
}
</code></pre>

<p>现在让我们给应用程序添加一对按钮：一个按钮通过直接对列表的第一条进行改变来切换，另一个按钮将 Todo 添加到整个列表中。代码如下：</p>

<pre><code class="language-javascript">@Component({
    selector: &#39;app&#39;,
    template: `&lt;div&gt;
                    &lt;todo-list [todos]=&quot;todos&quot;&gt;&lt;/todo-list&gt;
               &lt;/div&gt;
               &lt;button (click)=&quot;toggleFirst()&quot;&gt;Toggle First Item&lt;/button&gt;
               &lt;button (click)=&quot;addTodo()&quot;&gt;Add Todo to List&lt;/button&gt;`
})
export class App {
    todos:Array = initialData;

    constructor() {
    }

    toggleFirst() {
        this.todos[0].completed = ! this.todos[0].completed;
    }

    addTodo() {
        let newTodos = this.todos.slice(0);
        newTodos.push( new Todo(1, &quot;TODO 4&quot;, 
            false, new Owner(&quot;John&quot;, &quot;Doe&quot;)));
        this.todos = newTodos;
    }
}
</code></pre>

<p>现在让我们看看两个新按钮的行为：</p>

<ul>
<li>第一个按钮“Toggle First Item”不起作用！ 这是因为 <code>toggleFirst()</code> 方法直接使列表的元素发生改变。
<code>TodoList</code> 无法检测到它，因为它的输入引用 <code>todos</code> 没有改变。</li>
<li>第二个按钮确实起作用！ 请注意，方法 <code>addTodo()</code> 创建了 todo list 的副本，然后向该副本添加了一个项目，最后用复制的 list 替换了 todos 成员变量。这会触发变更检测，因为该组件在其输入中检测到引用变更：它收到了一个新列表！</li>
<li>在第二个按钮中，直接修改 todo list 将不起作用！我们需要一个新列表。</li>
</ul>

<h3 id="toc_13"><code>OnPush</code> 真的只是通过引用比较比较输入吗?</h3>

<p>事实并非如此，如果你尝试通过单击来切换 todo，它仍然可以使用！即使你将 <a href="https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo_item.ts">TodoItem</a> 也切换为 <code>OnPush</code>。这是因为 <code>OnPush</code> 不仅仅检查组件输入中的更改：如果组件发生事件，该事件也将触发变更检测。</p>

<p>根据<a href="http://victorsavkin.com/post/110170125256/change-detection-in-angular-2">引用</a>自 Victor Savkin 的博客：</p>

<blockquote>
<p>当使用 OnPush 检测器时，框架将在其任何输入属性发生更改时，当它触发事件或当 Observable 触发事件时检查 OnPush 组件。</p>
</blockquote>

<p>尽管可以提供更好的性能，但如果与可变对象一起使用，则使用 <code>OnPush</code> 的代价是很高的复杂性。它可能会引入难以推理和重现的错误。但是有一种方法可以使 <code>OnPush</code> 的使用成为可行的。</p>

<h3 id="toc_14">使用 Immutable.js 简化 Angular 应用程序的构建</h3>

<p>如果我们仅使用不可变对象和不可变列表构建应用程序，则可以在所有地方使用 <code>OnPush</code>，而不会陷入变更检测错误的风险。这是因为对于不可变对象，修改数据的唯一方法是创建一个新的不可变对象并替换先前的对象。对于不可变的对象，我们可以保证：</p>

<ul>
<li>一个新的不可变对象将始终触发 <code>OnPush</code> 变更检测</li>
<li>我们不能忘记创建对象的新副本而意外地产生错误，因为修改数据的唯一方法是创建新对象</li>
</ul>

<p>对于不可变的一个不错的选择是使用 <a href="https://facebook.github.io/immutable-js/">Immutable.js</a> 库。该库提供了用于构建应用程序的不可变基元，例如不可变对象（Map）和不可变列表。</p>

<p>该库也可以以类型安全的方式使用，阅读<a href="https://blog.angular-university.io/angular-2-application-architecture-building-flux-like-apps-using-redux-and-immutable-js-js/">之前的文章</a>，以获取有关如何执行此操作的示例。</p>

<h2 id="toc_15">避免变更检测循环：生产与开发模式</h2>

<p>Angular 变更检测的重要属性之一是，它与 AngularJs 不同，它强制执行单向数据流：当更新控制器类上的数据时，变更检测将运行并更新视图。</p>

<p>但是视图的更新本身并不会触发进一步的更改，而这些更改又会触发视图的进一步更新，从而在 AngularJs 中创建了 digest cycle。</p>

<h3 id="toc_16">如何在Angular中触发变更检测循环？</h3>

<p>一种方法是使用生命周期回调。例如，在 <a href="https://github.com/jhades/blog.angular-university.io/blob/master/ng2-change-detection/src/todo_list.ts#L46">TodoList</a> 组件中，我们可以触发回调到另一个组件改变其中一个绑定：</p>

<pre><code class="language-javascript">ngAfterViewChecked() {
    if (this.callback &amp;&amp; this.clicked) {
        console.log(&quot;changing status ...&quot;);
        this.callback(Math.random());
    }
}
</code></pre>

<p>错误消息将显示在控制台中：</p>

<pre><code class="language-text">EXCEPTION: Expression &#39;{{message}} in App@3:20&#39; has changed after it was checked
</code></pre>

<p>仅当我们在开发模式下运行 Angular 时，才会引发此错误消息。如果启用生产模式会怎样？</p>

<pre><code class="language-javascript">@NgModule({
    declarations: [App],
    imports: [BrowserModule],
    bootstrap: [App]
})
export class AppModule {}
</code></pre>

<p>在生产模式下，不会引发该错误，并且不会发现问题。</p>

<h3 id="toc_17">变更检测问题经常发生吗？</h3>

<p>我们的确必须竭尽全力触发变更检测循环，但以防万一最好在开发阶段始终使用开发模式，因为这样可以避免问题。</p>

<p>这种保证是以 Angular 始终运行变更检测两次为代价的，这是第二次检测此类情况。在生产模式下，变更检测仅运行一次。</p>

<h2 id="toc_18">打开 / 关闭变更检测并手动触发</h2>

<p>在某些特殊情况下，我们确实希望关闭变更检测。想象一下一种情况，其中大量数据通过 Websocket 从后端到达。我们可能只想每 5 秒更新一次 UI 的特定部分。为此，我们首先将变更检测器注入到组件中：</p>

<pre><code class="language-javascript">constructor(private ref: ChangeDetectorRef) {
    ref.detach();
    setInterval(() =&gt; {
      this.ref.detectChanges();
    }, 5000);
  }
</code></pre>

<p>如我们所见，我们只是拆下了变更检测器，这有效地关闭了变更检测。然后，我们只需调用 <code>detectChanges()</code> 每 5 秒手动触发一次。</p>

<p>现在，让我们快速总结一下有关 Angular 变更检测所需的所有知识：它是什么，它如何工作以及变更检测主要的可用类型是什么。</p>

<h2 id="toc_19">总结</h2>

<p>Angular 变更检测是内置的框架功能，可确保组件数据与其 HTML 模板视图之间的自动同步。</p>

<p>变更检测通过检测常见的浏览器事件（例如鼠标单击，HTTP 请求和其他类型的事件），并确定是否需要更新每个组件的视图来起作用。</p>

<p>变更检测有两种类型：</p>

<ul>
<li>默认变更检测：Angular 通过比较事件发生之前和之后的所有模板表达式值（对于组件树的所有组件）来决定是否需要更新视图。</li>
<li>OnPush 变更检测：这是通过检测一些新数据是否已通过组件输入或使用异步管道订阅的 Observable 显式推送到组件中而起作用的。（还有触发事件）</li>
</ul>

<p>Angular的<strong>默认</strong>变更检测机制实际上与 AngularJs 相似：它比较浏览器事件前后的模板表达式的值，以查看是否有所更改。<strong>所有</strong>组件都这样做。但是也有一些重要的区别：</p>

<p>其一，没有变更检测循环，也没有像 AngularJs 中的 digest cycle。这允许仅通过查看其模板和其控制器就可以推断出每个组件。</p>

<p>另一个区别是，由于构建了变更检测器，因此组件中检测变更的机制要快得多。</p>

<p>最后，与 AngularJs 不同，变更检测机制是可以自定义的。</p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>JavaScript VM，JavaScript 虚拟机，即 JavaScript 引擎。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一章 让爱融入生活]]></title>
    <link href="2019919.xyz/16160615801436.html"/>
    <updated>2021-03-18T17:59:40+08:00</updated>
    <id>2019919.xyz/16160615801436.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p>听了你的话，</p>

<p>我仿佛受了审判，</p>

<p>无比委屈，</p>

<p>又无从分辩，</p>

<p>在离开前，</p>

<p>我想问，</p>

<p>那真的是你的意思吗？</p>

<p>在自我辩护前，</p>

<p>在带着痛苦或恐惧质问前，</p>

<p>在我用言语筑起心灵之墙前，</p>

<p>告诉我，</p>

<p>我听明白了吗？</p>
</blockquote>

<p>搞清楚自己的理解与对方表达的意思一致吗？我经常因误解对方的话或是对方话术中某些词语触及到我的敏感点而忽略对方的主题，导致矛盾升级。</p>

<blockquote>
<p>我心里有话要说，</p>

<p>那些话对我如此重要，</p>

<p>如果言语无法传达我的心声，</p>

<p>请你帮我获得自由好吗？</p>

<p>如果你以为我想羞辱你，</p>

<p>如果你认定我不在乎你，</p>

<p>请透过我的言语，</p>

<p>倾听我们共有的情感。</p>
</blockquote>

<p>换一个角色，我在使用语言时，可能会伤害到别人，但这并不是我的本意，那此时如果引起了别人的愤怒，我需要确定对方是否有对我的误解，来重新描述我想表达的主题。</p>

<h2 id="toc_0">引言</h2>

<h2 id="toc_1">人生的抉择</h2>

<blockquote>
<p>非暴力沟通指导我们转变谈话和聆听的方式。我们不再条件反射式地反应，而是去明了自己的观察、感受和愿望，有意识地使用语言</p>
</blockquote>

<p>改变自己条件反射式地反应，有意识地使用语言。（比如老婆在家问我一些小事的时候，第一反应直接回复“不知道”，这在情理上觉得没什么问题，但是沟通后得知，对方看我条件反射地回复“不知道”有一种没有当回事的感觉，这里如果回答一些提示性的回复更好，比如询问什么东西在哪时，我可以说”在电脑桌和床头柜上都没有看到它。“）</p>

<blockquote>
<p>听到批评时，我们一般会申辩、退缩或反击。</p>
</blockquote>

<p>申辩：有时内心明白对方的批评是对的，但是自己找理由说自己是对的，对方的观察理解是错误的。<br/>
退缩：不搭理对方。<br/>
反击：指出对方同样拥有这样的错误，或者对方有另外一种错误，以这种方式吵架。</p>

<blockquote>
<p>非暴力沟通的使用，并不需要沟通的对象熟悉非暴力沟通，或对我们心存善意。如果我们遵循非暴力沟通的原则，乐于互助，并表明那是唯一的动机，那么，他人也会加入我们，最终形成良好的互动。</p>
</blockquote>

<p>所以在学习非暴力沟通的时候谨记，以改善自我为中心。</p>

<h2 id="toc_2">非暴力沟通的要素</h2>

<p>观察 感受 需要 请求</p>

<blockquote>
<p>要点是，清楚地表达观察结果，而不判断或评估。接着，表达感受，例如受伤、害怕、喜悦、开心、气愤等等。然后，说出哪些需要导致那样的感受。</p>
</blockquote>

<p>todo 什么是判断和评估？<br/>
todo 表达要表达出自己明确的请求</p>

<h2 id="toc_3">非暴力沟通的运用</h2>

<h2 id="toc_4">小结</h2>

<p>当对方处于愤怒的心情谩骂发牢骚时，我想让对方理解自己的目的是不可能的，首先要理解对方的痛苦，让他感受到我在倾听我在理解我在努力感受他所受到的痛苦，当对方感受到我有领会它的意思时，对方才有可能会愿意听我讲出我的目的。（同事中有这样的人）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[States and Fates]]></title>
    <link href="2019919.xyz/16129618605374.html"/>
    <updated>2021-02-10T20:57:40+08:00</updated>
    <id>2019919.xyz/16129618605374.html</id>
    <content type="html"><![CDATA[
<p>This document helps clarify the different adjectives surrounding promises, by dividing them up into two categories: <strong>states</strong> and <strong>fates</strong>.</p>

<blockquote>
<p>本文档阐明围绕 Promise 的各种形容词，把它们分为两部分：<strong>状态</strong>和<strong>命运</strong>。</p>
</blockquote>

<h2 id="toc_0">Overview and Operational Definitions</h2>

<h3 id="toc_1">States</h3>

<p>Promises have three possible mutually exclusive states: fulfilled, rejected, and pending.</p>

<blockquote>
<p>Promise 有三种可能的互斥独立状态：已兑现、已拒绝、待定。</p>
</blockquote>

<ul>
<li>A promise is <em>fulfilled</em> if <code>promise.then(f)</code> will call <code>f</code> &quot;as soon as possible.&quot;</li>
</ul>

<blockquote>
<ul>
<li>如果 <code>promise.then(f)</code> 会马上调用 <code>f</code>，那么 promise 是已兑现状态。</li>
</ul>
</blockquote>

<ul>
<li>A promise is <em>rejected</em> if <code>promise.then(undefined, r)</code> will call <code>r</code> &quot;as soon as possible.&quot;</li>
</ul>

<blockquote>
<ul>
<li>如果 <code>promise.then(undefined, r)</code> 会马上调用 <code>r</code>，那么 promise 是已拒绝状态。</li>
</ul>
</blockquote>

<ul>
<li>A promise is <em>pending</em> if it is neither fulfilled nor rejected.</li>
</ul>

<blockquote>
<ul>
<li>如果它既不是已兑现也不是已拒绝，那么 promise 是待定状态。</li>
</ul>
</blockquote>

<p>We say that a promise is <em>settled</em> if it is not pending, i.e. if it is either fulfilled or rejected. Being settled is not a state, just a linguistic convenience.</p>

<blockquote>
<p>如果 promise 不是待定状态，我们说它<em>已敲定</em>，无论它是已兑现还是已拒绝。已敲定不是一个状态，知识一个语言上的便利。</p>
</blockquote>

<h3 id="toc_2">Fates</h3>

<p>Promises have two possible mutually exclusive fates: resolved, and unresolved.</p>

<blockquote>
<p>Promise 有两种可能的互斥独立命运：已决议，未决议。</p>
</blockquote>

<ul>
<li>A promise is <em>resolved</em> if trying to resolve or reject it has no effect, i.e. the promise has been &quot;locked in&quot; to either follow another promise, or has been fulfilled or rejected.</li>
</ul>

<blockquote>
<ul>
<li>如果 promise 已决议，尝试决议或拒绝它是没有任何效果，promise 被接下来其他 promise 锁定，或者已被兑现或拒绝。</li>
</ul>
</blockquote>

<ul>
<li>A promise is <em>unresolved</em> if it is not resolved, i.e. if trying to resolve or reject it will have an impact on the promise.</li>
</ul>

<blockquote>
<p>如果</p>
</blockquote>

<p>A promise can be &quot;resolved to&quot; either a promise or thenable, in which case it will store the promise or thenable for later unwrapping; or it can be resolved to a non-promise value, in which case it is fulfilled with that value.</p>

<h3 id="toc_3">Relating States and Fates</h3>

<p>A promise whose fate is resolved can be in any of the three states:</p>

<ul>
<li>Fulfilled, if it has been resolved to a non-promise value, or resolved to a thenable which will call any passed fulfillment handler back as soon as possible, or resolved to another promise that is fulfilled.</li>
<li>Rejected, if it has been rejected directly, or resolved to a thenable which will call any passed rejection handler back as soon as possible, or resolved to another promise that is rejected.</li>
<li>Pending, if it has been resolved to a thenable which will call neither handler back as soon as possible, or resolved to another promise that is pending.</li>
</ul>

<p>A promise whose fate is unresolved is necessarily pending.</p>

<p>Note that these relations are recursive, e.g. a promise that has been resolved to a thenable which will call its fulfillment handler with a promise that has been rejected is itself rejected.</p>

<h2 id="toc_4">Relation to the Spec</h2>

<p>A promise&#39;s state is reflected in its [[PromiseState]] internal slot.</p>

<p>A promise&#39;s fate is stored implicitly as part of its &quot;resolving functions.&quot;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 深浅拷贝]]></title>
    <link href="2019919.xyz/16124460113427.html"/>
    <updated>2021-02-04T21:40:11+08:00</updated>
    <id>2019919.xyz/16124460113427.html</id>
    <content type="html"><![CDATA[
<p>在数组章节提到数组的展开运算符时，作者举例说明展开运算符可以进行拷贝，原为如下：</p>

<blockquote>
<p>The spread operator is a convenient way to create a (shallow) copy of an array:</p>
</blockquote>

<pre><code class="language-javascript">let original = [1,2,3];
let copy = [...original];
copy[0] = 0;  // Modifying the copy does not change the original
original[0]   // =&gt; 1
</code></pre>

<p>copy 对象为 original 展开后的数组字面量，但是拷贝后的数组修改了序列为 0 的元素的值，但是被拷贝数组中序列为 0 的元素的值并没有被改变，作者称这样的拷贝为浅拷贝，</p>

<p>在我的印象中深浅拷贝是如下形式的：</p>

<ul>
<li>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，在修改了拷贝元，拷贝先也会跟着改变。</li>
<li>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，拷贝元和拷贝之间脱离了关系。</li>
</ul>

<p>但是这个实例中，作者只测试了拷贝先的修改，我又做了如下测试：</p>

<pre><code class="language-javascript">let original = [1,2,3];
let copy = [...original];
original[0] = 10;
copy[0]  // =&gt; 1
</code></pre>

<p>就是说在修改被拷贝数组时，拷贝后的数组也不跟随改变。<br/>
所以作者的浅拷贝指的是什么呢？<br/>
问题需要最根溯源，从基础来解决问题，下面就先来回溯下数据类型。</p>

<h2 id="toc_0">JavaScript 数据类型</h2>

<p>最新 ECMAScript 标准定义了九种类型：</p>

<ul>
<li>六个数据类型</li>
</ul>

<pre><code class="language-javascript">typeof undefined === &#39;undefined&#39;;
typeof true === &#39;boolean&#39;;
typeof 123 === &#39;number&#39;;
typeof &#39;str&#39; === &#39;string&#39;;
typeof 123n ===&#39;bigint&#39;;
typeof Symbol(&#39;symbol&#39;) === &#39;symbol&#39;;
</code></pre>

<ul>
<li>两个结构类型</li>
</ul>

<pre><code class="language-javascript">typeof {} === &#39;object&#39;;
typeof (() =&gt; {}) === &#39;function&#39;;
</code></pre>

<ul>
<li>结构根</li>
</ul>

<pre><code class="language-javascript">typeof null === &#39;object&#39;;
</code></pre>

<p>以上九种类型又分为原始值（Primitive Value）和对象（Object）：</p>

<ul>
<li>Primitive values
<ul>
<li>Boolean type</li>
<li>Null type</li>
<li>Undefined type</li>
<li>Number type</li>
<li>BigInt type</li>
<li>String type</li>
<li>Symbol type</li>
</ul></li>
<li>Objects</li>
</ul>

<p>原始值（又名基本类型）其值存放在栈中，它的值无法被修改，当对基本类型进行操作时，会在新的空间内创建一个原始值。</p>

<p>对象也就是引用类型（又名复杂类型），它只在栈中保存其内存地址，指向存在堆中的数据，当对其进行修改时，栈内的地址进行改变，指向堆中另外的数据。</p>

<h2 id="toc_1">问题解决</h2>

<p>现在再回想一下深浅拷贝的定义就会发现，其只是针对复杂类型。也就是说在原文中所用示例在用展开运算符对 original 数组进行拷贝，而其拷贝的值是初始数组内的元素，而其元素只是 number 类型的原始值，因此这个实例无法展示其浅拷贝特性。</p>

<p>了解了这些后，针对引用类型做一个实验：</p>

<pre><code class="language-javascript">let original = [{a:1},2,3];
let copy = [...original];
original[0].a = 10;
copy[0].a; // =&gt; 10
</code></pre>

<p>这个例子中初始数组中的第一个元素为对象，是一个引用类型数据，拷贝后对其中的 a 属性进行修改，果然拷贝后的数组中第一个元素的 a 属性值也被修改。如此证明了展开运算符的确是浅拷贝。</p>

<h2 id="toc_2"> 总结</h2>

<p>这次的错误理解的根源是对基本概念掌握的不够牢固，这里展开运算符只是将初始数组中的元素展开到一个新的数组字面量中，因此并不是拷贝整个数组，而是拷贝数组中的每个元素，所以深浅拷贝的描述对象也是数组中的元素。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数中的展开运算符和解构]]></title>
    <link href="2019919.xyz/16108495213063.html"/>
    <updated>2021-01-17T10:12:01+08:00</updated>
    <id>2019919.xyz/16108495213063.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过函数声明和调用掌握函数的 this 值]]></title>
    <link href="2019919.xyz/16107633205948.html"/>
    <updated>2021-01-16T10:15:20+08:00</updated>
    <id>2019919.xyz/16107633205948.html</id>
    <content type="html"><![CDATA[
<p>函数的 this 对于基础薄弱的前端程序员一直是一个比较头疼的问题，在对 ES6 的模糊和对 ES6 之前的函数作用域不理解双重打击下，往往无法区分 this 值到底是什么，因而在编写程序时常常需要通过测试当前作用域的 this 是什么，再去使用，甚至是某些公司严格规定哪种方式去实现。</p>

<p>细细的看完了权威指南的第七版受益颇多，但是作者并没有拿出一个章节专门将相关内容进行汇总，这里就通过函数的声明和调用来总结下函数 this 值的几种情况。</p>

<h2 id="toc_0"> 函数定义</h2>

<p>函数的定义有多种方式来适应不同的使用场景：</p>

<ul>
<li>函数声明语句</li>
<li>函数表达式</li>
<li>箭头函数</li>
<li>嵌套函数</li>
<li>应用函数的构造函数 Function()</li>
</ul>

<h3 id="toc_1"> 函数声明语句</h3>

<p>与大多数声明语句一样，以关键字 + 名称的形式来进行声明，函数用关键字 function 来声明：</p>

<pre><code class="language-javascript">function testOutPut(){
    console.log(&#39;Hello world!&#39;);        
}
</code></pre>

<p>函数声明语句是函数名变成一个变量，这个变量的值是函数本身。这里实际上是声明了一个 testOutPut 变量，并讲函数对象赋值给 testOutPut。在 JavaScript 的运行时中，函数对象创建于该函数所在作用域的代码开始执行之前，也就是说，在同一个上下文中，可以先执行函数调用再进行函数语句声明。只是第一个函数作为值的概念的应用场景。</p>

<h3 id="toc_2"> 函数表达式</h3>

<p>函数表达式是一个赋值语句，将一个函数赋值给一个变量或常量。感觉函数表达式跟函数声明语句的运行时一样，但是如果先进行函数调用再进行函数表达式来定义函数将会异常。因为函数表达式在没有执行前并没有将函数赋值给变量，所以它也就不能被引用。</p>

<pre><code class="language-javascript">beforeDefined();
let beforeDefined = function(){console.log(1);}
// Uncaught ReferenceError: beforeDefined is not defined
</code></pre>

<p>函数表达式的函数名称是可选项，如果给函数表达式添加一个函数名，那这个函数的<em>局部函数作用域内</em>会包含该属性的函数名的对象，其值绑定的是该函数：</p>

<pre><code class="language-javascript">const f = function fact(x) {
    if (x &lt;= 1) return 1;
    else return x*fact(x-1);
};
</code></pre>

<p>只有在函数局部作用域内会有这个对象，有点闭包的感觉。</p>

<h3 id="toc_3"> 箭头函数</h3>

<p>箭头函数是 ES6 的新特性，在实际生产中非常常用。它支持很多简洁语法：</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; { return x + y; };
const sum = (x, y) =&gt; x + y;
const polynomial = x =&gt; x*x + 2*x + 3;
const constantFunc = () =&gt; 42;
</code></pre>

<p>注意参数和箭头之间不能换行，否则会引起歧义。<br/>
除此之外，它最大的特性就是它继承定义它环境的 this 值，我理解添加箭头函数的目的就是为了解决方法的嵌套函数 this 值为全局对象（严格模式下是 undefined）的缺陷：</p>

<pre><code class="language-javascript">let o = {
    a:1,
    m:function(){
        let self = this;
        console.log(this === o);
        f();
        function f(){
            console.log(this === o);
            console.log(self === o);
            console.log(this);
        }
    }
}
o.m();
// true
// flase
// true
// Window{...}
</code></pre>

<p>在 ES6 之前，我们需要通过闭包将 this 值保存在变量中使用，而有了箭头函数，可以直接继承 m 方法的 this 值：</p>

<pre><code class="language-javascript">o = {
    a:1,
    m:function(){
        let self = this;
        console.log(this === o);
        const f = () =&gt; {
            console.log(this === o);
            console.log(self === o);
            console.log(this);
        }
        f();
    }
}
o.m();
// true
// true
// true
// {a: 1, m: ƒ}
</code></pre>

<h3 id="toc_4"> 嵌套函数</h3>

<p>函数可以嵌套在其他函数内。嵌套函数可以访问包含它们函数的变量和参数（闭包）：</p>

<pre><code class="language-javascript">function first(){
    let strFirst = &quot;first&quot;;
    second();
    function second(){
        let strSecond = &quot;second&quot;;
        third();
        function third(){
            console.log(strFirst);
            console.log(strSecond);
        }
    }
}
first();
// first
// second
</code></pre>

<h3 id="toc_5"> Function() 构造函数创建函数</h3>

<p>Function() 函数的实参都是字符串，最后一个实参是函数体。</p>

<pre><code class="language-javascript">const f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);
</code></pre>

<p>这里想到一个情况，当函数名相同时是否会报错：</p>

<pre><code class="language-javascript">const f1 = new Function(&quot;x&quot;, &quot;x&quot;, &quot;return x;&quot;);
f1(1,2);
// 2
</code></pre>

<p>实际情况并没有，再次测试一下直接函数声明语句使用两个相同的参数，也没有报错：</p>

<pre><code class="language-javascript">function f2(x,x,y){return x*y};
f2(1,2,2);
// 4
</code></pre>

<p>这样看实际上跟函数外部用 var 声明的变量在函数中再次声明一个效果：</p>

<pre><code class="language-javascript">var x = 1;
function test(){let x = 2;console.log(x)};
console.log(x);
test();
// 1
// 2
</code></pre>

<p>函数变量声明多个相相同的变量名时，传递的实参值将反复覆盖同名参数。<br/>
Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，看书上的一个例子：</p>

<pre><code class="language-javascript">let scope = &quot;global&quot;;
function constructFunction() {
    let scope = &quot;local&quot;;
    return new Function(&quot;return scope&quot;);  // Doesn&#39;t capture local scope!
}
constructFunction()(); 
// &quot;global&quot;
</code></pre>

<h2 id="toc_6"> 函数调用</h2>

<p>函数调用和方法调用很常见就不再赘述，这里有三种很少使用的调用方式：</p>

<ul>
<li>构造函数调用</li>
<li>间接调用</li>
<li>隐式调用</li>
</ul>

<h3 id="toc_7"> 构造函数调用</h3>

<pre><code class="language-javascript">function CreatObj(){
    this[&#39;p&#39;] = &quot;property&quot;;    
}
o = new CreatObj();
// CreatObj {p: &quot;property&quot;}
</code></pre>

<p>构造函数创建一个新对象，并将这个对象作为它的上下文，也就是说构造函数中的 this 值是新创建的对象。<br/>
构造函数通常没有 return 语句，当显示的用 return 语句返回一个对象时，构造函数创建的对象将变成它 return 的对象，其他情况当没有返回值或返回一个原始值时，返回值都被忽略，返回它新创建的对象。</p>

<h3 id="toc_8">间接调用</h3>

<p>JavaScript 万物接对象，对象就有自己的属性和方法。同理，函数也是对象，也有自己的方法和属性，而 call() 和 apply() 方法也可以用来间接调用函数。</p>

<h4 id="toc_9">call() 方法</h4>

<p>MDN 中对于 call() 的解释已经很明了了：</p>

<blockquote>
<p>The call() method calls a function with a given this value and arguments provided individually.</p>
</blockquote>

<pre><code class="language-javascript">f.call(o, 1, 2);
</code></pre>

<p>这里不过是将 o 对象作为函数 f 调用的上下文，并传入两个实参 1 和 2 作为实参列表，也就是说它等同与下面的代码：</p>

<pre><code class="language-javascript">o.m = f;
o.m(1, 2);
delete o.m;
</code></pre>

<p>这里注意 delete 语句，目的就是说函数在使用 call 方法时只是临时将 o 作为 f 的上下文并调用。而函数还有个不涉及调用的方法 bind() 它可以返回一个新的函数对象，<code>f.bind(o);</code>，而这个对象将一直绑定 o 为函数 f 的 this 值。</p>

<h4 id="toc_10">apply() 方法</h4>

<blockquote>
<p>The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).</p>
</blockquote>

<p>不难看出 apply() 和 call() 基本一致，只是实参以数组或者类似数组的对象进行传递。这里对类似数组的对象进行测试：</p>

<pre><code class="language-javascript">function test(...args){
    console.log(this);
    for(item in args) console.log(item);
}
let o = {a:1};
let likeArr = {p1:1,p2:2};
likeArr.length = 2;    
let unLikeArr = {p1:1,p2:2};
test.apply(o,likeArr);
// {a: 1}
// 0
// 1
test.apply(o,unLikeArr);
// {a: 1}
</code></pre>

<p>可见有了 length 的对象就被当作是类似数组的对象。</p>

<h4 id="toc_11">this 值</h4>

<p>可见当 call() 和 apply() 调用函数时给函数绑定了一个上下文 this 值，但是箭头函数是个特例，它从它定义的位置的上下文继承 this 值。也就是说当给箭头函数定义的函数使用这两个方法时，第一个参数将被忽略：</p>

<pre><code class="language-javascript">let o = {
    a: 1,
    f: function(){
        const oBind = {b:1};
        const test = ()=&gt; console.log(this);
        test.apply(oBind);
    }
}
o.f();
// {a: 1, f: ƒ}
</code></pre>

<h3 id="toc_12">隐式调用</h3>

<ul>
<li>getter 和 setter 方法在获取或者设置它的属性时可能被隐式调用。</li>
<li>在对象进行字符串或者数值型和 BigInt 类型转换时，会隐式调用 toString() 和 valueOf() 方法。</li>
<li>循环可迭代对象的元素时会产生很多方法调用。</li>
<li>模板字符串可以调用函数。</li>
<li>Proxy 对象的任何一个操作都会导致函数调用。</li>
</ul>

<h2 id="toc_13"> 关于函数 this 值的总结</h2>

<p>函数 this 值有以下几种情况：</p>

<ul>
<li>函数声明语句和函数表达式定义的函数，在非严格模式下 this 值永远是 global，严格模式下是 undefined。</li>
<li>apply() call() bind() 方法用在非箭头函数时，第一个参数作为函数运行时的 this 值。</li>
<li>箭头函数的 this 值永远继承于它所定义的位置的 this 值。</li>
<li>对象的方法中 this 值是该对象的引用，嵌套在该对象中的函数不为方法，所以遵循函数的 this 值（global 或者 undefined）。</li>
<li>构造函数的 this 值是新创建的对象。</li>
</ul>

<p>闭包只是参数和变量作用域的引用，与 this 值无关。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过变量作用域深入了解 undefined]]></title>
    <link href="2019919.xyz/16088182648987.html"/>
    <updated>2020-12-24T21:57:44+08:00</updated>
    <id>2019919.xyz/16088182648987.html</id>
    <content type="html"><![CDATA[
<p>undefined 是一个变量，它有可能被篡改，所以使用void（0）来代替他，但是在做实验的时候发现虽然给它赋值不报错，取值时候 undefined 却并没有改变。</p>

<pre><code class="language-javascript">    undefined = 0
    // 0
    undefined
    // undefined
</code></pre>

<p>这回学习到了变量作用域，再结合之前学的对象的属性，深入了解下 undefined 到底什么时候会被篡改。</p>

<h2 id="toc_0">函数作用域和声明提前</h2>

<p>别的语言一般为块级作用域，JavaScript 取而代之使用了函数作用域：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。</p>

<pre><code class="language-javascript">    var a = function test(o){
        var i = 0;                          // i在整个函数体内均是有定义的
        if(typeof o == &quot;object&quot;){
            var j = 4;                      // j在函数体内是有定义的，不仅仅是在这个代码段内
            for(var k=0; k &lt; 3; k++){       // k在函数体内是有定义的，不仅仅是在循环内
                console.log(k);             // 输出数字0～2
            }
            console.log(k);                 // k已经定义了，输出3
        }
        console.log(k);                     // k已经定义了，输出3
        console.log(j);                     // j已经定义了，输出4
    };
</code></pre>

<p>JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部。</p>

<pre><code class="language-javascript">    var a = &#39;1&#39;;
    function f(){
        console.log(a);
        var a = &#39;2&#39;;
        console.log(a);
    }
</code></pre>

<p>由于函数作用域的特性，变量 a 的声明被提前到了整个函数体最前面，声明了但是没赋值，所以第一次 console 是 undefined。执行到 var 语句时才被赋值，这应该也是为什么可以一个变量多次 var 声明的原因，后面每一次 var 只是起到了赋值的作用。</p>

<h2 id="toc_1">ES6 块作用域</h2>

<p>ES6 弥补了这这个概念，追加了 let 和 const，也就有了 {} 块作用域的概念，const 用来声明常量，这个就不提了，用上面的例子感受一下 let 和 var 的区别。</p>

<pre><code class="language-javascript">    var a = function test(o){
        var i = 0;                          // i在整个函数体内均是有定义的
        if(typeof o == &quot;object&quot;){
            let j = 4;                      // j在if块内是有定义的
            for(var k=0; k &lt; 3; k++){       // k在函数体内是有定义的，不仅仅是在循环内
                console.log(k);             // 输出数字0～2
                console.log(j);             // j已经定义了，输出4
            }
            console.log(k);                 // k已经定义了，输出3
        }
        console.log(k);                     // k已经定义了，输出3
        console.log(j);                     // j在块外，抛出异常Uncaught ReferenceError: j is not defined
    };
</code></pre>

<p>let 和 const 只有在块内是被声明的。</p>

<h2 id="toc_2">全局变量的本质</h2>

<p>当声明一个 JavaScript 全局变量时，实际上是定义了全局对象的一个属性。当使用 var 声明一个变量时，创建的这个属性是不可配置的，无法通过 delete 运算符删除。</p>

<pre><code class="language-javascript">    test =1
    // 1
    window.test
    // 1
    delete test
    // true
    window.test
    // undefined
    var test = 1
    // undefined
    window.test
    // 1
    delete test
    // false
    window.test
    // 1
</code></pre>

<p>可以看到当定义一个全局变量的时候他变成了 window 的属性。<br/>
JavaScript 可以允许使用 this 关键字来引用全局对象，但是不能引用局部变量中存放的对象。</p>

<pre><code class="language-javascript">    this.test
    // 1
</code></pre>

<h2 id="toc_3">深入理解 undefined 的本质</h2>

<p>undefined 明明是个变量为什么赋值后无法使用呢。任何地方都可以直接使用 undefined，那他是一个全局变量一个全局的属性，事实也果然如此。</p>

<pre><code class="language-javascript">    window.undefined == undefined
    // true
</code></pre>

<p>而属性分两类，他们的特征如下：</p>

<ul>
<li>数据属性
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性是否能被赋值。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul></li>
<li>访问器属性（getter/setter）
<ul>
<li>getter：函数或 undefined，在取属性值时被调用。</li>
<li>setter：函数或 undefined，在设置属性值时被调用。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。<br/>
查看下全局属性 undefined 的属性特征。</li>
</ul></li>
</ul>

<pre><code class="language-javascript">    console.log(Object.getOwnPropertyDescriptor(window,&#39;undefined&#39;));
    // configurable: false
    // enumerable: false
    // value: undefined
    // writable: false
</code></pre>

<p>writable：false，就是这个原因 undefined 虽然是个全局变量，但是我们赋值之后他并没有被改变。那为什么还需要用 void(0) 来代替 undefined 呢？结合上面的函数作用域再做一个实验。</p>

<pre><code class="language-javascript">    function test() {
        var undefined = 100; 
        console.log(undefined);
        var obj = {a : undefined}; 
        console.log(Object.getOwnPropertyDescriptor(obj,&#39;a&#39;));
    }
    test();
    // 100
    // configurable: true
    // enumerable: true
    // value: 100
    // writable: true
</code></pre>

<p>在函数作用域中，undefined 被从声明并赋值为 100，无论是直接 console 它自己还是去查看 undefined 属性特性都能看出，undefined 变量被修改了。这也就说在函数作用域内 undefined 可以被修改。</p>

<pre><code class="language-javascript">    function test() {
        const undefined = 100; 
        console.log(undefined);
        const obj = {a : undefined}; 
        console.log(Object.getOwnPropertyDescriptor(obj,&#39;a&#39;));
        test();
    }
    // 100
    // configurable: true
    // enumerable: true
    // value: 100
    // writable: true
</code></pre>

<p>块作用域内也一样可以被修改，得出结论 undefined 是一个类似 var 声明一样可以被重复声明的全局属性，而他的属性特性 writable 是 false，所以不能被修改，但是在非全局作用域内，他是可以被篡改的，这时候就要注意用 void (0) 来替代 undefined。</p>

<h2 id="toc_4">作用域链<sup>1</sup></h2>

<p>以书中的角度用对象属性去看作用域链：</p>

<ul>
<li>JavaScript最顶层的代码，其作用域链只有一个全局对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Global object</td>
    <tr>
</table>

<ul>
<li>不包含嵌套的函数，其作用域两个对象：函数自身的变量对象和全局对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Activation object</td>
    <tr>
    <tr>
        <td>1</td><td>Global object</td>
    <tr>
</table>

<blockquote>
<p>活动对象(activation object)，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端</p>
</blockquote>

<ul>
<li>对于包含了嵌套函数的函数，其作用域包含至少三个对象：自身的变量对象，外层的变量对象（将自身嵌套的函数），全局变量对象。</li>
</ul>

<table>
    <tr>
        <th colspan=2>Scope chain</th>
    </tr>
    <tr>
        <td>0</td><td>Sub activation object</td>
    <tr>
    <tr>
        <td>1</td><td>Activation object</td>
    <tr>
    <tr>
        <td>2</td><td>Global object</td>
    <tr>
</table>

<p>作用域链给我的感觉类似原型链，将函数的上下文构成了链表的形式，而方法执行时一层一层往外找，所以为了方便链表从上到下查找属性，所以有了声明提前，链表最顶端为嵌套函数的最里层，链表最底端则是全局变量对象。</p>

<pre><code class="language-javascript">    function test(){
        var fun1,fun2;
        for(var i=0;i&lt;2;i++){
            if(i === 0){
                fun1 = function(){console.log(&#39;fun1:i=&#39;+i)};
            }
            if(i === 1){
                fun2 = function(){console.log(&#39;fun2:i=&#39;+i)};
            }
        };
        fun1();
        fun2();
    }∫
    test();
    // fun1:i=2
    // fun2:i=2
</code></pre>

<h2 id="toc_5">注</h2>

<ol>
<li>在看 JavaScript 权威指南第七版第八章时发现作者将原来的作用域链的“链”字都删除了，变成了作用域，但是还没有看前面作用域相关内容，应该有新的理解，在完成翻译后再继续补全。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 6 章 对象]]></title>
    <link href="2019919.xyz/16113218396407.html"/>
    <updated>2021-01-22T21:23:59+08:00</updated>
    <id>2019919.xyz/16113218396407.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">6.1 介绍对象</a>
</li>
<li>
<a href="#toc_1">6.2 创建对象</a>
<ul>
<li>
<a href="#toc_2">6.2.1 对象字面量</a>
</li>
<li>
<a href="#toc_3">6.2.2 用 new 创建对象</a>
</li>
<li>
<a href="#toc_4">6.2.3 原型</a>
</li>
<li>
<a href="#toc_5">6.2.4 Object.create()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">6.3 查询和设置属性</a>
<ul>
<li>
<a href="#toc_7">6.3.1 对象作关联数组</a>
</li>
<li>
<a href="#toc_8">6.3.2 继承</a>
</li>
<li>
<a href="#toc_9">6.3.3 属性访问异常</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">6.4 删除属性</a>
</li>
<li>
<a href="#toc_11">6.5 测试属性</a>
</li>
<li>
<a href="#toc_12">6.6 枚举属性</a>
<ul>
<li>
<a href="#toc_13">6.6.1 属性枚举顺序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">6.7 扩展对象</a>
</li>
<li>
<a href="#toc_15">6.8 序列化对象</a>
</li>
<li>
<a href="#toc_16">6.9 对象方法</a>
<ul>
<li>
<a href="#toc_17">6.9.1 toString() 方法</a>
</li>
<li>
<a href="#toc_18">6.9.2 toLocaleString() 方法</a>
</li>
<li>
<a href="#toc_19">6.9.3 valueOf() 方法</a>
</li>
<li>
<a href="#toc_20">6.9.4 toJSON() 方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">6.10 扩展的对象字面量语法</a>
<ul>
<li>
<a href="#toc_22">6.10.1 速记属性</a>
</li>
<li>
<a href="#toc_23">6.10.2 计算属性名</a>
</li>
<li>
<a href="#toc_24">6.10.3 Symbol 作属性名</a>
</li>
<li>
<a href="#toc_25">6.10.4 展开运算符</a>
</li>
<li>
<a href="#toc_26">6.10.5 速记方法</a>
</li>
<li>
<a href="#toc_27">6.10.6 属性 Getter 和 Setter 方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_28">6.11 总结</a>
</li>
</ul>


<p>对象是 JavaScript 最基本的数据类型，在本章之前的章节中已经多次看到它们。因为对象对 JavaScript 语言非常重要，所以了解它们的工作原理非常重要，本章将提供这些细节。它从对象的正式概述开始，然后深入到关于创建对象以及查询、设置、删除、测试和枚举对象属性的实用部分。在这些以属性为中心的章节之后，将介绍如何扩展、序列化和定义对象上的重要方法。最后，本章以一大段关于 ES6 中的新对象文字语法和该语言的最新版本结尾。</p>

<h2 id="toc_0">6.1 介绍对象</h2>

<p>对象是一个复合值：它聚合了多个值（原始值或其他对象），并允许按名称存储和获取这些值。对象是属性的无序集合，每个属性都有一个名称和一个值。属性名通常是字符串（尽管，正如我们将在 §6.10.3 中看到的，属性名也可以是 Symbol），所以我们可以说对象将字符串映射到值。这种字符串到值的映射有不同的名称——可能已经熟悉这种基本数据结构的别的名称“散列”（hash）、“散列表”（hashtable）、“字典”（dictionary）或“关联数组”（associative array）。然而，对象不仅仅是简单的字符串到值的映射。除了维护自己的属性集，JavaScript 对象还继承另一个对象的属性，即它的“原型”。对象的方法通常是继承的属性，而这种“原型继承”是 JavaScript 的一个关键特性。</p>

<p>JavaScript 对象是动态的——属性通常可以添加和删除——但它们可以用来模拟静态类型语言的静态对象和“结构体”（struct）。有时它们也用做字符串的集 合（忽略名/值对中的值）。</p>

<p>JavaScript 中任何不是字符串、数字、Symbol 或 true、false、null 或 undefined 的值都是对象。即使字符串、数字和布尔值不是对象，它们的行为和不可变对象非常类似。</p>

<p>回想一下 §3.8，对象是可变的，通过引用而不是值来操作。如果变量 x 指向一个对象的引用，执行 <code>y = x;</code> 时，变量 y 也是指向同一对象的引用，而不是该对象的副本。通过变量 y 修改这个对象也会对变量 x 造成影响。</p>

<p>对对象最常见的操作是创建它们并设置、查询、删除、测试和枚举它们的属性。这些基本的操作将在本章的开头部分进行描述。之后的部分将介绍更高级的主题。</p>

<p>属性有一个名称和一个值。属性名可以是任何字符串，包括空字符串（或任何 Symbol），但任何对象都不能有两个同名的属性。值可以是任何 JavaScript 值，也可以是 getter 或 setter 函数（或两者都是）。我们将在 §6.10.6 中学习 getter 和 setter 函数。</p>

<p>有时，能够区分直接在对象上定义的属性和从原型对象继承的属性是很重要的。JavaScript 使用术语“自有属性”来指代非继承属性。</p>

<p>除了名称和值之外，每个属性还有三个属性属性:</p>

<ul>
<li>writable 属性指定是否可以设置属性的值。</li>
<li>enumerable 属性指定 for/in 循环是否返回属性名称。</li>
<li>可配置属性指定该属性是否可以删除，是否可以修改其属性。</li>
</ul>

<p>许多 JavaScript 的内置对象具有只读、不可枚举或不可配置的属性。但是，在默认情况下，创建的对象的所有属性都是可写、可枚举和可配置的。§14.1 解释了为对象指定非默认属性属性值的技巧。</p>

<h2 id="toc_1">6.2 创建对象</h2>

<p>对象可以用对象字面量创建，也可以用 new 关键字和 Object.create() 函数来创建。接下来的几部分对这些技术一一讲述。</p>

<h3 id="toc_2">6.2.1 对象字面量</h3>

<p>创建对象最简单的方式就是在 JavaScript 代码中使用对象直接量。对象直接量是由若干名/值对组成的映射表，名/值对中间用冒号分隔，名/值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是 JavaScript 标识符也可以是字符串字面量（包括空字符串）。属性的值可以是任意类型的 JavaScript 表达式；表达式的值（可以是原始值也可以是对象值）变成这个属性的值。下面有一些例子：</p>

<pre><code class="language-javascript">let empty = {};                          // An object with no properties
let point = { x: 0, y: 0 };              // Two numeric properties
let p2 = { x: point.x, y: point.y+1 };   // More complex values
let book = {
    &quot;main title&quot;: &quot;JavaScript&quot;,          // These property names include spaces,
    &quot;sub-title&quot;: &quot;The Definitive Guide&quot;, // and hyphens, so use string literals.
    for: &quot;all audiences&quot;,                // for is reserved, but no quotes.
    author: {                            // The value of this property is
        firstname: &quot;David&quot;,              // itself an object.
        surname: &quot;Flanagan&quot;
    }
};
</code></pre>

<p>对象文本中最后一个属性的尾随逗号是合法的，并且某些编程样式鼓励使用这些尾随逗号，因为，如果之后在对象文本的末尾添加新属性，则不太可能导致语法错误。</p>

<p>对象字面量是一个表达式，它每次计算时都会创建和初始化一个新对象。每次字面量计算时，将计算每个属性的值。这意味着，如果单个对象字面量出现在循环体或重复调用的函数中，它能创建许多个新对象，并且这些对象的属性值可能彼此不同。</p>

<p>此处的简单语法对象字面量，自 JavaScript 最早的版本以来一直是合法的。最新版本引入了许多对象字面量的新的特性，这些特性在 §6.10 中介绍。</p>

<h3 id="toc_3">6.2.2 用 new 创建对象</h3>

<p>new 运算符创建并初始化一个新的对象。new 关键字必须紧跟一个函数调用。这种方式使用函数叫做构造函数调用，其提供初始化一个新创建的对象的服务。在 JavaScript 中，内置类型都包含相对应的构造函数。例如：</p>

<pre><code class="language-javascript">let o = new Object();  // Create an empty object: same as {}.
let a = new Array();   // Create an empty array: same as [].
let d = new Date();    // Create a Date object representing the current time
let r = new Map();     // Create a Map object for key/value mapping
</code></pre>

<p>除了这些内置构造函数，常常用自定义构造函数来初始化新对象。 第 9 章将详细讲述其中的细节。</p>

<h3 id="toc_4">6.2.3 原型</h3>

<p>在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个 JavaScript 对象都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。</p>

<p>所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。当第一次学习 JavaScript 时，这可能令人困惑。请记住：几乎所有对象都有原型，但只有相对较少的对象具有原型属性。正是这些具有原型属性的对象定义了所有其他对象的原型。</p>

<p>没有原型的对象为数不多，Object.prototype就是其中之一：它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。大部分的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如， Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。这一系列链接的原型对象就是所谓 “原型链”（prototype chain）。</p>

<p>§6.3.2 节讲述属性继承的工作机制。第 9 章将会更详细地讨论原型和构造函数：包括如何通过编写构造函数定义对象的“类”，以及给构造函数的 prototype 属性赋值可以让其“实例”直接使用这个原型上的属性和方法。并且在 §14.3 我们会学习如何查询（甚至改变）对象的原型。</p>

<h3 id="toc_5">6.2.4 Object.create()</h3>

<p>Object.create() 创建一个新的对象，用第一个实参作为它的原型：</p>

<pre><code class="language-javascript">let o1 = Object.create({x: 1, y: 2});     // o1 inherits properties x and y.
o1.x + o1.y                               // =&gt; 3
</code></pre>

<p>可以通过传入参数 null 来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如 toString()，也就是说，它将不能和“+”运算符一起正常工作：</p>

<pre><code class="language-javascript">let o2 = Object.create(null);             // o2 inherits no props or methods.
</code></pre>

<p>如果想创建一个普通的空对象（像通过 {} 或 new Object() 创建的对象），需要传入 Object.prototype：</p>

<pre><code class="language-javascript">let o3 = Object.create(Object.prototype); // o3 is like {} or new Object().
</code></pre>

<p>可以通过任意原型创建新对象，这是一个强大的特性，并且本章我们会在很多地方使用 Object.create()。（Object.create() 也可以传入第二个可选实参来描述这个新的对象的属性。第二个实参是一个高级特性，在  §14.1 再进行描述。）</p>

<p>Object.create() 其中一个用途是预防对象无意间（非恶意地）被无法支配的库函数篡改。可以创建一个继承它的对象来传递给函数，而不是将其直接传递给函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象：</p>

<pre><code class="language-javascript">let o = { x: &quot;don&#39;t change this value&quot; };
library.function(Object.create(o));  // Guard against accidental modifications
</code></pre>

<p>想要了解其工作原理，需要先知道 JavaScript 中属性的查询和设置机制。这是接下来这节的主题。</p>

<h2 id="toc_6">6.3 查询和设置属性</h2>

<p>§4.4 已经提到，可以通过点（.）或方括号（[]）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。如果使用点运算符，右侧必须是一个以属性名称命名的简单标识符。如果使用方括号，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字：</p>

<pre><code class="language-javascript">let author = book.author;       // Get the &quot;author&quot; property of the book.
let name = author.surname;      // Get the &quot;surname&quot; property of the author.
let title = book[&quot;main title&quot;]; // Get the &quot;main title&quot; property of the book.
</code></pre>

<p>和查询属性值的写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧：</p>

<pre><code class="language-javascript">book.edition = 7;                   // Create an &quot;edition&quot; property of book.
book[&quot;main title&quot;] = &quot;ECMAScript&quot;;  // Change the &quot;main title&quot; property.
</code></pre>

<p>当使用方括号时，我们说方括号内的表达式必须返回字符串。其实更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值或 Symbol（§6.10.3）。在第 7 章里有一些例子中的方括号内使用了数字，这情况是非常常用的。</p>

<h3 id="toc_7">6.3.1 对象作关联数组</h3>

<p>上文提到，下面两个表达式有相同的值：</p>

<pre><code class="language-javascript">object.property
object[&quot;property&quot;]
</code></pre>

<p>第一种语法使用点运算符和一个标识符，这和 C 和 Java 中访问一个结构体或对象的静态字段非常类似。第二种语法使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array）（也称做散列、映射或字典）。JavaScript 对象都是关联数组，本节将讨论它的重要性。</p>

<p>在 C、C++、Java 和一些强类型语言中，对象只能拥有固定数目的属性，并且这些属性的名称必须提前定义好。由于 JavaScript 是一个弱类型语言，因此不适用这条规则：对象在程序中可以创建任意数量的属性。当使用 . 运算符访问对象的属性时，属性名用一个标识符来表示。标识符必须直接出现在 JavaScript 程序中，它们不是数据类型，所以无法在程序中修改。</p>

<p>另一种方式，当通过 [] 来访问对象的属性时，属性名通过字符串来表示。字符串是 JavaScript 的数据类型，在程序运行时可以修改和创建它们。因此，可以在 JavaScript 中使用下面这种代码：</p>

<pre><code class="language-javascript">let addr = &quot;&quot;;
for(let i = 0; i &lt; 4; i++) {
    addr += customer[`address${i}`] + &quot;\n&quot;;
}
</code></pre>

<p>这段代码读取 customer 对象的 address0、address1、address2 和 address3 属性，并将它们连接起来。</p>

<p>这个例子主要说明了通过字符串表达式使用数组标记来访问对象属性的灵活性。这段代码也可以通过点运算符来重写，但是一些场景只能使用数组写法来完成。假设你正在写一个程序，这个程序利用网络资源计算用户股票市场投资的当前价值。程序允许用户输入他们拥有的股票名称以及对应的数量。你可以用一个名为 portfolio 的对象来储存这些信息。每一个股票在对象中都有一个属性与之对应。属性名是股票名，属性值是股票持有份额。例如，如果用户持有 IBM 的 50 股，那么 portfolio.ibm 属性的值就为 50。</p>

<p>下面是程序的部分代码，这个函数用来给 portifolio 添加新的股票：</p>

<pre><code class="language-javascript">function addstock(portfolio, stockname, shares) {
    portfolio[stockname] = shares;
}
</code></pre>

<p>由于用户是在程序运行时输入股票名称，因此在之前无法得知这些股票的名称是什么。而由于在写程序的时候不知道属性名称，因此无法通过点运算符（.）来访问对象 portfolio 的属性。但可以使用 [] 运算符，因为它使用字符串值（字符串值是动态的，可以在运行时更改）而不是标识符（标识符是静态的，必须写死在程序中）作为索引对属性进行访问。</p>

<p>第 5 章介绍了 for/in 循环（§6.6 节还会进一步介绍）。当使用 for/in 循环遍历关联数组时，就可以清晰地体会到 for/in 的强大之处。下面的例子就是利用 for/in 计算  portfolio 的合计值：</p>

<pre><code class="language-javascript">function computeValue(portfolio) {
    let total = 0.0;
    for(let stock in portfolio) {       // For each stock in the portfolio:
        let shares = portfolio[stock];  // get the number of shares
        let price = getQuote(stock);    // look up share price
        total += shares * price;        // add stock value to total value
    }
    return total;                       // Return total value.
}
</code></pre>

<p>如本节所示，JavaScript 对象通常用作关联数组，理解其工作原理非常重要。但是，在 ES6 之后使用 Map 类常常是一个更好的选择，我们将在 §11.1.2 中进行描述。</p>

<h3 id="toc_8">6.3.2 继承</h3>

<p>JavaScript 对象中有一组“自有属性”，也有一组属性是继承自它的原型对象。想要理解属性继承，必须更深入地了解属性访问的细节。这一节的例子通过使用 Object.create() 函数创建对象来指定它的原型。我们会在第 9 章再次看到它，但是，每次使用 new 创建类的实例时，都会创建一个从原型对象继承属性的对象。</p>

<p>假设要查询对象 o 的属性 x。如果 o 中不存在 x 名称的自由属性，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到 x 或者查找到一个原型是 null 的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。</p>

<pre><code class="language-javascript">let o = {};               // o inherits object methods from Object.prototype
o.x = 1;                  // and it now has an own property x.
let p = Object.create(o); // p inherits properties from o and Object.prototype
p.y = 2;                  // and has an own property y.
let q = Object.create(p); // q inherits properties from p, o, and...
q.z = 3;                  // ...Object.prototype and has an own property z.
let f = q.toString();     // toString is inherited from Object.prototype
q.x + q.y                 // =&gt; 3; x and y are inherited from o and p
</code></pre>

<p>现在假设给对象 o 的属性 x 赋值，如果 o 中已经有属性 x（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性 x 的值。否则，赋值操作给 o 添加一个新属性 x。如果之前 o 继承自属性 x，那么这个继承的属性就被新创建的同名属性覆盖了。</p>

<p>属性赋值操作检查原型链只是判断是否允许赋值操作。例如，如果 o 继承自一个只读属性 x，那么赋值操作是不允许的（§6.3.3 将对此进行详细讨论）。 如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在 JavaScript 中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是 JavaScript 的一个重要特性，该特性让程序员可以有选择地重写继承的属性。</p>

<pre><code class="language-javascript">let unitcircle = { r: 1 };         // An object to inherit from
let c = Object.create(unitcircle); // c inherits the property r
c.x = 1; c.y = 1;                  // c defines two properties of its own
c.r = 2;                           // c overrides its inherited property
unitcircle.r                       // =&gt; 1: the prototype is not affected
</code></pre>

<p>属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性。但有一个例外，如果 o 继承自属性 x，而这个属性是一个具有 setter 方法的存取器属性（参照 §6.10.6），那么这时将调用 setter 方法而不是给 o 创建一个属性 x。需要注意的是，setter 方法是由对象 o 调用的，而不是定义这个属性的原型对象调用的。因此如果 setter 方法定义任意属性，这个操作只是针对 o 本身，并不会修改原型链。</p>

<h3 id="toc_9">6.3.3 属性访问异常</h3>

<p>属性访问表达式并不总是返回或设置一个值。本节讲述查询或设置属性时的一些出错情况。</p>

<p>查询一个不存在的属性并不会报错，如果在对象 o 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。回想一下我们的 book 对象有属性“sub-title”，而没有属性“subtitle”：</p>

<pre><code class="language-javascript">book.subtitle    // =&gt; undefined: property doesn&#39;t exist
</code></pre>

<p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null 和 undefined 值都没有属性，因此查询这些值的属性会报错，接上例：</p>

<pre><code class="language-javascript">let len = book.subtitle.length; // !TypeError: undefined doesn&#39;t have length
</code></pre>

<p>如果 . 的左边是 null 或 undefined 时，其属性表达式会失败。所以当写一个像 book.author.surname 一样的表达式时，如果你不确定 book 和 book.author 确实被定义就要小心了。下面提供了两种避免出错的方法：</p>

<pre><code class="language-javascript">// A verbose and explicit technique
let surname = undefined;
if (book) {
    if (book.author) {
        surname = book.author.surname;
    }
}

// A concise and idiomatic alternative to get surname or null or undefined
surname = book &amp;&amp; book.author &amp;&amp; book.author.surname;
</code></pre>

<p>为了理解为什么这里的第二种方法可以避免类型错误异常，可以参照 §4.10.1节 中关于 &amp;&amp; 运算符的短路行为。</p>

<p>如 §4.4.1 中所描述，ES2020 支持用 ?. 条件属性访问，它允许这样重写上面的赋值表达式：</p>

<pre><code class="language-javascript">let surname = book?.author?.surname;
</code></pre>

<p>当然，给 null 和 undefined 设置属性也会报类型错误。给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性。在严格模式下（§5.6.3），属性设定失败时会抛出 TypeError 异常。在非严格模式下，这些失败的处理经常没有任何反应。</p>

<p>尽管属性赋值成功或失败的规律看起来很简单，但要描述清楚并不容易。在这些场景下给对象 o 设置属性 p 会失败：</p>

<p>o 中的属性 p 是只读的：不能给只读属性重新赋值。</p>

<p>o 中的属性 p 是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。</p>

<p>o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且o的可扩展性是（见 §14.2）false。如果 o 中不存在 p，而且没有 setter 方法可供调用，则 p 一定会添加至 o 中。但如果 o 不是可扩展的，那么在 o 中不能定义新属性。</p>

<h2 id="toc_10">6.4 删除属性</h2>

<p>删除运算符（§4.13.4）能删除对象中的属性。它的操作数应当是一个属性访问表达式。令人意外的是，delete 没有操作属性的值，而是操作属性的属性：</p>

<pre><code class="language-javascript">delete book.author;          // The book object now has no author property.
delete book[&quot;main title&quot;];   // Now it doesn&#39;t have &quot;main title&quot;, either.
</code></pre>

<p>delete 运算符只删除自有属性，不删除继承属性。（想要删除一个继承属性，必须从定义这个属性的原型对象上删除它。这会影响所有继承这个原型的对象。）</p>

<p>如果删除成功或删除没有任何影响时删除表达式计算结果是 true（如删除不存在的属性）。delete 作用于非属性访问表达式（无用代码）时也返回 true。</p>

<pre><code class="language-javascript">let o = {x: 1};    // o has own property x and inherits property toString
delete o.x         // =&gt; true: deletes property x
delete o.x         // =&gt; true: does nothing (x doesn&#39;t exist) but true anyway
delete o.toString  // =&gt; true: does nothing (toString isn&#39;t an own property)
delete 1           // =&gt; true: nonsense, but true anyway
</code></pre>

<p>delete 不能删除那些可配置性为 false 的属性。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。在严格模式中，删除一个不可配置属性会报一个类型错误。在非严格模式中，在这些情况下的 delete 操作会返回 false：</p>

<pre><code class="language-javascript">// In strict mode, all these deletions throw TypeError instead of returning false
delete Object.prototype // =&gt; false: property is non-configurable
var x = 1;              // Declare a global variable
delete globalThis.x     // =&gt; false: can&#39;t delete this property
function f() {}         // Declare a global function
delete globalThis.f     // =&gt; false: can&#39;t delete this property either
</code></pre>

<p>当在非严格模式中删除全局对象的可配值属性时，可以省略对全局对象的引用，直接在 delete 操作符后跟随要删除的属性名即可：</p>

<pre><code class="language-javascript">globalThis.x = 1;       // Create a configurable global property (no let or var)
delete x                // =&gt; true: this property can be deleted
</code></pre>

<p>然而在严格模式中，delete 后跟随一个非法的操作数（比如 x），则会报一个语法错误，因此必须显式指定对象及其属性：</p>

<pre><code class="language-javascript">delete x;               // SyntaxError in strict mode
delete globalThis.x;    // This works
</code></pre>

<h2 id="toc_11">6.5 测试属性</h2>

<p>JavaScript 对象可以看作属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以用 in 运算符、hasOwnPreperty() 和  propertyIsEnumerable() 方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。这节的例子都是用字符串作为属性名称，但是也可以用 Symbol 作为属性名（§6.10.3）。</p>

<p>in 运算符的左侧是属性名，右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true：</p>

<pre><code class="language-javascript">let o = { x: 1 };
&quot;x&quot; in o         // =&gt; true: o has an own property &quot;x&quot;
&quot;y&quot; in o         // =&gt; false: o doesn&#39;t have a property &quot;y&quot;
&quot;toString&quot; in o  // =&gt; true: o inherits a toString property
</code></pre>

<p>对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false：</p>

<pre><code class="language-javascript">let o = { x: 1 };
o.hasOwnProperty(&quot;x&quot;)        // =&gt; true: o has an own property x
o.hasOwnProperty(&quot;y&quot;)        // =&gt; false: o doesn&#39;t have a property y
o.hasOwnProperty(&quot;toString&quot;) // =&gt; false: toString is an inherited property
</code></pre>

<p>propertyIsEnumerable() 是 hasOwnProperty() 的增强版。只有检测到是自有属性且这个属性的可枚举性为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非使用  §14.1 中介绍的技术来让它们不可枚举。</p>

<pre><code class="language-javascript">let o = { x: 1 };
o.propertyIsEnumerable(&quot;x&quot;)  // =&gt; true: o has an own enumerable property x
o.propertyIsEnumerable(&quot;toString&quot;)  // =&gt; false: not an own property
Object.prototype.propertyIsEnumerable(&quot;toString&quot;) // =&gt; false: not enumerable
</code></pre>

<p>除了使用 in 运算符之外，另一种更简便的方法是使用 !== 判断一个属性是否是 undefined：</p>

<pre><code class="language-javascript">let o = { x: 1 };
o.x !== undefined        // =&gt; true: o has a property x
o.y !== undefined        // =&gt; false: o doesn&#39;t have a property y
o.toString !== undefined // =&gt; true: o inherits a toString property
</code></pre>

<p>然而有一种场景只能使用 in 运算符而不能使用上述属性访问的方式。in 可以区分不存在的属性和存在但值为 undefined 的属性。例如下面的代码：</p>

<pre><code class="language-javascript">let o = { x: undefined };  // Property is explicitly set to undefined
o.x !== undefined          // =&gt; false: property exists but is undefined
o.y !== undefined          // =&gt; false: property doesn&#39;t even exist
&quot;x&quot; in o                   // =&gt; true: the property exists
&quot;y&quot; in o                   // =&gt; false: the property doesn&#39;t exist
delete o.x;                // Delete the property x
&quot;x&quot; in o                   // =&gt; false: it doesn&#39;t exist anymore
</code></pre>

<h2 id="toc_12">6.6 枚举属性</h2>

<p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。有几种不同的方法可以做到这一点。</p>

<p>§5.4.5 讨论过 for/in 循环，其可以在循环体中遍历指定对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的 内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非用下文中提到的一个方法将它们转换为不可枚举的）。例如：</p>

<pre><code class="language-javascript">let o = {x: 1, y: 2, z: 3};          // Three enumerable own properties
o.propertyIsEnumerable(&quot;toString&quot;)   // =&gt; false: not enumerable
for(let p in o) {                    // Loop through the properties
    console.log(p);                  // Prints x, y, and z, but not toString
}
</code></pre>

<p>为了防止 for/in 枚举到继承属性，可以在循环中添加显示检查：</p>

<pre><code class="language-javascript">for(let p in o) {
    if (!o.hasOwnProperty(p)) continue;       // Skip inherited properties
}

for(let p in o) {
    if (typeof o[p] === &quot;function&quot;) continue; // Skip all methods
}
</code></pre>

<p>作为使用 for/in 循环的替代方法，通常使用 for/of 循环遍历易获取对象的属性名称数组。可以使用四个函数获取属性名称数组：</p>

<p>Object.keys() 返回对象的可枚举自有属性名称数组集合。数组内不包含不可枚举属性、继承属性或属性名称是 Symbol（见 §6.10.3）的属性</p>

<p>Object.getOwnPropertyNames() 用起来和 Object.keys() 类似，但是它返回数组中也包含不可迭代的自有属性，只要它们的名称是字符串。</p>

<p>Object.getOwnPropertySymbols() 返回名称是 Symbol 的自有属性，无论它们是否可枚举。</p>

<p>Reflect.ownKeys() 返回所有的自由属性名称，包括可枚举和不可枚举类型，也包括字符串和 Symbol（见 §14.6）。</p>

<p>在 §6.7 中有例子使用 for/of 循环 Object.keys()。</p>

<h3 id="toc_13">6.6.1 属性枚举顺序</h3>

<p>ES6 正式定义元素的自有属性的枚举顺序。Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Reflect.ownKeys() 和相关方法如 JSON.stringify() 属性列表都按以下顺序排列的，受它们自身是否是不可枚举属性列表或者属性是字符串或者 Symbol 影响：</p>

<p>首先列出名称为非负整数的字符串属性，按从最小到最大的数字顺序列出。此规则意味着数组和数组类对象将按顺序枚举其属性。</p>

<p>列出所有看起来像数组索引的属性后，将列出所有具有字符串名称的剩余属性（包括看起来像负数或浮点数字的属性）。这些属性按添加到对象的顺序列出。对于在对象字面量中定义的属性，此顺序与它们在文本中显示的顺序相同。</p>

<p>最后，其名称为 Symbol 对象的属性按添加到对象的顺序列出。</p>

<p>for/in 循环的枚举顺序不像这些枚举函数那样严格指定，但实现通常按刚才描述的顺序枚举自己的属性，然后向上移动原型链按相同顺序枚举每个原型对象的属性。但是请注意，如果已枚举具有相同名称的属性，或者不可枚举属性已经被检测过再次枚举到相同名称的属性，都不会再次枚举。</p>

<h2 id="toc_14">6.7 扩展对象</h2>

<p>在 JavaScript 代码中有一个很常见的操作，需要将一个对象中的属性拷贝到另外一个对象。以下面的代码很容易实现：</p>

<pre><code class="language-javascript">let target = {x: 1}, source = {y: 2, z: 3};
for(let key of Object.keys(source)) {
    target[key] = source[key];
}
target  // =&gt; {x: 1, y: 2, z: 3}
</code></pre>

<p>但是因为这个是个常用的操作，各种 JavaScript 框架定义公用函数，经常将其命名为 extend() 来执行这个拷贝操作。最后在 ES6 中，这个功能以 Object.assign() 的形式被添加到 JavaScript 核心语言中。</p>

<p>Object.assign() 需要两个或多个对象作为其实参。它修改并返回第一个实参，即目标对象，但不会改变第二个或任何后续参数，这些参数是源对象。对于每个源对象，它将该对象的可枚举自有属性（包括名称为 Symbol 的属性）复制到目标对象中。它按源对象在实参列表顺序中的顺序处理，所以第一个源对象中的属性会重写在目标对象中的同名属性，然后以第二个源对象中的同名属性（如果有第二个源对象）再次重写第一个源对象重写后的属性。</p>

<p>Object.assign() 通过普通属性的 get 和 set 操作复制属性，因此，如果源对象具有 getter 方法或目标对象具有 setter 方法，则将在复制期间调用它们，但不会复制方法本身。</p>

<p>看这样一个场景，有一个对象定义许多属性的默认值，希望将这些默认属性中不存在于目标对象中的属性复制到目标对象中，使用 Object.assign() 不会得到想要的结果：</p>

<pre><code class="language-javascript">Object.assign(o, defaults);  // overwrites everything in o with defaults
</code></pre>

<p>想得到这个效果需要创建一个新的对象，将默认值拷贝到其中，然后用 o 的属性重写默认值中的属性：</p>

<pre><code class="language-javascript">o = Object.assign({}, defaults, o);
</code></pre>

<p>我们会在 §6.10.4 见到，可以用 ... 展开操作符如下操作这个对象拷贝并重写：</p>

<pre><code class="language-javascript">o = {...defaults, ...o};
</code></pre>

<p>为了避免对象创建和复制的额外开销，我们还可以通过编写一个 Object.assign() 仅在缺少属性时复制属性：</p>

<pre><code class="language-javascript">// Like Object.assign() but doesn&#39;t override existing properties
// (and also doesn&#39;t handle Symbol properties)
function merge(target, ...sources) {
    for(let source of sources) {
        for(let key of Object.keys(source)) {
            if (!(key in target)) { // This is different than Object.assign()
                target[key] = source[key];
            }
        }
    }
    return target;
}
Object.assign({x: 1}, {x: 2, y: 2}, {y: 3, z: 4})  // =&gt; {x: 2, y: 3, z: 4}
merge({x: 1}, {x: 2, y: 2}, {y: 3, z: 4})          // =&gt; {x: 1, y: 2, z: 4}
</code></pre>

<p>编写其他属性操作公共函数很简单，就是像这个 merge() 函数。例如，如果对象的属性不出现在另一个模板对象中，则 restrict() 函数会删除这些属性。或者，subtract() 函数可以从其他对象中删除一个对象的所有属性。</p>

<h2 id="toc_15">6.8 序列化对象</h2>

<p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是“JavaScript Object Notation”——JavaScript 对象表示法，它的语法和 JavaScript 对象与数组字面量的语法非常相近：</p>

<pre><code class="language-javascript">let o = {x: 1, y: {z: [false, null, &quot;&quot;]}}; // Define a test object
let s = JSON.stringify(o);   // s == &#39;{&quot;x&quot;:1,&quot;y&quot;:{&quot;z&quot;:[false,null,&quot;&quot;]}}&#39;
let p = JSON.parse(s);       // p == {x: 1, y: {z: [false, null, &quot;&quot;]}}
</code></pre>

<p>JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。支持对象、数组、字符串、无穷大数字、true、false 和 null，并且它们可以序列化和还原。NaN、Infinity 和 -Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON() 函数），但 JSON.parse() 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify() 和 JSON.parse() 都可以接收第二个可选实参，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。§11.6 有关于这些函数的详细文档。</p>

<h2 id="toc_16">6.9 对象方法</h2>

<p>上文已经讨论过，所有的 JavaScript 对象都从 Object.prototype 继承属性（除了那些不通过原型显式创建的对象）。这些继承属性主要是方法，因为 JavaScript 程序员普遍对继承方法更感兴趣。例如我们已经见过的 hasOwnProperty() 和 propertyIsEnumerable() 方法。（并且我们也已经提到了一小部分定义在对象构造函数中的静态函数，像 Object.create() 和 Object.keys()。）本节介绍在 Object.prototype 上定义的少数通用对象方法，但是这些方法经常会被更专业的实现所取代。在下面的各节中，我们将展示在单个对象上定义这些方法的示例。在第 9 章中，将学习如何更常规化地为整个对象类定义这些方法。</p>

<h3 id="toc_17">6.9.1 toString() 方法</h3>

<p>toString() 方法没有实参，它将返回一个表示调用这个方法的对象值的字符串。在需要将对象转换为字符串的时候，JavaScript 都会调用这个方法。比如，当使用 + 运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用 toString()。</p>

<p>默认的 toString() 方法的返回值带有的信息量很少（尽管它在检测对象的类型时非常有用，参照 §14.4.3），例如，下面这行代码的计算结果为字符串”[object Object]”：</p>

<pre><code class="language-javascript">let s = { x: 1, y: 1 }.toString();  // s == &quot;[object Object]&quot;
</code></pre>

<p>由于默认的 toString() 方法并不会输出很多有用的信息，因此很多类都带有自定义的 toString()。例如，当数组转换为字符串的时候，结果是一个数组元素列表，只是每个元素都转换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。可以像下面这样自定义 toString() 方法：</p>

<pre><code class="language-javascript">let point = {
    x: 1,
    y: 2,
    toString: function() { return `(${this.x}, ${this.y})`; }
};
String(point)    // =&gt; &quot;(1, 2)&quot;: toString() is used for string conversions
</code></pre>

<h3 id="toc_18">6.9.2 toLocaleString() 方法</h3>

<p>除了基本的 toString() 方法之外，对象都包含 toLocaleString() 方法，这个方法返回一个表示这个对象的本地化字符串。Object 中默认的 toLocaleString() 方法并不做任何本地化自身的操作，它仅调用 toString() 方法并返回对应值。Date 和 Number 类对 toLocaleString() 方法做了定制，可以用它对数字、日期和时间做本地化的转换。 Array 类的 toLocaleString() 方法和 toString() 方法很像，唯一的不同是每个数组元素会调用 toLocaleString() 方法转换为字符串，而不是调用各自的 toString() 方法。可以像这样使用 point 对象做到同样的效果：</p>

<pre><code class="language-javascript">let point = {
    x: 1000,
    y: 2000,
    toString: function() { return `(${this.x}, ${this.y})`; },
    toLocaleString: function() {
        return `(${this.x.toLocaleString()}, ${this.y.toLocaleString()})`;
    }
};
point.toString()        // =&gt; &quot;(1000, 2000)&quot;
point.toLocaleString()  // =&gt; &quot;(1,000, 2,000)&quot;: note thousands separators
</code></pre>

<p>在 §11.7 的国际化类中，toLocaleString() 方法的实现是非常有用的。</p>

<h3 id="toc_19">6.9.3 valueOf() 方法</h3>

<p>valueOf() 方法和 toString() 方法非常类似，但往往当 JavaScript 需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法。默认的 valueOf() 方法不足为奇，但有些内置类自定义了 valueOf() 方法. Date 类定义 valueOf() 将日期转化成数值型，并且这允许 Date 对象使用 &lt; 和 &gt; 按时间先手顺序比较。可以对 point 对象做同样的事，定义一个 valueOf() 方法返回原点到点的距离：</p>

<pre><code class="language-javascript">let point = {
    x: 3,
    y: 4,
    valueOf: function() { return Math.hypot(this.x, this.y); }
};
Number(point)  // =&gt; 5: valueOf() is used for conversions to numbers
point &gt; 4      // =&gt; true
point &gt; 5      // =&gt; false
point &lt; 6      // =&gt; true
</code></pre>

<h3 id="toc_20">6.9.4 toJSON() 方法</h3>

<p>Object.prototype 实际上没有定义 toJSON() 方法，但对于需要执行序列化的对象来说，JSON.stringify() 方法（见 §6.8）会调用 toJSON() 方法。如果在待序列化的对象中存在这 个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。Date 类（§11.4）定义了 toJSON() 方法返回日期的序列化字符串。我们可以这样对 point 对象做同样的事：</p>

<pre><code class="language-javascript">let point = {
    x: 1,
    y: 2,
    toString: function() { return `(${this.x}, ${this.y})`; },
    toJSON: function() { return this.toString(); }
};
JSON.stringify([point])   // =&gt; &#39;[&quot;(1, 2)&quot;]&#39;
</code></pre>

<h2 id="toc_21">6.10 扩展的对象字面量语法</h2>

<p>JavaScript 的最新版本扩展了许多有用的对象字面量相关的语法。以下小节解释这些扩展。</p>

<h3 id="toc_22">6.10.1 速记属性</h3>

<p>假设值存储在变量 x 和 y 中，并且想要创建具有名为 x 和 y 的属性的对象，这些属性包含这些值。使用基本对象字面量语法，最终会重复每个标识符两次：</p>

<pre><code class="language-javascript">let x = 1, y = 2;
let o = {
    x: x,
    y: y
};
</code></pre>

<p>在 ES6 之后，可以删除标识符的冒号和一个副本，最终使用更简单的代码：</p>

<pre><code class="language-javascript">let x = 1, y = 2;
let o = { x, y };
o.x + o.y  // =&gt; 3
</code></pre>

<h3 id="toc_23">6.10.2 计算属性名</h3>

<p>有时需要创建具有特定属性的对象，但该属性的名称不是可以在源代码中键入的编译时常量。相反，需要的属性名称存储在变量中，或者是调用的函数的返回值。不能对此类属性使用基本对象字面量。而必须创建一个对象，通过额外的步骤，添加所需的属性：</p>

<pre><code class="language-javascript">const PROPERTY_NAME = &quot;p1&quot;;
function computePropertyName() { return &quot;p&quot; + 2; }

let o = {};
o[PROPERTY_NAME] = 1;
o[computePropertyName()] = 2;
</code></pre>

<p>使用称为计算属性的 ES6 特性设置这样的对象要简单得多，该功能允许从前面的代码写入方括内并直接移动到对象字面量中：</p>

<pre><code class="language-javascript">const PROPERTY_NAME = &quot;p1&quot;;
function computePropertyName() { return &quot;p&quot; + 2; }

let p = {
    [PROPERTY_NAME]: 1,
    [computePropertyName()]: 2
};

p.p1 + p.p2 // =&gt; 3
</code></pre>

<p>使用这种新语法，方括号将其分隔成 JavaScript 表达式。计算该表达式，并将结果值（如有必要转换为字符串）用作属性名称。</p>

<p>可能想要使用计算属性的一个情况是，有一个 JavaScript 代码库，该库希望传递具有一组特定属性的对象，并且这些属性的名称定义为该库中的常量。如果要编写代码以创建将传递给该库的对象，可以硬编码属性名称，但如果在任何地方键入错误的属性名称，则存在错误风险；如果库的新版本更改了所需的属性名称，则存在版本不匹配问题的风险。相反，可能会发现，使用计算属性语法与库定义的属性名称常量时，它使代码更加健壮。</p>

<h3 id="toc_24">6.10.3 Symbol 作属性名</h3>

<p>计算属性语法启用了另一个非常重要的对象字面量特性。在 ES6 之后，属性名称可以是字符串或 Symbol。如果将 Symbol 分配给变量或常量，则可以使用计算属性语法将该 Symbol 用作属性名称：</p>

<pre><code class="language-javascript">const extension = Symbol(&quot;my extension symbol&quot;);
let o = {
    [extension]: { /* extension data stored in this object */ }
};
o[extension].x = 0; // This won&#39;t conflict with other properties of o
</code></pre>

<p>如 §3.6 中所述，符号是不透明值。除了将它们用作属性名称，不能对它们进行任何其他处理。但是，每个 Symbol 都不同于所有其他 Symbol，这意味着 Symbol 适合创建唯一的属性名称。通过调用 Symbol() 工厂函数创建新 Symbol。（Symbol 是原始值，而不是对象，因此 Symbol() 不是使用 new 调用的构造函数。）Symbol() 返回的值不等于任何其他 Symbol 或其他值。可以将字符串传递给 Symbol()，当 Symbol 转换为字符串时，将使用此字符串。但是，这只是一个调试帮助：使用同一字符串参数创建的两个 Symbol 仍然彼此不同。</p>

<p>Symbol 的要点不是安全性，而是为 JavaScript 对象定义一个安全的扩展机制。如果从第三方代码获取对象，您无法控制该对象，并且需要向该对象添加自己的一些属性，但希望确保属性不会与对象上可能存在的任何属性冲突，可以安全地使用 Symbol 作为属性名称。如果这样做，还可以确信第三方代码不会意外更改 Symbol 命名的属性。（当然，该第三方代码可以使用 Object.getOwnPropertySymbols() 来发现你使用的 Symbol，然后可以更改或删除你的属性。这就是为什么符号不是安全机制。）</p>

<h3 id="toc_25">6.10.4 展开运算符</h3>

<p>在 ES2018 之后，可以使用展开运算符 ... 将现有的对象中的属性复制到新的对象中：</p>

<pre><code class="language-javascript">let position = { x: 0, y: 0 };
let dimensions = { width: 100, height: 75 };
let rect = { ...position, ...dimensions };
rect.x + rect.y + rect.width + rect.height // =&gt; 175
</code></pre>

<p>在此代码中，position 和 dimensions 对象的属性被展开到 rect 对象字面量中，就像它们以字面量的方式写入这些大括号中一样。请注意，... 语法通常称为展开运算符，但在任何情况下都不是真正的 JavaScript 运算符。相反，它是一种特殊情况下语法，仅在对象文本中可用。（... 在别的 JavaScript 上下文中有其他用途，但是对象字面量上下文中只有这一种用法。）</p>

<p>如果展开的目标对象和源对象中具有相同的名称，则该属性的值将是位置处于后面的值：</p>

<pre><code class="language-javascript">let o = { x: 1 };
let p = { x: 0, ...o };
p.x   // =&gt; 1: the value from object o overrides the initial value
let q = { ...o, x: 2 };
q.x   // =&gt; 2: the value 2 overrides the previous value from o.
</code></pre>

<p>还有注意展开运算符只展开对象的自有属性，不展开继承属性：</p>

<pre><code class="language-javascript">let o = Object.create({x: 1}); // o inherits the property x
let p = { ...o };
p.x                            // =&gt; undefined
</code></pre>

<p>最后，值得注意的是，虽然展开运算符在代码中只是三个小点，但它对 JavaScript 解释器来说可以代表大量的工作。如果对象具有 n 个属性，则将这些属性分散到另一个对象的过程很可能是 O(n) 操作。这意味着，如果你发现自己在使用 ... 在循环或递归函数中，类似将数据累积到一个大对象中的方法，您可能正在编写一个低效的 O(n2) 算法，该算法不会随着 n 变大而扩展。</p>

<h3 id="toc_26">6.10.5 速记方法</h3>

<p>当函数被定义为对象的属性时，我们称该函数为方法（我们将在第 8 章和第 9 章中对方法有更多的描述）。在 ES6 之前，在对象字面量中用函数定义表达式定义一个方法和在对象中定义其他属性一样：</p>

<pre><code class="language-javascript">let square = {
    area: function() { return this.side * this.side; },
    side: 10
};
square.area() // =&gt; 100
</code></pre>

<p>但是，在 ES6 中，对象字面量语法（以及我们将在第 9 章中看到的类定义语法）已扩展成允许省略函数关键字和冒号的快捷方式，可以写成这样的代码：</p>

<pre><code class="language-javascript">let square = {
    area() { return this.side * this.side; },
    side: 10
};
square.area() // =&gt; 100
</code></pre>

<p>两种形式是相同的：在对象字面量中添加一个名为 area 的属性，并指定一个函数为这个属性的值。速记语法更清晰的看出 area() 是一个方法而不是一个像 side 一样的数据属性。</p>

<p>使用此速记语法编写方法时，属性名称可以采用对象字面量中的任何合法形式：除了像上面的名称 area 这样的常规 JavaScript 标识符外，还可以使用字符串字面量和计算属性名称，包括 Symbol 属性名称：</p>

<pre><code class="language-javascript">const METHOD_NAME = &quot;m&quot;;
const symbol = Symbol();
let weirdMethods = {
    &quot;method With Spaces&quot;(x) { return x + 1; },
    [METHOD_NAME](x) { return x + 2; },
    [symbol](x) { return x + 3; }
};
weirdMethods[&quot;method With Spaces&quot;](1)  // =&gt; 2
weirdMethods[METHOD_NAME](1)           // =&gt; 3
weirdMethods[symbol](1)                // =&gt; 4
</code></pre>

<p>使用 Symbol 作为方法名称并不像看起来那么奇怪。为了使对象可迭代（因此它可以与 for/of 循环一起使用），必须定义一个具有符号名称 Symbol.iterator 的方法，并且在第 12 章中有这样做的示例。</p>

<h3 id="toc_27">6.10.6 属性 Getter 和 Setter 方法</h3>

<p>到目前为止，本节我们所讨论的所有的对象都是具有名称和普通值的数据属性。JavaScript 还支持存取器属性，这些属性没有单个值，而是具有一个或两个存取器方法：getter 和或是或 setter。</p>

<p>当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无实参）。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时， JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。</p>

<p>如果属性同时有 getter 和 setter 方法，则它是一个可读写属性。如果它只含有 getter 方法，它是一个只读属性。如果它只有 setter 方法，它是一个只可写属性（这对一个数据属性来说是不可能的），如果尝试去读它，计算结果永远是 undefined。</p>

<p>存储器属性可以通过表达式在对象字面量语法中定义（不像我们在这里看到的其他 ES6 扩展，getter 和 setter 是 ES5 中的内容）：</p>

<pre><code class="language-javascript">let o = {
    // An ordinary data property
    dataProp: value,

    // An accessor property defined as a pair of functions.
    get accessorProp() { return this.dataProp; },
    set accessorProp(value) { this.dataProp = value; }
};
</code></pre>

<p>存储器属性定义为名称与属性名称相同的一个或两个方法。这些方法看起来像使用 ES6 速记定义的普通方法，只不过 getter 和 setter 定义使用 get 或 set 前缀。（在 ES6 中，在定义 getter 和 setter 时还可以使用计算属性名称。只需将带方括号的表达式替换属性名称即可。</p>

<p>上面定义的存储器方法只需获取并设置数据属性的值，没有理由将存储器属性替换数据属性。但作为一个更有趣的示例，请考虑以下表示 2D 笛卡尔点的对象。它具有表示点的 x 和 y 坐标的普通数据属性，并且具有提供点等效极坐标的存储器属性：</p>

<pre><code class="language-javascript">let p = {
    // x and y are regular read-write data properties.
    x: 1.0,
    y: 1.0,

    // r is a read-write accessor property with getter and setter.
    // Don&#39;t forget to put a comma after accessor methods.
    get r() { return Math.hypot(this.x, this.y); },
    set r(newvalue) {
        let oldvalue = Math.hypot(this.x, this.y);
        let ratio = newvalue/oldvalue;
        this.x *= ratio;
        this.y *= ratio;
    },

    // theta is a read-only accessor property with getter only.
    get theta() { return Math.atan2(this.y, this.x); }
};
p.r     // =&gt; Math.SQRT2
p.theta // =&gt; Math.PI / 4
</code></pre>

<p>请注意，在本示例中的 getter 和 setter 中使用 this 关键字。JavaScript 以对象的方法的方式调用这些函数，这意味着在函数体中，this 指的是点对象 p。因此，r 属性的 getter 方法通过 this.x 和 this.y 获取到 x 和 y 属性的引用。方法以及 this 关键字在 §8.2.2 中详细介绍。</p>

<p>存储器属性是可继承的，就像数据属性一样，因此可以使用上面定义的对象 p 作为其他点的原型。可以为新对象提供自有的 x 和 y 属性，它们将继承 r 和 theta 属性：</p>

<pre><code class="language-javascript">let q = Object.create(p); // A new object that inherits getters and setters
q.x = 3; q.y = 4;         // Create q&#39;s own data properties
q.r                       // =&gt; 5: the inherited accessor properties work
q.theta                   // =&gt; Math.atan2(4, 3)
</code></pre>

<p>上述代码使用存储器属性定义一个 API，该 API 提供一组数据的两种表示形式（笛卡尔坐标和极坐标）。使用存储器属性的其他场景包括属性写入的稳健性检测以及在每个属性上返回不同的值：</p>

<pre><code class="language-javascript">// This object generates strictly increasing serial numbers
const serialnum = {
    // This data property holds the next serial number.
    // The _ in the property name hints that it is for internal use only.
    _n: 0,

    // Return the current value and increment it
    get next() { return this._n++; },

    // Set a new value of n, but only if it is larger than current
    set next(n) {
        if (n &gt; this._n) this._n = n;
        else throw new Error(&quot;serial number can only be set to a larger value&quot;);
    }
};
serialnum.next = 10;    // Set the starting serial number
serialnum.next          // =&gt; 10
serialnum.next          // =&gt; 11: different value each time we get next
</code></pre>

<p>最后，下面是使用 getter 方法实现具有&quot;魔幻&quot;行为的属性的示例：</p>

<pre><code class="language-javascript">// This object has accessor properties that return random numbers.
// The expression &quot;random.octet&quot;, for example, yields a random number
// between 0 and 255 each time it is evaluated.
const random = {
    get octet() { return Math.floor(Math.random()*256); },
    get uint16() { return Math.floor(Math.random()*65536); },
    get int16() { return Math.floor(Math.random()*65536)-32768; }
};
</code></pre>

<h2 id="toc_28">6.11 总结</h2>

<p>本章非常详细地记录了 JavaScript 对象，涵盖的主题包括：</p>

<ul>
<li>基本对象术语，包括可枚举和自有属性等术语的含义。</li>
<li>对象字面量语法，包括 ES6 及以后的许多新特性。</li>
<li>如何读取、写入、删除、枚举和检查对象属性是否存在。</li>
<li>基于原型的继承是如何在 JavaScript 中工作，以及如何使用 Object.create() 创建一个从另一个对象继承的对象。</li>
<li>如何使用 Object.assign() 将属性从一个对象复制到另一个对象。</li>
<li>所有 JavaScript 的非原始值都是对象。这包括数组和函数，这是接下来两章的主题。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 7 章 数组]]></title>
    <link href="2019919.xyz/16124375850406.html"/>
    <updated>2021-02-04T19:19:45+08:00</updated>
    <id>2019919.xyz/16124375850406.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">7.1 创建数组</a>
<ul>
<li>
<a href="#toc_1">7.1.1 数组字面量</a>
</li>
<li>
<a href="#toc_2">7.1.2 展开运算符</a>
</li>
<li>
<a href="#toc_3">7.1.3 Array() 构造函数</a>
</li>
<li>
<a href="#toc_4">7.1.4 Array.of()</a>
</li>
<li>
<a href="#toc_5">7.1.5 Array.from()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">7.2 数组元素的读和写</a>
</li>
<li>
<a href="#toc_7">7.3 稀疏数组（Sparse Arrays）</a>
</li>
<li>
<a href="#toc_8">7.4 数组长度</a>
</li>
<li>
<a href="#toc_9">7.5 数组元素添加和删除</a>
</li>
<li>
<a href="#toc_10">7.6 数组遍历</a>
</li>
<li>
<a href="#toc_11">7.7 多维数组</a>
</li>
<li>
<a href="#toc_12">7.8 数组方法</a>
<ul>
<li>
<a href="#toc_13">7.8.1 数组迭代器方法</a>
<ul>
<li>
<a href="#toc_14">FOREACH()</a>
</li>
<li>
<a href="#toc_15">MAP()</a>
</li>
<li>
<a href="#toc_16">FILTER()</a>
</li>
<li>
<a href="#toc_17">FIND() 和 FINDINDEX()</a>
</li>
<li>
<a href="#toc_18">EVERY() 和 SOME()</a>
</li>
<li>
<a href="#toc_19">REDUCE() 和 REDUCERIGHT()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_20">7.8.2 用 flat() 和 flatMap() 展平数组</a>
</li>
<li>
<a href="#toc_21">7.8.3 用 concat() 添加数组</a>
</li>
<li>
<a href="#toc_22">7.8.4  push()、pop()、shift() 和 unshift() 与堆栈和队列</a>
</li>
<li>
<a href="#toc_23">7.8.5 slice()、splice()、fill() 和 copyWithin() 与子数组</a>
<ul>
<li>
<a href="#toc_24">SLICE()</a>
</li>
<li>
<a href="#toc_25">SPLICE()</a>
</li>
<li>
<a href="#toc_26">FILL()</a>
</li>
<li>
<a href="#toc_27">COPYWITHIN()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_28">7.8.6 数组的查询和排序方法</a>
<ul>
<li>
<a href="#toc_29">INDEXOF() 和 LASTINDEXOF()</a>
</li>
<li>
<a href="#toc_30">INCLUDES()</a>
</li>
<li>
<a href="#toc_31">SORT()</a>
</li>
<li>
<a href="#toc_32">REVERSE()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_33">7.8.7 数组转化字符串</a>
</li>
<li>
<a href="#toc_34">7.8.8 Array 的静态方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_35">7.9 类数组对象</a>
</li>
<li>
<a href="#toc_36">7.10 作为数组的字符串</a>
</li>
<li>
<a href="#toc_37">7.11 总结</a>
</li>
</ul>


<p>本章记录了数组、一个在 JavaScript 和大多数其他编程语言中的基本数据类型。数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript 数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。JavaScript 数组的索引是基于零的 32 位数值：第一个元素的索引为 0，最大可能的索引为 4,294,967,294（2<sup>32</sup>-2），数组最大能容纳 4,294,967,295 个元素。JavaScript 数组是动态的：根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。JavaScript 数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 大于任何元素的最高索引。</p>

<p>JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。我们将在本章的其他地方更多地讨论特殊化的数组。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。</p>

<p>数组继承自 Array.prototype 中的属性，它定义了一套丰富的数组操作方法，§7.8 涵盖这方面内容。大多数这些方法是通用的，这意味着它们不仅对真正的数组有效，而且对“类数组对象”同样有效。§7.9 讨论类数组对象。最后，JavaScript 字符串的行为与字符数组类似，我们将在 §7.10 讨论。</p>

<p>ES6 引入了一组新的数组类，这些类统称为“类型化数组”。与常规的 JavaScript 数组不同，类型化数组有固定的长度和固定的数值元素类型。它们提供高性能和对二进制数据的字节级访问，在 §11.2 中有介绍。</p>

<h2 id="toc_0">7.1 创建数组</h2>

<p>有很多种创建数组的方法。以下小节将说明如何使用以下方式创建数组：</p>

<ul>
<li>数组字面量</li>
<li>可迭代数组 ... 展开运算符</li>
<li>Array() 构造函数</li>
<li>Array.of() 和 Array.from() 工厂方法</li>
</ul>

<h3 id="toc_1">7.1.1 数组字面量</h3>

<p>到目前为止使用数组字面量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。例如：</p>

<pre><code class="language-javascript">let empty = [];                 // An array with no elements
let primes = [2, 3, 5, 7, 11];  // An array with 5 numeric elements
let misc = [ 1.1, true, &quot;a&quot;, ]; // 3 elements of various types + trailing comma
</code></pre>

<p>数组字面量中的值不一定要是常量；它们可以是任意的表达式：</p>

<pre><code class="language-javascript">let base = 1024;
let table = [base, base+1, base+2, base+3];
</code></pre>

<p>数组字面量可以包含对象字面量或其他数组字面量：</p>

<pre><code class="language-javascript">let b = [[1, {x: 1, y: 2}], [2, {x: 3, y: 4}]];
</code></pre>

<p>如果数组字面量在一行中包含多个逗号，之间没有值，则数组是稀疏的（请参阅 §7.3）。省略值的数组元素不存在，但如果查询它们则返回 undefined：</p>

<pre><code class="language-javascript">let count = [1,,3]; // Elements at indexes 0 and 2. No element at index 1
let undefs = [,,];  // An array with no elements but a length of 2
</code></pre>

<p>数组字面量语法允许可选的尾部逗号，所以 [,,] 的长度是 2，不是3。</p>

<h3 id="toc_2">7.1.2 展开运算符</h3>

<p>ES6 之后，可以使用展开操作符 ... 将一个数组中的元素展开在数组字面量中：</p>

<pre><code class="language-javascript">let a = [1, 2, 3];
let b = [0, ...a, 4];  // b == [0, 1, 2, 3, 4]
</code></pre>

<p>三个点展开数组 a，所以它的元素变成了数组字面量，并被创建在数组中。就像 ...a 被数组 a 的元素所替换，被列出作为未闭合的数组字面量的一部分。（注意，尽管我们称三点是展开运算符，但这并不是一个操作，因为它只能用于数组字面量和本书后面提到的函数调用。）</p>

<p>展开运算符可以方便的创建一个数组的拷贝（浅拷贝）：</p>

<pre><code class="language-javascript">let original = [1,2,3];
let copy = [...original];
copy[0] = 0;  // Modifying the copy does not change the original
original[0]   // =&gt; 1
</code></pre>

<p>展开运算符可以作用于任何可迭代对象。（可迭代对象是可以用 for/of 进行循环的对象；第一次在 §5.4.4 中提到，在第 12 章会看到更多关于它们的描述。）字符串是可迭代对象，所以可以使用展开操作符将字符串转换成单个字符的数组。</p>

<pre><code class="language-javascript">let digits = [...&quot;0123456789ABCDEF&quot;];
digits // =&gt; [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]
</code></pre>

<p>Set 对象（§11.1.1）是可迭代对象，所以数组去重有一种简单的方法是用展开运算符将数组转换成 set 然后再转成数组：</p>

<pre><code class="language-javascript">let letters = [...&quot;hello world&quot;];
[...new Set(letters)]  // =&gt; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;o&quot;,&quot; &quot;,&quot;w&quot;,&quot;r&quot;,&quot;d&quot;]
</code></pre>

<h3 id="toc_3">7.1.3 Array() 构造函数</h3>

<p>另一种创建数组的方法是使用 Array() 构造函数。可以用三种不同的方式调用这个构造函数：</p>

<p>调用时没有实参：</p>

<pre><code class="language-javascript">let a = new Array();
</code></pre>

<p>这个方法创建了一个没有元素的空数组，它等价于 [] 数组字面量。</p>

<p>调用时有一个数值实参，它指定了数组的长度：</p>

<pre><code class="language-javascript">let a = new Array(10);
</code></pre>

<p>该技术创建指定长度的数组。当预先知道所需元素个数时，这种形式的 Array() 构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性“0”、“1”等还未定义。</p>

<p>为数组显式指定两个或多个数组元素或者非数值元素：</p>

<pre><code class="language-javascript">let a = new Array(5, 4, 3, 2, 1, &quot;testing, testing&quot;);
</code></pre>

<p>以这种形式，构造函数的实参将会成为新数组的元素。使用数组字面量比这样使用 Array() 构造函数要简单多了。</p>

<h3 id="toc_4">7.1.4 Array.of()</h3>

<p>当 Array() 构造函数调用时有一个数值型实参，它会将实参作为数组的长度。但当调用时不止一个数值型实参时，它会将那些实参作为数组的元素创建。这意味着 Array() 构造函数不能创建只有一个数值型元素的数组。</p>

<p>在 ES6 中，Array.of() 函数修复了这个问题：它是一个将其实参值（无论有多少个实参）作为数组元素创建并返回一个新数组的工厂方法：</p>

<pre><code class="language-javascript">Array.of()        // =&gt; []; returns empty array with no arguments
Array.of(10)      // =&gt; [10]; can create arrays with a single numeric argument
Array.of(1,2,3)   // =&gt; [1, 2, 3]
</code></pre>

<h3 id="toc_5">7.1.5 Array.from()</h3>

<p>Array.from 是 ES6 中另外一个数组工厂方法。它期望一个可迭代或类数组对象作为它的第一个实参，并返回一个包含对象中元素的新数组。使用一个可迭代实参，Array.from(iterable) 工作方式类似于展开运算符 [...iterable]。它也可以简单的拷贝一个数组：</p>

<pre><code class="language-javascript">let copy = Array.from(original);
</code></pre>

<p>Array.from() 也很重要，因为它定义了一个将类数组对象拷贝成数组的方法。类数组对象是一个不是数组的对象，它有一个数值型的 length 属性，并且它的值碰巧保存在属性名为整数的属性中。当使用客户端 JavaScript 时，一些浏览器方法的返回值是类数组的，并且当将其转化成真正的数组后会更容易操作它们：</p>

<pre><code class="language-javascript">let truearray = Array.from(arraylike);
</code></pre>

<p>Array.from() 第二个实参为可选实参。如果传递一个函数作为第二个实参，那么当新数组被创建，每一个元素都会被作为实参传入这个指定函数中，并且这个函数的每个返回值保存在数组中代替原来的值。（这很像后面会介绍的数组 map() 方法，但是，它会更加高效的执行映射，因其为没有创建数组，而是直接进行映射到另外一个数组。）</p>

<h2 id="toc_6">7.2 数组元素的读和写</h2>

<p>使用 [] 运算符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的 JavaScript 语句：</p>

<pre><code class="language-javascript">let a = [&quot;world&quot;];     // Start with a one-element array
let value = a[0];      // Read element 0
a[1] = 3.14;           // Write element 1
let i = 2;
a[i] = 3;              // Write element 2
a[i + 1] = &quot;hello&quot;;    // Write element 3
a[a[i]] = a[0];        // Read elements 0 and 2, write element 3
</code></pre>

<p>数组特殊的是，当使用小于 2<sup>32</sup>–1 的非负整数属性名时，数组会自动维护 length 属性。例如，上文中我们创建了只有一个元素的数组 a。然后我们为其序列为 1、2 和 3 的元素进行赋值。数组 length 属性会自动改变：</p>

<pre><code class="language-javascript">a.length       // =&gt; 4
</code></pre>

<p>请记住，数组是对象的特殊形式。使用方括号访问数组元素就像用方括号访问对象的属性一样。JavaScript 将指定的数字索引值转换成字符串（索引值 1 变成“1”）然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做：</p>

<pre><code class="language-javascript">let o = {};    // Create a plain object
o[1] = &quot;one&quot;;  // Index it with an integer
o[&quot;1&quot;]         // =&gt; &quot;one&quot;; numeric and string property names are the same
</code></pre>

<p>清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有在 0～2<sup>32</sup>-2 之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的 length 属性值。</p>

<p>注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的：</p>

<pre><code class="language-javascript">a[-1.23] = true;  // This creates a property named &quot;-1.23&quot;
a[&quot;1000&quot;] = 0;    // This the 1001st element of the array
a[1.000] = 1;     // Array index 1. Same as a[1] = 1;
</code></pre>

<p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有“越界”错误的概念。当试图查询任何对象中不存在的属性时，都不会报错，只会得到 undefined 值。类似于对象，对于对象同样存在这种情况。</p>

<pre><code class="language-javascript">let a = [true, false]; // This array has elements at indexes 0 and 1
a[2]                   // =&gt; undefined; no element at this index.
a[-1]                  // =&gt; undefined; no property with this name.
</code></pre>

<h2 id="toc_7">7.3 稀疏数组（Sparse Arrays）</h2>

<p>稀疏数组就是包含从 0 开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array() 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。</p>

<pre><code class="language-javascript">let a = new Array(5); // No elements, but a.length is 5.
a = [];               // Create an array with no elements and length = 0.
a[1000] = 0;          // Assignment adds one element but sets length to 1001.
</code></pre>

<p>后面会看到你也可以用 delete 运算符来生产稀疏数组。</p>

<p>足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。</p>

<p>注意，当在数组字面量中省略值时（像 [1,,3] 中使用重复的逗号）返回的是稀疏数组，省略掉的值是不存在的：</p>

<pre><code class="language-javascript">let a1 = [,];           // This array has no elements and length 1
let a2 = [undefined];   // This array has one undefined element
0 in a1                 // =&gt; false: a1 has no element with index 0
0 in a2                 // =&gt; true: a2 has the undefined value at index 0
</code></pre>

<p>了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 undefined 元素。</p>

<h2 id="toc_8">7.4 数组长度</h2>

<p>每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，length 属性值代表数组中元素的个数。其值比数组中最大的索引大 1：</p>

<pre><code class="language-javascript">[].length             // =&gt; 0: the array has no elements
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].length  // =&gt; 3: highest index is 2, length is 3
</code></pre>

<p>当数组是稀疏的时，length 属性值大于元素的个数。而且关于此我们可以说数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。</p>

<p>第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于 n 的元素将从中删除：</p>

<pre><code class="language-javascript">a = [1,2,3,4,5];     // Start with a 5-element array.
a.length = 3;        // a is now [1,2,3].
a.length = 0;        // Delete all elements.  a is [].
a.length = 5;        // Length is 5, but no elements, like new Array(5)
</code></pre>

<p>还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个稀疏区域。</p>

<h2 id="toc_9">7.5 数组元素添加和删除</h2>

<p>我们已经见过添加数组元素最简单的方法：为新索引赋值：</p>

<pre><code class="language-javascript">let a = [];      // Start with an empty array.
a[0] = &quot;zero&quot;;   // And add elements to it.
a[1] = &quot;one&quot;;
</code></pre>

<p>也可以使用push()方法在数组末尾增加一个或多个元素：</p>

<pre><code class="language-javascript">let a = [];           // Start with an empty array
a.push(&quot;zero&quot;);       // Add a value at the end.  a = [&quot;zero&quot;]
a.push(&quot;one&quot;, &quot;two&quot;); // Add two more values.  a = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]
</code></pre>

<p>在数组尾部压入一个元素与给 a[a.length] 赋值是一样的。可以使用 unshift() 方法（§7.8 有描述）在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。pop() 方法与 push() 相反：它移除数组最后一个元素并返回这个元素，使数组 length 减 1。同样，shift() 方法移除并返回数组的第一个元素，使数组 length 减 1，并将其他元素依次移到低 1 的索引处。§7.8 有更多关于这些方法的描述。</p>

<p>可以像删除对象属性一样使用 delete 运算符来删除数组元素：</p>

<pre><code class="language-javascript">let a = [1,2,3];
delete a[2];   // a now has no element at index 2
2 in a         // =&gt; false: no array index 2 is defined
a.length       // =&gt; 3: delete does not affect array length
</code></pre>

<p>删除数组元素与为其赋 undefined 值是类似的（但有一些微妙的区别）。注意，对一个数组元素使用 delete 不会修改数组的 length 属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。</p>

<p>正如上面所看到的，也可以通过设置新的所需长度，即可从数组尾部删除元素。</p>

<p>最后，splice() 是一个通用的方法来插入、删除或替换数组元素。它会根据需要修改 length 属性并移动元素到更高或较低的索引处。详细内容见 §7.8。</p>

<h2 id="toc_10">7.6 数组遍历</h2>

<p>在 ES6 中，最容易遍历数组元素（或可迭代对象）的方法是 for/of 循环，在 §5.4.4 中详细介绍：</p>

<pre><code class="language-javascript">let letters = [...&quot;Hello world&quot;];  // An array of letters
let string = &quot;&quot;;
for(let letter of letters) {
    string += letter;
}
string  // =&gt; &quot;Hello world&quot;; we reassembled the original text
</code></pre>

<p>内置数组迭代器 for/of 循环按照升序返回数组元素。对于稀疏数组它没有特殊的行为，数组中不存在的元素只是单纯的返回 undefined。</p>

<p>如果使用 for/of 循环一个数组时还需要知道每个元素的索引，可以像这样将数组的 entries() 方法和解构语句一同使用：</p>

<pre><code class="language-javascript">let everyother = &quot;&quot;;
for(let [index, letter] of letters.entries()) {
    if (index % 2 === 0) everyother += letter;  // letters at even indexes
}
everyother  // =&gt; &quot;Hlowrd&quot;
</code></pre>

<p>另一种不错的遍历数组方法是用 forEach()。这不是 for 循环的新形式，而是提供数组遍历功能方法的数组方法。可以给数组的 forEach() 方法传递一个函数，forEach() 会对数组中每一个元素调用这个方法：</p>

<pre><code class="language-javascript">let uppercase = &quot;&quot;;
letters.forEach(letter =&gt; {  // Note arrow function syntax here
    uppercase += letter.toUpperCase();
});
uppercase  // =&gt; &quot;HELLO WORLD&quot;
</code></pre>

<p>正如期望的，forEach() 按顺序对数组进行计算，实际上它将数组索引作为第二个实参传递到函数，这有时很有用。与 for/of 循环不同，forEach() 能意识到稀疏数组，并且不会为不存在的元素调用函数。</p>

<p>§7.8.1 更详细地记录了 forEach() 方法。该部分还介绍演示了特定类型的数组遍历方法，如 map() 和 filter()。</p>

<p>也可以用一种非常老旧方式遍历数组的元素（§5.4.3）：</p>

<pre><code class="language-javascript">let vowels = &quot;&quot;;
for(let i = 0; i &lt; letters.length; i++) { // For each index in the array
    let letter = letters[i];              // Get the element at that index
    if (/[aeiou]/.test(letter)) {         // Use a regular expression test
        vowels += letter;                 // If it is a vowel, remember it
    }
}
vowels  // =&gt; &quot;eoo&quot;
</code></pre>

<p>在嵌套循环或其他性能至关重要的上下文中，有时可能会看到这样的数组遍历，以便数组长度仅被查一次，而不是在每次循环都去查询。以下两种形式都是符合习惯的 for 循环，虽然不是特别常用，而且对于现代 JavaScript 解释器，它们是否对性能有任何影响尚不清楚：</p>

<pre><code class="language-javascript">// Save the array length into a local variable
for(let i = 0, len = letters.length; i &lt; len; i++) {
    // loop body remains the same
}

// Iterate backwards from the end of the array to the start
for(let i = letters.length-1; i &gt;= 0; i--) {
    // loop body remains the same
}
</code></pre>

<p>这些示例假定数组是稠密的，并且所有元素都包含有效的数据。如果不是这样，应该在使用数组元素之前测试它们。如果要跳过 undefined 和不存在的元素，可以编写：</p>

<pre><code class="language-javascript">for(let i = 0; i &lt; a.length; i++) {
    if (a[i] === undefined) continue; // Skip undefined + nonexistent elements
    // loop body here
}
</code></pre>

<h2 id="toc_11">7.7 多维数组</h2>

<p>JavaScript 不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次 [] 操作符即可。例如，假设变量 matrix 是一个数组的数组，它的基本元素是数值，那么 matrix[x] 的每个元素是包含一个数值数组，访问数组中特定数值的代码为 matrix[x][y]。这里有一个具体的例子，它使用二维数组作为一个九九乘法表：</p>

<pre><code class="language-javascript">// Create a multidimensional array
let table = new Array(10);               // 10 rows of the table
for(let i = 0; i &lt; table.length; i++) {
    table[i] = new Array(10);            // Each row has 10 columns
}

// Initialize the array
for(let row = 0; row &lt; table.length; row++) {
    for(let col = 0; col &lt; table[row].length; col++) {
        table[row][col] = row*col;
    }
}

// Use the multidimensional array to compute 5*7
table[5][7]  // =&gt; 35
</code></pre>

<h2 id="toc_12">7.8 数组方法</h2>

<p>前面几节重点介绍了用于处理数组的基本 JavaScript 语法。但通常，由 Array 类定义的方法是最强大的。下一节将记录这些方法。在阅读有关这些方法时，请记住，其中一些方法修改了调用的数组，而其中一些方法使数组保持不变。许多方法返回数组：有时，这是一个新数组，原始数组保持不变。其他时候，方法将修改数组，并且返回对修改后数组的引用。</p>

<p>以下每个小节都涵盖一组相关的数组方法：</p>

<p>迭代器方法循环遍历数组的元素，通常调用在每个元素上指定的函数。</p>

<p>堆栈和队列方法在数组的开头和结尾添加和删除数组元素。</p>

<p>子数组方法用于提取、删除、插入、填充和复制一个更大数组中相邻的区域。</p>

<p>搜索和排序方法用于查找数组中的元素和排序数组的元素。</p>

<p>以下小节还介绍 Array 类的静态方法和一些用于连接数组和将数组转换为字符串的各种方法。</p>

<h3 id="toc_13">7.8.1 数组迭代器方法</h3>

<p>本节中介绍的方法通过将数组元素按顺序传递到所指定的函数来遍历数组，它们提供了迭代、映射、筛选、测试和减少数组的便捷方法。</p>

<p>然而，在详细解释这些方法之前，值得对它们进行一些概括。首先，所有这些方法都接受函数作为其第一个实参，并使用调用数组的每个元素（或某些元素）作为实参调用该函数。如果数组是稀疏的，则不会为不存在的元素调用传递的函数。在大多数情况下，提供的函数被调用时有三个实参：数组元素的值、数组元素的索引和数组本身。通常，只需要这些实参值中的第一个，并且可以忽略第二个和第三个值。</p>

<p>以下小节中描述的大多数迭代器方法都接受可选的第二个实参。如果指定，则调用函数就像它是第二个实参的方法一样。也就是说，传递的第二个实参将成为第一个函数实参内部的 this 值。传递的函数的返回值通常很重要，但不同的方法以不同的方式处理返回值。此处描述的方法都没有修改调用它们的数组（当然，传递的函数可以修改这个数组）。</p>

<p>这节的每个函数都调用它的第一个函数实参，并且通常将该函数内联定义为方法调用表达式的一部分，而不是使用在其他地方显示定义的函数。箭头函数语法（参见 §8.1.3）在这些方法中特别有效，我们将在下面的示例中使用它。</p>

<h4 id="toc_14">FOREACH()</h4>

<p>forEach() 方法遍历数组，调用为每个元素指定的函数。正如我们已经描述的那样，将函数作为第一个实参传递给 forEach()。forEach() 然后使用三个实参调用函数：数组元素的值、数组元素的索引和数组本身。如果只关心数组元素的值，则编写一个只有一个实参的函数（将忽略其他实参）：</p>

<pre><code class="language-javascript">let data = [1,2,3,4,5], sum = 0;
// Compute the sum of the elements of the array
data.forEach(value =&gt; { sum += value; });          // sum == 15

// Now increment each array element
data.forEach(function(v, i, a) { a[i] = v + 1; }); // data == [2,3,4,5,6]
</code></pre>

<p>请注意，forEach() 不提供在所有元素传递给函数之前终止迭代的方法。也就是说，没有等效于常规 for 循环的 break 语句可以使用。</p>

<h4 id="toc_15">MAP()</h4>

<p>map() 方法将调用数组的每个元素传递到指定的函数，并返回一个包含函数返回的值的数组。例如：</p>

<pre><code class="language-javascript">let a = [1, 2, 3];
a.map(x =&gt; x*x)   // =&gt; [1, 4, 9]: the function takes input x and returns x*x
</code></pre>

<p>传递到 map() 的函数的调用方式与传递给 forEach() 的函数相同。但是，对于 map() 方法，传递的函数应返回一个值。请注意，map() 返回一个新数组：它不会修改调用它的数组。如果该数组是稀疏的，则不会为缺失的元素调用函数，但返回的数组将稀疏，其确实元素与原始数组的位置相同：它将具有相同的长度和相同的缺失元素。</p>

<h4 id="toc_16">FILTER()</h4>

<p>filter() 方法返回一个数组，其中包含调用该数组的数组元素的子集。传递给它的函数应该是断言：返回真或假的函数。断言函数的调用就像 forEach() 和 map() 调用一样。如果返回值为 true，或者能转换为 true 的值，则传递给断言的元素是子集的成员，并将添加到将成为返回值的数组中。例子：</p>

<pre><code class="language-javascript">let a = [5, 4, 3, 2, 1];
a.filter(x =&gt; x &lt; 3)         // =&gt; [2, 1]; values less than 3
a.filter((x,i) =&gt; i%2 === 0) // =&gt; [5, 3, 1]; every other value
</code></pre>

<p>注意 filter() 跳过稀疏数组中的丢失元素并且返回值也总是稠密的。要缩小稀疏数组的间距，可以这样做：</p>

<pre><code class="language-javascript">let dense = sparse.filter(() =&gt; true);
</code></pre>

<p>要缩小间隙并移除 undefined 和 null 元素，可以用 filter 这样做：</p>

<pre><code class="language-javascript">a = a.filter(x =&gt; x !== undefined &amp;&amp; x !== null);
</code></pre>

<h4 id="toc_17">FIND() 和 FINDINDEX()</h4>

<p>find() 和 findIndex() 方法就像 filter()，因为它们在数组中迭代，查找断言函数返回真实值的元素。但是，与 filter()不同，这两种方法在断言首次查找元素到时停止遍历。发生这种情况时，find() 返回匹配元素，而 findIndex() 返回匹配元素的索引。如果未找到匹配元素，find() 返回 undefined，findIndex() 返回 -1：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.findIndex(x =&gt; x === 3)  // =&gt; 2; the value 3 appears at index 2
a.findIndex(x =&gt; x &lt; 0)    // =&gt; -1; no negative numbers in the array
a.find(x =&gt; x % 5 === 0)   // =&gt; 5: this is a multiple of 5
a.find(x =&gt; x % 7 === 0)   // =&gt; undefined: no multiples of 7 in the array
</code></pre>

<h4 id="toc_18">EVERY() 和 SOME()</h4>

<p>every() 和 some() 方法是数组断言：它们将指定的断言函数应用于数组的元素，然后返回 true 或 false。</p>

<p>every() 方法与数学全称量化符号 ∀ 相似：如果数组中所有元素执行断言函数返回值都为 true，则返回 true：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.every(x =&gt; x &lt; 10)      // =&gt; true: all values are &lt; 10.
a.every(x =&gt; x % 2 === 0) // =&gt; false: not all values are even.
</code></pre>

<p>some() 方法与数学存在限定符 ∃ 相同：如果数组中存在至少有一个元素调用断言函数返回 true 的返回 true，仅在断言全部返回 false 时返回 false：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.some(x =&gt; x%2===0)  // =&gt; true; a has some even numbers.
a.some(isNaN)         // =&gt; false; a has no non-numbers.
</code></pre>

<p>请注意，every() 和 some() 只要它们知道要返回的值，都停止对数组元素的遍历。some() 在断言函数第一次返回 true 时返回 true，并且只有在每个元素调用断言函数都返回 false 时，才会遍历整个数组 。every() 正好相反：它返回 false 时，您的谓词返回 false，并且仅在谓词始终返回 true 时，才会回注所有元素。另请注意，根据数学约定，every() 返回 true，有些返回 false，当在空数组上调用时，某些返回 false。</p>

<h4 id="toc_19">REDUCE() 和 REDUCERIGHT()</h4>

<p>reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。举例说明它是如何工作的：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.reduce((x,y) =&gt; x+y, 0)          // =&gt; 15; the sum of the values
a.reduce((x,y) =&gt; x*y, 1)          // =&gt; 120; the product of the values
a.reduce((x,y) =&gt; (x &gt; y) ? x : y) // =&gt; 5; the largest of the values
</code></pre>

<p>reduce() 需要两个实参。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的实参是一个传递给函数的初始值。</p>

<p>reduce() 使用的函数与 forEach() 和 map() 使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第 2～4 个实参传递给函数。第一个实参是到目前为止的化简操作累积的结果。第一次调用函数时，第一个实参是一个初始值，它就是传递给 reduce() 的第二个实参。在接下来的调用中，这个值就是上一次化简函数的返回值。在上面的第一个例子中，第一次调用化简函数时的实参是 0 和 1。将两者相加并返回 1。再次调用时的实参是 1 和 2，它返回 3。然后它计算 3+3=6、6+4=10， 最后计算 10+5=15。最后的值是 15，reduce() 返回这个值。</p>

<p>可能已经注意到了，上面第三次调用 reduce() 时只有一个实参：没有指定初始值。当不指定初始值调用 reduce() 时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个实参。在上面求和与求积的例子中，可以省略初始值实参。</p>

<p>在空数组上，不带初始值实参调用 reduce() 将导致类型错误异常。如果调用它的时候只有一个值（数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值）reduce() 只是简单地返回那个值而不会调用化简函数。</p>

<p>reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低（从右到左）处理数组，而不是从低到高。如果 reduction 操作的优先顺序是从右到左，你可能想使用它，例如：</p>

<pre><code class="language-javascript">// Compute 2^(3^4).  Exponentiation has right-to-left precedence
let a = [2, 3, 4];
a.reduceRight((acc,val) =&gt; Math.pow(val,acc)) // =&gt; 2.4178516392292583e+24
</code></pre>

<p>注意，reduce() 和 reduceRight() 都能接收一个可选的实参，它指定了化简函数调用时的 this 关键字的值。可选的初始值实参仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，请参看 Function.bind() 方法（§8.7.5）。</p>

<p>为了简单起见，到目前位置所展示的例子都是数值的，但数学计算不是 reduce() 和 reduceRight() 的唯一意图。任何想要将两个相同类型的值（例如两个对象）合并到一个值的函数都可以用化简函数。另一方面，使用数组化简的算法可能很快变得复杂且难以理解，可能会发现，如果使用常规循环构造来处理数组则更容易读、写和推理。</p>

<h3 id="toc_20">7.8.2 用 flat() 和 flatMap() 展平数组</h3>

<p>在 ES2019 中，flat() 方法创建并返回一个新的数组，该数组包含与调用的数组相同的元素，只不过作为数组的任何元素都&quot;展平&quot;到返回的数组中。例如：</p>

<pre><code class="language-javascript">[1, [2, 3]].flat()    // =&gt; [1, 2, 3]
[1, [2, [3]]].flat()  // =&gt; [1, 2, [3]]
</code></pre>

<p>当调用时没有实参，flat() 将平展一个级别的嵌套。作为数组的原始数组的元素被展平，但这些数组的数组元素不会展平。如果要展平更多级别，需要传递数字给 flat()：</p>

<pre><code class="language-javascript">let a = [1, [2, [3, [4]]]];
a.flat(1)   // =&gt; [1, 2, [3, [4]]]
a.flat(2)   // =&gt; [1, 2, 3, [4]]
a.flat(3)   // =&gt; [1, 2, 3, 4]
a.flat(4)   // =&gt; [1, 2, 3, 4]
</code></pre>

<p>flatMap() 方法的工作方式与 map() 方法（见“map()”）类似，只不过返回的数组会自动展平，就像传递到 flat()。也就是说，调用 a.flatMap(f) 与 a.map(f).flat()（但更高效）相同：</p>

<pre><code class="language-javascript">let phrases = [&quot;hello world&quot;, &quot;the definitive guide&quot;];
let words = phrases.flatMap(phrase =&gt; phrase.split(&quot; &quot;));
words // =&gt; [&quot;hello&quot;, &quot;world&quot;, &quot;the&quot;, &quot;definitive&quot;, &quot;guide&quot;];
</code></pre>

<p>可以将 flatMap() 视为 map() 的泛化，它允许输入数组的每个元素映射到输出数组的多个元素。特别的是，flatMap() 允许将输入元素映射到空数组，该数组在平展后不输出到数组中：</p>

<pre><code class="language-javascript">// Map non-negative numbers to their square roots
[-2, -1, 1, 2].flatMap(x =&gt; x &lt; 0 ? [] : Math.sqrt(x)) // =&gt; [1, 2**0.5]
</code></pre>

<h3 id="toc_21">7.8.3 用 concat() 添加数组</h3>

<p>concat() 方法创建并返回一个新数组，它的元素包括调用 concat() 的原始数组的元素和 concat() 的每个实参。如果这些实参中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat() 不会递归扁平化数组的数组。concat() 也不会修改调用的数组：</p>

<pre><code class="language-javascript">let a = [1,2,3];
a.concat(4, 5)          // =&gt; [1,2,3,4,5]
a.concat([4,5],[6,7])   // =&gt; [1,2,3,4,5,6,7]; arrays are flattened
a.concat(4, [5,[6,7]])  // =&gt; [1,2,3,4,5,[6,7]]; but not nested arrays
a                       // =&gt; [1,2,3]; the original array is unmodified
</code></pre>

<p>请注意，concat() 创建调用数组的新副本。在许多情况下，这是正确的做法，但它是一个昂贵的操作。如果您发现自己编写代码像 <code>a = a.concat(x)</code>，那么您应该考虑使用 push() 或 splice() 修改数组，而不是创建新的数组。</p>

<h3 id="toc_22">7.8.4  push()、pop()、shift() 和 unshift() 与堆栈和队列</h3>

<p>push() 和 pop() 方法允许将数组当做栈来使用。push() 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop() 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。注意，两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用 push() 和 pop() 能够用 JavaScript 数组实现先进后出的栈。例如：</p>

<pre><code class="language-javascript">let stack = [];       // stack == []
stack.push(1,2);      // stack == [1,2];
stack.pop();          // stack == [1]; returns 2
stack.push(3);        // stack == [1,3]
stack.pop();          // stack == [1]; returns 3
stack.push([4,5]);    // stack == [1,[4,5]]
stack.pop()           // stack == [1]; returns [4,5]
stack.pop();          // stack == []; returns 1
</code></pre>

<p>push() 方法不展平传入的数组，但如果想要将数组的元素全部压入另外一个数组，可以使用展开运算符（§8.3.4）来显示展开：</p>

<pre><code class="language-javascript">a.push(...values);
</code></pre>

<p>unshift() 和 shift() 方法的行为非常类似于 push() 和 pop()，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。unshift() 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。shift() 删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。可以使用 unshift() 和 shift() 实现栈，但它比使用 push() 和 pop() 的效率低，因为每次在数组头部添加或删除元素时，都需要向上或向下移动数组元素。但是，您可以使用 push() 在数组末尾添加元素并 shift() 从数组的头部删除它们来实现队列数据解构：</p>

<pre><code class="language-javascript">let q = [];            // q == []
q.push(1,2);           // q == [1,2]
q.shift();             // q == [2]; returns 1
q.push(3)              // q == [2, 3]
q.shift()              // q == [3]; returns 2
q.shift()              // q == []; returns 3
</code></pre>

<p>unshift() 有一个特性是值得一提的，你可能会觉得它令人惊讶。将多个实参传入 unshift() 时，它们将一次全部插入，这意味着它们最终在数组中的顺序与一次插入一个实参的顺序时不同的：</p>

<pre><code class="language-javascript">let a = [];            // a == []
a.unshift(1)           // a == [1]
a.unshift(2)           // a == [2, 1]
a = [];                // a == []
a.unshift(1,2)         // a == [1, 2]
</code></pre>

<h3 id="toc_23">7.8.5 slice()、splice()、fill() 和 copyWithin() 与子数组</h3>

<p>数组定义了许多在连续区域，子数组或数组的“片段”上工作的方法。 以下各节描述了提取，替换，填充和复制片段的方法。</p>

<h4 id="toc_24">SLICE()</h4>

<p>slice() 方法返回指定数组的一个片段或子数组。它的两个实参分别指定了片段的开始和结束的位置。返回的数组包含第一个实参指定的位置到（但不包含）第二个实参指定的位置之间的所有数组元素。如果只指定一个实参，返回的数组将包含从开始位置到数组结尾的所有元素。如实参中出现负数，它表示相对于数组 length 的位置。例如，实参 -1 指定了最后一个元素，而 -2 指定了它前面的元素。注意，slice() 不会修改调用的数组。下面有一些示例：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.slice(0,3);    // Returns [1,2,3]
a.slice(3);      // Returns [4,5]
a.slice(1,-1);   // Returns [2,3,4]
a.slice(-3,-2);  // Returns [3]
</code></pre>

<h4 id="toc_25">SPLICE()</h4>

<p>splice() 方法是在数组中插入或删除元素的通用方法。不同于 slice() 和 concat()，splice() 会修改调用的数组。注意，splice() 和 slice() 拥有非常相似的名字， 但它们的功能却有本质的区别。</p>

<p>splice() 能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。splice() 的第一个实参指定了插入和（或）删除的起始位置。第二个实参指定了应该从数组中删除的元素的个数。（注意这里是这两个方法的另外一个不同。slice() 的第二个实参是结束的位置。splice() 的第二个实参是长度。）如果省略第二个实参，从起始点开始到数组结尾的所有元素都将被删除。splice() 返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5,6,7,8];
a.splice(4)    // =&gt; [5,6,7,8]; a is now [1,2,3,4]
a.splice(1,2)  // =&gt; [2,3]; a is now [1,4]
a.splice(1,1)  // =&gt; [4]; a is now [1]
</code></pre>

<p>splice() 的前两个实参指定了需要删除的数组元素。紧随其后的任意个数的实参指定了需要插入到数组中的元素，从第一个实参指定的位置开始插入。例如：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.splice(2,0,&quot;a&quot;,&quot;b&quot;)  // =&gt; []; a is now [1,2,&quot;a&quot;,&quot;b&quot;,3,4,5]
a.splice(2,2,[1,2],3)  // =&gt; [&quot;a&quot;,&quot;b&quot;]; a is now [1,2,[1,2],3,3,4,5]
</code></pre>

<p>注意，不同于 concat()，splice() 插入数组本身，不是数组的元素。</p>

<h4 id="toc_26">FILL()</h4>

<p>fill() 方法将数组或数组片段的元素填充为指定值。它将对调用它的数组进行突变，并返回修改后的数组：</p>

<pre><code class="language-javascript">let a = new Array(5);   // Start with no elements and length 5
a.fill(0)               // =&gt; [0,0,0,0,0]; fill the array with zeros
a.fill(9, 1)            // =&gt; [0,9,9,9,9]; fill with 9 starting at index 1
a.fill(8, 2, -1)        // =&gt; [0,9,8,8,9]; fill with 8 at indexes 2, 3
</code></pre>

<p>fill() 的第一个实参是将数组元素填充的值。可选的第二个实参指定起始索引。如果省略，则填充将从索引 0 开始。可选的第三个实参指定结束索引，将填充到（但不包括）该索引的数组元素。 如果省略此实参，则从起始索引到末尾填充数组。可以通过传递负数来指定相对于数组末尾的索引，就像 slice() 一样。</p>

<h4 id="toc_27">COPYWITHIN()</h4>

<p>copyWithin() 将数组的一个片段复制到数组中的新位置。它在适当的位置修改数组并返回修改后的数组，但不会更改数组的长度。第一个实参指定将第一个元素复制到的目标索引。第二个实参指定被复制的第一个元素的索引。如果省略此第二个实参，则使用 0。第三个实参指定被复制的元素片段的结尾。如果省略，则使用数组的长度。从开始索引到结束索引（但不包括结束索引）的元素将被复制。可以通过传递负数来指定相对于数组末尾的索引，就像 slice() 一样：</p>

<pre><code class="language-javascript">let a = [1,2,3,4,5];
a.copyWithin(1)       // =&gt; [1,1,2,3,4]: copy array elements up one
a.copyWithin(2, 3, 5) // =&gt; [1,2,3,4,4]: copy last 2 elements to index 2
a.copyWithin(0, -2)   // =&gt; [4,4,3,4,4]: negative offsets work, too
</code></pre>

<p>copyWithin() 旨在作为一种高性能方法，对类型化数组特别有用（请参见 §11.2）。它模仿的 C 标准库中 memmove() 函数。 请注意，即使源区域和目标区域之间存在重叠，该拷贝也可以正常工作。</p>

<h3 id="toc_28">7.8.6 数组的查询和排序方法</h3>

<p>数组实现 indexOf()、lastIndexOf() 和 include() 方法，这些方法类似于名称相同的字符串方法。还有 sort() 和 reverse() 方法，用于对数组元素进行重新排序。这些方法在下面的小节中介绍。</p>

<h4 id="toc_29">INDEXOF() 和 LASTINDEXOF()</h4>

<p>indexOf() 和 lastIndexOf() 在数组中搜索具有指定值的元素，并返回找到的第一个元素的索引，如果未找到，则返回 -1。indexOf() 从头到尾搜索数组，lastIndexOf() 从尾到头搜索：</p>

<pre><code class="language-javascript">let a = [0,1,2,1,0];
a.indexOf(1)       // =&gt; 1: a[1] is 1
a.lastIndexOf(1)   // =&gt; 3: a[3] is 1
a.indexOf(3)       // =&gt; -1: no element has value 3
</code></pre>

<p>indexOf() 和 lastIndexOf() 使用 === 运算符将其实参与数组元素进行比较。如果数组包含对象而不是原始值，则这些方法将检查两个引用是否都指向完全相同的对象。如果要实际查看对象的内容，尝试将 find() 方法代替自定义的断言函数。</p>

<p>indexOf() 和 lastIndexOf() 采用可选的第二个实参，该实参指定开始搜索的数组索引。如果省略此参数，则 indexOf() 从开头开始，lastIndexOf() 从结尾开始。第二个参数允许使用负值，并将其视为距数组末端的偏移量，就像 slice() 方法一样：例如，值 –1 指定数组的最后一个元素。</p>

<p>以下函数在数组中搜索指定的值，并返回所有匹配索引的数组。这演示了如何使用 indexOf() 的第二个参数来查找第一个参数之外的匹配项。</p>

<pre><code class="language-javascript">// Find all occurrences of a value x in an array a and return an array
// of matching indexes
function findall(a, x) {
    let results = [],            // The array of indexes we&#39;ll return
        len = a.length,          // The length of the array to be searched
        pos = 0;                 // The position to search from
    while(pos &lt; len) {           // While more elements to search...
        pos = a.indexOf(x, pos); // Search
        if (pos === -1) break;   // If nothing found, we&#39;re done.
        results.push(pos);       // Otherwise, store index in array
        pos = pos + 1;           // And start next search at next element
    }
    return results;              // Return array of indexes
}
</code></pre>

<p>请注意，字符串具有 indexOf() 和 lastIndexOf() 方法，它们与这些数组方法一样工作，不同之处在于第二个实参是负数时被视为零。</p>

<h4 id="toc_30">INCLUDES()</h4>

<p>ES2016 的 includes() 方法采用单个实参，如果数组包含该值返回 true 否则 false。它不会告诉你值的索引，只告诉你该值是否存在。includes() 方法实际上是数组集的成员身份测试。但是请注意，数组不是 Set 的高效表示形式，如果使用多个元素，则应使用真正的 Set 对象（§11.1.1）。</p>

<p>includes() 方法在一个重要方面与 indexOf() 方法略有不同。indexOf() 与 === 运算符使用相同的算法测试相等性，并且这个相等算法认为非数字值与所有其他值（包括自身）不同。includes() 使用略有不同的相等算法，它认为 NaN 等于自身。这意味着 indexOf() 不会检测数组中的 NaN 值，但 includes() 可以：</p>

<pre><code class="language-javascript">let a = [1,true,3,NaN];
a.includes(true)            // =&gt; true
a.includes(2)               // =&gt; false
a.includes(NaN)             // =&gt; true
a.indexOf(NaN)              // =&gt; -1; indexOf can&#39;t find NaN
</code></pre>

<h4 id="toc_31">SORT()</h4>

<p>sort() 对数组的元素直接进行排序，并返回排序后的数组。当调用 sort() 时，它会按字母顺序对数组元素进行排序（如有必要，暂时将它们转换为字符串以执行比较）：</p>

<pre><code class="language-javascript">let a = [&quot;banana&quot;, &quot;cherry&quot;, &quot;apple&quot;];
a.sort(); // a == [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]
</code></pre>

<p>如果数组中包含 undefined 元素，它们会被放在数组的结尾。</p>

<p>若要将数组按字母顺序以外的顺序排序，必须将比较函数作为实参传递给 sort()。该函数决定了它的两个实参在排好序的数组中的先后顺序。假设第一个实参应该在前，比较函数应该返回一个小于 0 的数值。反之，假设第一个参数应该在后，函数应该返回一个大于 0 的数值。并且，假设两个值相等（也就是说，它们的顺序无关紧要），函数应该返回 0。例如，用数值大小而非字母表顺序进行数组排序，代码如下：</p>

<pre><code class="language-javascript">let a = [33, 4, 1111, 222];
a.sort();               // a == [1111, 222, 33, 4]; alphabetical order
a.sort(function(a,b) {  // Pass a comparator function
    return a-b;         // Returns &lt; 0, 0, or &gt; 0, depending on order
});                     // a == [4, 33, 222, 1111]; numerical order
a.sort((a,b) =&gt; b-a);   // a == [1111, 222, 33, 4]; reverse numerical order
</code></pre>

<p>另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将实参都转化为小写字符串（使用 toLowerCase() 方法），再开始比较：</p>

<pre><code class="language-javascript">let a = [&quot;ant&quot;, &quot;Bug&quot;, &quot;cat&quot;, &quot;Dog&quot;];
a.sort();    // a == [&quot;Bug&quot;,&quot;Dog&quot;,&quot;ant&quot;,&quot;cat&quot;]; case-sensitive sort
a.sort(function(s,t) {
    let a = s.toLowerCase();
    let b = t.toLowerCase();
    if (a &lt; b) return -1;
    if (a &gt; b) return 1;
    return 0;
});   // a == [&quot;ant&quot;,&quot;Bug&quot;,&quot;cat&quot;,&quot;Dog&quot;]; case-insensitive sort
</code></pre>

<h4 id="toc_32">REVERSE()</h4>

<p>reverse() 方法反转数组中元素的顺序并返回反转后的数组。它直接在数组中操作，换一种说法，它不创建一个新的数组，它不创建一个新的带有排序后的元素的数组，而是直接在已存在的数组中进行排序。</p>

<pre><code class="language-javascript">let a = [1,2,3];
a.reverse();   // a == [3,2,1]
</code></pre>

<h3 id="toc_33">7.8.7 数组转化字符串</h3>

<p>Array 类定义了三个方法来将数组转化为字符串，通常在创建日志和错误信息时会用到。（如果要以文本形式保存数组的内容供以后重用，请使用 JSON.stringify()（§6.8）序列化数组，而不是使用此处描述的方法。）</p>

<p>join() 方法将数组的所有元素转换为字符串并连接它们，返回生成的字符串。可以指定一个可选字符串来分隔生成的字符串中的元素。如果未指定分隔符字符串，则使用逗号：</p>

<pre><code class="language-javascript">let a = [1, 2, 3];
a.join()               // =&gt; &quot;1,2,3&quot;
a.join(&quot; &quot;)            // =&gt; &quot;1 2 3&quot;
a.join(&quot;&quot;)             // =&gt; &quot;123&quot;
let b = new Array(10); // An array of length 10 with no elements
b.join(&quot;-&quot;)            // =&gt; &quot;---------&quot;: a string of 9 hyphens
</code></pre>

<p>join() 方法是 String.split() 方法的反向方法，该方法通过将字符串拆分为多个片段来创建数组。</p>

<p>数组与所有 JavaScript 对象一样，具有 toString() 方法。对于数组，此方法的工作方式与没有参数的 join() 方法相同：</p>

<pre><code class="language-javascript">[1,2,3].toString()          // =&gt; &quot;1,2,3&quot;
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].toString()  // =&gt; &quot;a,b,c&quot;
[1, [2,&quot;c&quot;]].toString()     // =&gt; &quot;1,2,c&quot;
</code></pre>

<p>请注意，输出不包括方括号或数组值周围的任何其他分隔符。</p>

<p>toLocaleString() 是 toString() 的本地化版本。它通过调用元素的 toLocaleString() 方法将每个数组元素转换为字符串，然后使用特定于区域设置（和实现定义）分隔符字符串连接生成的字符串。</p>

<h3 id="toc_34">7.8.8 Array 的静态方法</h3>

<p>除了我们已经记录的数组方法之外，Array 类还定义了三个静态函数，可以通过 Array 构造函数而不是数组调用。Array.of() 和 Array.from() 是用于创建新数组的工厂方法。它们记录在 §7.1.4 和 §7.1.5 中。</p>

<p>另外一个静态数组方法是 Array.isArray()，用来判断一个未知值是否是数组：</p>

<pre><code class="language-javascript">Array.isArray([])     // =&gt; true
Array.isArray({})     // =&gt; false
</code></pre>

<h2 id="toc_35">7.9 类数组对象</h2>

<p>我们已经看到，JavaScript 数组的有一些特性是其他对象所没有的：</p>

<ul>
<li>当有新的元素添加到列表中时，自动更新 length 属性。</li>
<li>length 设置为一个较小值将截断数组。</li>
<li>从 Array.prototype 中继承一些有用的方法。</li>
<li>数组传入 Array.isArray() 方法返回 true。</li>
</ul>

<p>这些特性让 JavaScript 数组和常规的对象有明显的区别。但是它们不是定义数组的本质特性。一种常常完全合理的看法是把拥有一个数值型 length 属性和对应非负整数属性的对象看作数组的同类。</p>

<p>实际上这些“类数组”对象在实践中偶尔出现，虽然不能通过它们直接调用数组方法或者期望 length 属性有什么特殊的行为，但是仍然可以用针对真正数组遍历代码来遍历它们。结论就是很多数组算法针对类数组对象同样奏效，就像针对真正的数组一样。尤其是这种情况，算法把数组看成只读的或者如果保持数组长度不变。</p>

<p>以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”：</p>

<pre><code class="language-javascript">let a = {};  // Start with a regular empty object

// Add properties to make it &quot;array-like&quot;
let i = 0;
while(i &lt; 10) {
    a[i] = i * i;
    i++;
}
a.length = i;

// Now iterate through it as if it were a real array
let total = 0;
for(let j = 0; j &lt; a.length; j++) {
    total += a[j];
}
</code></pre>

<p>在客户端 JavaScript 中，很多作用于 HTML documents 的方法（例如 document.querySelectorAll()）返回类数组对象。下面这个函数可能会用于测试对象是否可以用作类数组：</p>

<pre><code class="language-javascript">// Determine if o is an array-like object.
// Strings and functions have numeric length properties, but are
// excluded by the typeof test. In client-side JavaScript, DOM text
// nodes have a numeric length property, and may need to be excluded
// with an additional o.nodeType !== 3 test.
function isArrayLike(o) {
    if (o &amp;&amp;                            // o is not null, undefined, etc.
        typeof o === &quot;object&quot; &amp;&amp;        // o is an object
        Number.isFinite(o.length) &amp;&amp;    // o.length is a finite number
        o.length &gt;= 0 &amp;&amp;                // o.length is non-negative
        Number.isInteger(o.length) &amp;&amp;   // o.length is an integer
        o.length &lt; 4294967295) {        // o.length &lt; 2^32 - 1
        return true;                    // Then o is array-like.
    } else {
        return false;                   // Otherwise it is not.
    }
}
</code></pre>

<p>我们会在下一节看到字符串的行为像数组一样。尽管如此，对于数组这种测试（对字符串通常返回 false ）它们通常最好作为字符串处理，而不是作为数组处理。</p>

<p>大多数 JavaScript 数组方法都特意定义为泛型，以便它们在应用于除数组之外的类数组可以正常工作。由于类数组对象不会从 Array.prototype 继承，因此不能直接在它们上调用数组方法。但是，可以使用 Function.call 方法间接调用它们（详情请参阅 §8.7.4）：</p>

<pre><code class="language-javascript">let a = {&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;, length: 3}; // An array-like object
Array.prototype.join.call(a, &quot;+&quot;)                  // =&gt; &quot;a+b+c&quot;
Array.prototype.map.call(a, x =&gt; x.toUpperCase())  // =&gt; [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
Array.prototype.slice.call(a, 0)   // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]: true array copy
Array.from(a)                      // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]: easier array copy
</code></pre>

<p>此代码倒数第二行调用数组类对象上的 Array slice() 方法，以便将该对象的元素复制到真正的数组对象中。这是一个惯用的技巧，存在于许多旧代码中，但现在使用 Array.from() 要容易得多。</p>

<h2 id="toc_36">7.10 作为数组的字符串</h2>

<p>JavaScript 字符串的行为类似于 UTF-16 Unicode 字符的只读数组。可以使用方括号替代 charAt() 方法访问单个字符：</p>

<pre><code class="language-javascript">let s = &quot;test&quot;;
s.charAt(0)    // =&gt; &quot;t&quot;
s[1]           // =&gt; &quot;e&quot;
</code></pre>

<p>当然，字符串使用 typeof 运算符仍然返回 &quot;string&quot;，如果将字符串传递给 Array.isArray() 方法，则返回 false。</p>

<p>可索引字符串的主要好处是，我们可以用方括号替换对 charAt() 的调用，方括号更简洁、更可读，而且可能更高效。但是，字符串的行为类似于数组，也意味着我们可以对它们应用泛型数组方法。例如：</p>

<pre><code class="language-javascript">Array.prototype.join.call(&quot;JavaScript&quot;, &quot; &quot;)  // =&gt; &quot;J a v a S c r i p t&quot;
</code></pre>

<p>请记住，字符串是不可变值，因此当字符串被视为数组时，它们是只读数组。数组方法 push()、sort()、reverse() 和 splice() 直接修改数组，它们不能处理字符串。但是，尝试使用数组方法修改字符串不会引发异常：它只是静默失败。</p>

<h2 id="toc_37">7.11 总结</h2>

<p>本章深入介绍了 JavaScript 数组，包括有关稀疏数组和类数组对象的深奥细节。本章要点包括：</p>

<ul>
<li>数组字面量编写：方括号内逗号分隔值列表。</li>
<li>通过在方括号内指定所需的数组索引来访问单个数组元素。</li>
<li>for/of 循环和 ES6 中引入的 ... 展开运算符是遍历数组的特别有用的方法。</li>
<li>Array 类定义了一组用于操作数组的丰富方法，应该确保熟悉 Array API。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 8 章 函数]]></title>
    <link href="2019919.xyz/16106664265983.html"/>
    <updated>2021-01-15T07:20:26+08:00</updated>
    <id>2019919.xyz/16106664265983.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">8.1 函数定义</a>
<ul>
<li>
<a href="#toc_1">8.1.1 函数声明</a>
</li>
<li>
<a href="#toc_2">8.1.2 函数表达式</a>
</li>
<li>
<a href="#toc_3">8.1.3 箭头函数</a>
</li>
<li>
<a href="#toc_4">8.1.4 嵌套函数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">8.2 函数调用</a>
<ul>
<li>
<a href="#toc_6">8.2.1 函数调用</a>
<ul>
<li>
<a href="#toc_7">条件调用</a>
</li>
<li>
<a href="#toc_8">递归函数和栈</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">8.2.2 方法调用</a>
<ul>
<li>
<a href="#toc_10">方法链</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">8.2.3 构造函数调用</a>
</li>
<li>
<a href="#toc_12">8.2.4 间接调用</a>
</li>
<li>
<a href="#toc_13">8.2.5 函数隐式调用</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">8.3 函数的实参和形参</a>
<ul>
<li>
<a href="#toc_15">8.3.1 可选形参和默认值</a>
</li>
<li>
<a href="#toc_16">8.3.2 剩余参数和可变长实参列表</a>
</li>
<li>
<a href="#toc_17">8.3.3 实参对象</a>
</li>
<li>
<a href="#toc_18">8.3.4 函数调用时的展开运算符</a>
</li>
<li>
<a href="#toc_19">8.3.5 实参解构到形参中</a>
</li>
<li>
<a href="#toc_20">8.3.6 实参类型</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">8.4 函数作为值</a>
<ul>
<li>
<a href="#toc_22">8.4.1 自定义函数属性</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">8.5 函数作为命名空间</a>
</li>
<li>
<a href="#toc_24">8.6 闭包</a>
</li>
<li>
<a href="#toc_25">8.7 函数属性、方法、和构造函数</a>
<ul>
<li>
<a href="#toc_26">8.7.1 length 属性</a>
</li>
<li>
<a href="#toc_27">8.7.2 name 属性</a>
</li>
<li>
<a href="#toc_28">8.7.3 prototype 属性</a>
</li>
<li>
<a href="#toc_29">8.7.4 call() 和 apply() 方法</a>
</li>
<li>
<a href="#toc_30">8.7.5 bind() 方法</a>
</li>
<li>
<a href="#toc_31">8.7.6 toString() 方法</a>
</li>
<li>
<a href="#toc_32">8.7.7 Function() 构造函数</a>
</li>
</ul>
</li>
<li>
<a href="#toc_33">8.8 函数式编程</a>
<ul>
<li>
<a href="#toc_34">8.8.1 用函数处理数组</a>
</li>
<li>
<a href="#toc_35">8.8.2 高阶函数</a>
</li>
<li>
<a href="#toc_36">8.8.3 局部应用函数</a>
</li>
<li>
<a href="#toc_37">8.8.4 记忆（Memoization）</a>
</li>
</ul>
</li>
<li>
<a href="#toc_38">8.9 总结</a>
</li>
</ul>


<p>本章介绍了 JavaScript 函数。函数是 JavaScript 程序的基本构建块，也是几乎所有编程语言的共同特性。你可能已经了解函数的概念，如子例程或过程。</p>

<p>函数是一个 JavaScript 代码块，只定义一次，但可以执行或调用任意次数。JavaScript 函数是参数化的：一个函数定义可以包含一个标识符列表，称为参数，作为函数体的局部变量。函数调用为函数的参数提供值或实参。函数通常使用它们的实参值来计算一个返回值，该返回值成为函数调用表达式的值。除了参数之外，每次调用都有另一个值——调用上下文——即 this 关键字的值。</p>

<p>如果函数挂载在一个对象上作为其属性，它就被称为方法。当该方法在对象中被调用或通过对象调用时，该对象就是该方法函数的调用上下文或 this 值。用于初始化新创建的对象的函数称为构造函数。构造函数在 §6.2 中有介绍，我们将在第9章中再次谈到它。</p>

<p>在 JavaScript 中，函数是对象，它们可以被程序操作。例如，JavaScript 可以将函数赋给变量，并将它们传递给其他函数。由于函数是对象，所以您可以给它们设置属性，甚至调用它们的方法。</p>

<p>JavaScript 函数可以嵌套在其他函数中定义，并且它们可以访问定义它们所处的作用域内任何变量。这意味着 JavaScript 函数是闭包，支持闭包是非常重要的，它是非常强大的编程技巧。</p>

<h2 id="toc_0">8.1 函数定义</h2>

<p>定义 JavaScript 函数最直接的方法是使用 function 关键字，它既可以用作声明又可以用作表达式。ES6 定义了一种不使用 function 关键字的重要新方法来定义的函数：“箭头函数”，它具有特别简洁语法，并且在将一个函数作为参数传递给另一个函数的场景中非常实用。接下来的小节将介绍这三种定义函数的方法。注意，关于函数定义语法包含的函数参数相关内容将在 §8.3 中介绍。</p>

<p>在对象字面量和类定义中，有一种方便的快捷语法来定义方法。这种简写语法在 §6.10.5 中有介绍，相当于通过对象字面量语法将函数定义表达式用最基本的属性名：属性值的方式赋值给对象的属性。在另一种特殊情况下，可以在对象字面量中使用关键字 get 和 set 来定义特殊的属性 getter 和 setter 方法。这个函数定义语法在 §6.10.6 中介绍过。</p>

<p>注意，函数也可以用 Function() 构造函数来定义，这是 §8.7.7 的主题。此外，JavaScript 还定义了一些特殊类型的函数。function* 定义函数生成器（见第12章）和 async function 定义异步函数（见第13章）。</p>

<h3 id="toc_1">8.1.1 函数声明</h3>

<p>函数声明由 function 关键字组成，后面跟着这些组件:</p>

<ul>
<li>函数名称标识符。名称是函数声明的必要部分:它用作变量的名称，并将新定义的函数对象赋值给该变量。</li>
<li>一对圆括号，其中包含由0个或者多个用逗号分隔的标识符组成的列表。这些标识符是函数的参数名，它们的行为类似于函数体中的局部变量。</li>
<li>一对花括号，其中包含由0条或者多条 JavaScript 语句。这些语句构成了函数体：每当函数调用时，就会执行这些语句。</li>
</ul>

<p>下面是一些函数声明的例子:</p>

<pre><code class="language-javascript">// Print the name and value of each property of o.  Return undefined.
function printprops(o) {
    for(let p in o) {
        console.log(`${p}: ${o[p]}\n`);
    }
}

// Compute the distance between Cartesian points (x1,y1) and (x2,y2).
function distance(x1, y1, x2, y2) {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return Math.sqrt(dx*dx + dy*dy);
}

// A recursive function (one that calls itself) that computes factorials
// Recall that x! is the product of x and all positive integers less than it.
function factorial(x) {
    if (x &lt;= 1) return 1;
    return x * factorial(x-1);
}
</code></pre>

<p>重中之重要理解函数声明是函数名变成一个变量，这个变量的值是函数本身。函数声明语句“被提前”到脚本、函数、块之前，因此这种方式定义的函数可以在它定义之前被调用。另一种说法是所有声明在 Javascript 代码块中的函数，在块内始终是有定义的，它们定义在 JavaScript 解释器开始解释执行块内任何语句之前。</p>

<p>distance() 和 factorial() 函数计算一个值，它们用 retrun 来将这个值返回给调用者。return 语句导致函数停止执行，并返回它的表达式的值（如果有的话）给调用者。如果 return 语句没有一个与之相关的表达式，则函数返回 undefined 值。</p>

<p>printprops() 函数不同：它负责输出对象属性的名称和值。没有返回值的必要，并且该函数也不包含一个 return 语句。 调用 printprops() 函数的返回值永远是 undefined。如果一个函数不包含一个 return 语句，它仅仅执行函数体内每一条语句直到结束，并返回 undefined 给调用者。</p>

<p>在 ES6 之前，函数只允许在 JavaScript 文件顶层或者其他函数中声明。然而一些实现违反规约，在循环体条件体或者其他块中定义函数。在 ES6 的严格模式下，函数允许在块内进行声明。一个定义在块内的函数只存在于该块内，块外是不可见的。</p>

<h3 id="toc_2">8.1.2 函数表达式</h3>

<p>函数表达式看起来很像函数声明，但是它出现在一个它的上层表达式或语句的上下文中，并且函数名称是可选项。</p>

<p>下面是一些函数表达式的例子：</p>

<pre><code class="language-javascript">// This function expression defines a function that squares its argument.
// Note that we assign it to a variable
const square = function(x) { return x*x; };

// Function expressions can include names, which is useful for recursion.
const f = function fact(x) { if (x &lt;= 1) return 1; else return x*fact(x-1); };

// Function expressions can also be used as arguments to other functions:
[3,2,1].sort(function(a,b) { return a-b; });

// Function expressions are sometimes defined and immediately invoked:
let tensquared = (function(x) {return x*x;}(10));
</code></pre>

<p>注意函数名称在函数表达式中是可选项，在大部分函数表达式中我们省略了它。函数声明实际上声明了一个变量并且将函数对象赋值给它。按照这个角度来看，函数表达式没有声明一个变量：可以根据它是否会多次调用由你自己决定是将新定义的函数对象赋值给一个常量还是变量。用 const 定义函数表达式是一个非常好的做法，你不会因为意外赋值而重写了你的函数。</p>

<p>可以给函数一个名称，就像 factorial 函数，它需要调用它自己。如果一个函数表达式包含一个名称，那这个函数的局部函数作用域内会包含一个属性名为该函数名的对象，其值绑定的是该函数。实际上，函数名变成这个函数的一个局部变量。大多数函数表达式不需要函数名称，这让它们的定义更简洁（但是并没有下面要讲的箭头函数简洁）。</p>

<p>在函数声明和函数表达式之间有一个非常重要的不同。当你用函数声明，该函数对象创建于该函数所在作用域的代码开始执行之前，也就是声明提前，所以你可以在函数定义之前调用他们。如果用函数表达式来定义一个函数，这样使用就是不对的：该函数不会存在，直到函数定义表达式真正被计算。因为，想要执行一个函数，你必须可以引用它，而一个函数表达式定义的函数一直到该函数赋值给一个变量后才能被引用，所以要使用函数表达式需要在函数被调用之前定义。</p>

<h3 id="toc_3">8.1.3 箭头函数</h3>

<p>在 ES6 之后，你可以用一个特别简洁的语法来定义函数，被称为“箭头函数”。这个语法联想到数学符号，用一个 =&gt; &quot;箭头&quot;来分隔函数的参数和函数体。function 关键字未使用，并且，由于箭头函数是表达式而不是声明语句，也不需要一个函数名称。一般箭头函数用圆括号包含一个逗号分隔的参数列表，接一个 =&gt; 箭头，后面是花括号包含的函数体。</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; { return x + y; };
</code></pre>

<p>但是箭头函数支持更加简洁的语法。如果函数体只有一个简单的 return 语句，你可以省略 return 关键字，分号和花括号都一起省略，将函数体写成一个计算返回值的表达式。</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; x + y;
</code></pre>

<p>而且，如果一个箭头函数只有一个参数，你可以省略参数列表的圆括号。</p>

<pre><code class="language-javascript">const polynomial = x =&gt; x*x + 2*x + 3;
</code></pre>

<p>注意，如果箭头函数没有参数，必须写一对空圆括号。</p>

<pre><code class="language-javascript">const constantFunc = () =&gt; 42;
</code></pre>

<p>注意，当写一个箭头函数时，函数参数和箭头之间不能换行。否则，可能会直接在赋值后中止，就像 <code>const polynomial = x</code>，因为它本身是一个语法上合法的赋值语句。</p>

<p>此外，如果箭头函数体是一个单一的 return 语句，而且他返回的是一个对象字面量，那必须将对象字面量用圆括号包起来，避免将对象字面量的大括号误解成函数体的大括号。</p>

<pre><code class="language-javascript">const f = x =&gt; { return { value: x }; };  // Good: f() returns an object
const g = x =&gt; ({ value: x });            // Good: g() returns an object
const h = x =&gt; { value: x };              // Bad: h() returns nothing
const i = x =&gt; { v: x, w: x };            // Bad: Syntax Error
</code></pre>

<p>这段代码的第三行，函数 h() 就有歧义：这段代码原本返回对象字面量被转化为一个标签语句，所以一个返回 undefined 的函数被创建。第四行，结构更复杂的对象字面量不是一个合法的语句，这段代码会抛出一个语法异常。</p>

<p>简洁的箭头函数可以完美的传递一个函数给另外一个函数，比如一些数组的常规操作方法 map()，filter() 和 reduce()（见 §7.8.1），例如：</p>

<pre><code class="language-javascript">// Make a copy of an array with null elements removed.
let filtered = [1,null,2,3].filter(x =&gt; x !== null); // filtered == [1,2,3]
// Square some numbers:
let squares = [1,2,3,4].map(x =&gt; x*x);               // squares == [1,4,9,16]
</code></pre>

<p>箭头函数不同于用关键字定义的函数：箭头函数从定义它们的环境继承 this 关键字，而不是像其他定义方式那样定义自己的调用上下文。这是箭头函数一个重要且特别实用的特性，我们会在这一章的后面再次提到它。箭头函数也不同于其他函数，它们没有有原型属性。这意味着它不能被当作一个构造函数去创建一个类（见 §9.2）。</p>

<h3 id="toc_4">8.1.4 嵌套函数</h3>

<p>在 JavaScript 中，函数可以嵌套在其他函数内。例如：</p>

<pre><code class="language-javascript">function hypotenuse(a, b) {
    function square(x) { return x*x; }
    return Math.sqrt(square(a) + square(b));
}
</code></pre>

<p>嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。例如，在上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b。这些作用域规则对嵌套函数非常重要，我们会在 §8.6 再深入了解它们。</p>

<h2 id="toc_5">8.2 函数调用</h2>

<p>构成函数主体的 JavaScript 代码在定义之时并不会执行，只有调用该函数时，它们才会执行。JavaScript 函数可以以五种方式被调用。</p>

<ul>
<li>作为函数</li>
<li>作为方法</li>
<li>作为构造函数</li>
<li>通过它们的 call() 和 apply() 方法间接调用</li>
<li>隐式调用，不同于普通函数调，通过 JavaScript 语言特性调用函数。</li>
</ul>

<h3 id="toc_6">8.2.1 函数调用</h3>

<p>函数或方法通过调用表达式（§4.5）被调用。调用表达式由以下部分组成，计算函数对象的函数表达式，一个开放圆括号，逗号分隔的零个或多个实参表达式列表，一个闭合圆括号。如果函数表达式是属性访问表达式（函数是一个对象的属性或者一个数组的元素）那么它是一个方法调用表达式。这种情况会通过下面的例子说明，接下来这个代码包含了一些常规的函数调用表达式：</p>

<pre><code class="language-javascript">printprops({x: 1});
let total = distance(0,0,2,1) + distance(2,1,3,5);
let probability = factorial(5)/factorial(13);
</code></pre>

<p>在调用中，每个实参表达式（圆括号内的）执行计算，返回值作为函数的实参。这些值传给函数定义的参数。在函数体内，参数的引用指向对应实参的值。</p>

<p>对于常规的函数调用，函数返回值变成函数调用表达式的值。如果因解释器执行到函数结尾而返回，返回值就是 undefined。如果函数返回是因为解释器执行一个 return 语句，那么返回值是 return 后面的表达式的计算结果，如果 return 语句没有值也返回 undefined。</p>

<h4 id="toc_7">条件调用</h4>

<p>在 ES2020 中你可以通过在函数表达式和圆括号之间插入 ?. 符号，使函数只有在不为 null 和 undefined 时候再调用。表达式 f?.(x) 等价（假设没有副作用）于：</p>

<pre><code class="language-javascript">(f !== null &amp;&amp; f !== undefined) ? f(x) : undefined
</code></pre>

<p>详细的条件执行语法描述在 §4.5.1。</p>

<p>函数调用在非严格模式下，调用上下文（ this ）是全局对象。然而在严格模式下，调用上下文是 undefined。注意箭头语法定义的函数行为是不同的：实际上它们总是继承它们定义位置的 this 值。</p>

<p>以函数形式调用的函数通常不使用 this 关键字。不过，this 关键字可以用来判断当前是否是严格模式。</p>

<pre><code class="language-javascript">// Define and invoke a function to determine if we&#39;re in strict mode.
const strict = (function() { return !this; }());
</code></pre>

<h4 id="toc_8">递归函数和栈</h4>

<p>递归函数就像本章开始的 factorial() 函数，它调用它自己。某些算法（如涉及基于树的数据结构）可以使用递归函数特别优雅地实现。在写递归函数时，考虑内存分配是很重要的。当函数 A 调用函数 B，然后函数 B 又调用函数 C 时，Javascript 编译器需要知道在哪里重新执行函数 B，当函数 B 执行完成后它需要知道在哪里执行函数 A。你可以将执行上下文想象成一个栈。当一个函数调用另外一个函数时，一个新的执行上下文被压入栈中。当被调用函数返回，它的执行上下文对象从栈中弹出。如果一个函数递归调用100次，那么会有100个对象被压入栈中，然后这100个对象再依次从栈中弹出。这种调用非常耗内存。以现代的硬件递归调用100次通常没什么问题。但是如果一个函数递归上千次，它可能会失败并报错“Maximum call-stack size exceeded.”。</p>

<h3 id="toc_9">8.2.2 方法调用</h3>

<p>方法只不过是对象属性函数。如果有一个函数 f 和一个对象 o，可以用下面的代码给对象 o 定义一个名为 m 的方法：</p>

<pre><code class="language-javascript">o.m = f;
</code></pre>

<p>给对象 o 定义了方法 m()，用这种方式调用它：</p>

<pre><code class="language-javascript">o.m();
</code></pre>

<p>或者 m() 需要两个实参，可以这样调用它：</p>

<pre><code class="language-javascript">o.m(x, y);
</code></pre>

<p>例子中的代码是一个调用表达式：它包含一个函数表达式 o.m 和两个实参表达式 x 和 y。函数表达式本身是一个属性访问表达式，这意味着该函数被当作一个方法调用，而不是一个普通的函数。</p>

<p>对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即：调用上下文。属性访问表达式由两部分组成：一个对象（本例中的 o）和属性名称（m）。在像这样的方法调用表达式里，对象 o 成为调用上下文，函数体可以使用关键字this引用该对象。下面是一个具体的例子：</p>

<pre><code class="language-javascript">let calculator = { // An object literal
    operand1: 1,
    operand2: 1,
    add() {        // We&#39;re using method shorthand syntax for this function
        // Note the use of the this keyword to refer to the containing object.
        this.result = this.operand1 + this.operand2;
    }
};
calculator.add();  // A method invocation to compute 1+1.
calculator.result  // =&gt; 2
</code></pre>

<p>大多数方法调用使用点符号来访问属性，使用方括号（属性访问表达式）也可以进行属性访问操作。下面两个例子都是函数调用：</p>

<pre><code class="language-javascript">o[&quot;m&quot;](x,y);   // Another way to write o.m(x,y).
a[0](z)        // Also a method invocation (assuming a[0] is a function).
</code></pre>

<p>方法调用可能包括更复杂的属性访问表达式：</p>

<pre><code class="language-javascript">customer.surname.toUpperCase(); // Invoke method on customer.surname
f().m();                        // Invoke method m() on return value of f()
</code></pre>

<p>方法和 this 关键字是面向对象编程范式的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参对象，就是调用这个方法对象本身。通常来讲，方法执行就是对象的某种操作，方法调用的语法也清晰的表达了它是操作对象的函数，比较下面两行代码：</p>

<pre><code class="language-javascript">rect.setSize(width, height);
setRectSize(rect, width, height);
</code></pre>

<p>我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象 rect。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是 rect 对象，函数中的所有操作都将基于这个对象。</p>

<h4 id="toc_10">方法链</h4>

<p>当方法返回一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（或“链”）每次的调用结果都是另外一个表达式的组成部分。比如，基于 Promise 的异步操作（参见第13章），我们常常会这样写代码：</p>

<pre><code class="language-javascript">// Run three asynchronous operations in sequence, handling errors.
doStepOne().then(doStepTwo).then(doStepThree).catch(handleErrors);
</code></pre>

<p>当方法并不需要返回值时，最好直接返回 this。如果在设计的 API 中一直采用这种方式，使用 API 就可以用方法链 <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 风格的编程，在这种编程风格中，只要指定一次要调用的对象即可，余下的方法都可以基于此进行调用：</p>

<pre><code class="language-javascript">new Square().x(100).y(100).size(50).outline(&quot;red&quot;).fill(&quot;blue&quot;).draw();
</code></pre>

<p>需要注意的是，this 是一个关键字，不是变量，也不是属性名。JavaScript 的语法不允许给 this 赋值。</p>

<p>关键字 this 没有变量作用域的限制，除了箭头函数，嵌套函数不会从包含它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套的函数作为函数调用（不包含箭头函数），其 this 值不是全局对象（非严格模式下）就是undefined（严格模式下）。很多人误以为在一个方法中的函数声明并以函数调用的方式去执行可以用 this 来获取方法的执行上下文。下面这个例子说明了这个问题：</p>

<pre><code class="language-javascript">let o = {                 // An object o.
    m: function() {       // Method m of the object.
        let self = this;  // Save the &quot;this&quot; value in a variable.
        this === o        // =&gt; true: &quot;this&quot; is the object o.
        f();              // Now call the helper function f().

        function f() {    // A nested function f
            this === o    // =&gt; false: &quot;this&quot; is global or undefined
            self === o    // =&gt; true: self is the outer &quot;this&quot; value.
        }
    }
};
o.m();                    // Invoke the method m on the object o.
</code></pre>

<p>嵌套函数 f() 中，this 关键之不等于对象 o。这被广泛的认为是 JavaScript 的一个缺陷，了解这一点是很是很重要的。上面的代码演示了一种常用的解决方案。在方法 m 中，将 this 值赋值给一个变量 self，在签到函数 f 中，可以用 self 代替 this 来引用包含它的对象。</p>

<p>在 ES6 之后，有另外一种解决方案来解决这个问题，将嵌套函数 f 转换成箭头函数，它会正确的继承 this 值：</p>

<pre><code class="language-javascript">const f = () =&gt; {
    this === o  // true, since arrow functions inherit this
};
</code></pre>

<p>函数表达式不像函数声明，声明提前，所以为了让这种解决方案定义的函数可以被调用，需要将 f 函数定义表达式放在方法 m 中，这样它才可以在它被调用时存在。</p>

<p>另外还可以用嵌套函数的 bind() 方法，在指定对象上隐式调用一个新的函数：</p>

<pre><code class="language-javascript">const f = (function() {
    this === o  // true, since we bound this function to the outer this
}).bind(this);
</code></pre>

<p>关于 bind() 方法将在 §8.7.5 中讲解。</p>

<h3 id="toc_11">8.2.3 构造函数调用</h3>

<p>如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用（构造函数调用在 §4.6 和 §6.2.2 节有简单介绍，第9章会对构造函数做更详细的讨论）。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。</p>

<p>如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，JavaScript 构造函数调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号，比如，下面这两行代码就是等价的：</p>

<pre><code class="language-javascript">o = new Object();
o = new Object;
</code></pre>

<p>构造函数调用创建一个新的空对象，这个对象继承自构造函数的 prototype 属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数内可以使用 this 关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式 new o.m() 中，调用上下文并不是 o。</p>

<p>构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会隐式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p>

<h3 id="toc_12">8.2.4 间接调用</h3>

<p>JavaScript 中的函数也是对象，和其他 JavaScript 对象没什么两样，函数对象也可以包含方法。其中的两个方法 call() 和 apply() 可以用来间接地调用函数。两个方法都允许显式指定调用所需的 this 值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。call() 方法使用它自有的实参列表作为函数的实参，apply() 方法则要求以数组的形式传入实参。§8.7.4 节会有关于 call() 和apply () 方法的详细讨论。</p>

<h3 id="toc_13">8.2.5 函数隐式调用</h3>

<p>有各种各样的 JavaScript 语言特性，它们看起来不像函数调用但是却能调用函数。额外小心编写函数时可能会隐式调用，因为在隐式函数调用中 bug、副作用和性能问题都比普通的函数更难诊断和修复。</p>

<p>可能引起函数隐式调用的语言特性包括：</p>

<p>如果一个对象定义了 getter 或者 setter 方法，获取或者设置它的属性值可能调用这些方法。见 §6.10.6 有更多相关描述。</p>

<p>当对象用作一个字符串文本时（例如对象和一个字符串连接），它的 toString() 方法会被调用。同样的，对象用作一个数值型文本时，它的 valueOf() 方法被调用。详见 §3.9.3。</p>

<p>当循环可迭代对象的元素时会产生很多方法调用。第12章介绍了迭代器在函数调用级别如何工作，并演示如何编写方法来定义自己的可迭代类型。</p>

<p>可以伪装在模板字面量中 。在 §14.5 中演示如何在模板字符串中调用函数。</p>

<p>Proxy 对象（在 §14.7 中描述）的行为完全由函数控制。它的任何一个操作都会导致函数调用。</p>

<h2 id="toc_14">8.3 函数的实参和形参</h2>

<p>JavaScript 中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JavaScript 函数调用甚至不检查传入形参的个数。下面几节将会讨论当调用函数时的实参个数和声明的形参个数不匹配时出现的状况，同样介绍了如何显式测试函数实参的类型，以避免非法的实参传入函数。</p>

<h3 id="toc_15">8.3.1 可选形参和默认值</h3>

<p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。所以一些参数设置成可选的是非常实用的。看下面这个例子：</p>

<pre><code class="language-javascript">// Append the names of the enumerable properties of object o to the
// array a, and return a.  If a is omitted, create and return a new array.
function getPropertyNames(o, a) {
    if (a === undefined) a = [];  // If undefined, use a new array
    for(let property in o) a.push(property);
    return a;
}

// getPropertyNames() can be invoked with one or two arguments:
let o = {x: 1}, p = {y: 2, z: 3};  // Two objects for testing
let a = getPropertyNames(o); // a == [&quot;x&quot;]; get o&#39;s properties in a new array
getPropertyNames(p, a);      // a == [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; add p&#39;s properties to it
</code></pre>

<p>第一行代码中可以使用 || 运算符来代替一个 if 语句，这是一种习惯用法：</p>

<pre><code class="language-javascript">a = a || [];
</code></pre>

<p>回忆一下，§4.10.2 介绍了“||”运算符，如果第一个实参是真值的话就返回第一个实参；否则返回第二个实参。在这个场景下，如果作为第二个实参传入任意对象，那么函数就会使用这个对象。如果省略掉第二个实参（或者传递 null 以及其他任何假值），那么就新创建一个空数组，并赋值给 a。</p>

<p>需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参，他们必须显地的将 undefined 传入作为第一个实参 。</p>

<p>在 ES6 之后，可以直接在函数的参数列表中为每个函数参数定义默认值。直接在参数名后面接一个等号再接一个默认值（用于没有实参提供给参数时参数的值）：</p>

<pre><code class="language-javascript">// Append the names of the enumerable properties of object o to the
// array a, and return a.  If a is omitted, create and return a new array.
function getPropertyNames(o, a = []) {
    for(let property in o) a.push(property);
    return a;
}
</code></pre>

<p>默认参数表达式只有在函数调用时进行计算，而不是在它定义时，所以每一次 getPropertyNames() 函数只传一个实参调用时，一个新的空数组被创建并传给参数。<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> 最容易理解的就是参数默认值是常量（或者字面量表达式 [] 和 {}）。但这并不是必须的：举个例子，你可以用变量或者函数调用，计算一个默认参数的值。一个很有趣的情况是，对于有多个参数的函数，可以用前面的参数值来定义后面的参数默认值。</p>

<pre><code class="language-javascript">// This function returns an object representing a rectangle&#39;s dimensions.
// If only width is supplied, make it twice as high as it is wide.
const rectangle = (width, height=width*2) =&gt; ({width, height});
rectangle(1)  // =&gt; { width: 1, height: 2 }
</code></pre>

<p>这段代码描述了箭头函数中的参数默认值。方法函数和其他形式的函数定义也是如此。</p>

<h3 id="toc_16">8.3.2 剩余参数和可变长实参列表</h3>

<p>调用函数时允许传入的实参比函数声明时指定的形参个数少。剩余参数允许相反的情况：它允许我们在调用函数时，传入比型参多任意个数的实参。下面是一个可以传入一个或多个数值型实参的例子，并且返回其中最大的数：</p>

<pre><code class="language-javascript">function max(first=-Infinity, ...rest) {
    let maxValue = first; // Start by assuming the first arg is biggest
    // Then loop through the rest of the arguments, looking for bigger
    for(let n of rest) {
        if (n &gt; maxValue) {
            maxValue = n;
        }
    }
    // Return the biggest
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6)  // =&gt; 1000
</code></pre>

<p>剩余参数由三个 . 开始，必须是函数声明的最后一个参数。调用有剩余参数的函数时，传递的实参先赋值给非剩余参数，然后其余所有的实参（也就是“剩余”实参）存储在一个数组中变成剩余参数的值，最后一点非常重要：在一个函数体中，剩余参数的值总是一个数组。这个数组可能是空的，但是剩余参数永远不会是 undefined。（因此，从不会给剩余参数设置默认值，并且这也是不合法的。）</p>

<p>类似这种函数可以接收任意个数的实参，这种函数也称为“不定实参函数”，这个术语源自古老的C语言。</p>

<p>不要混淆 ... 定义函数的剩余参数和 ... 展开运算符，将在 §8.3.4 描述展开运算符在函数调用中的应用。</p>

<h3 id="toc_17">8.3.3 实参对象</h3>

<p>剩余参数是在 ES6 中加入的概念。在这之前，不定实参函数是用 Arguments 对象实现的：在函数体中，标识符 Arguments 是指向实参对象的引用。Arguments 对象是一个类数组对象（参照 §7.9），这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。下面的 max() 函数就是以前用 Arguments 对象代替剩余参数的例子：</p>

<pre><code class="language-javascript">function max(x) {
    let maxValue = -Infinity;
    // Loop through the arguments, looking for, and remembering, the biggest.
    for(let i = 0; i &lt; arguments.length; i++) {
        if (arguments[i] &gt; maxValue) maxValue = arguments[i];
    }
    // Return the biggest
    return maxValue;
}

max(1, 10, 100, 2, 3, 1000, 4, 5, 6)  // =&gt; 1000
</code></pre>

<p>Arguments 对象可追溯到 JavaScript 的最早时代，并带有一些奇怪的历史包袱，这使得它效率低下且难以优化，尤其是不在严格模式下。可能还会遇到一些代码使用 Arguments 对象，但是在编写新代码时要避免使用，可以用 ... 剩余函数来替代。Arguments 对象还有部分令人遗憾的遗产，在严格模式下，arguments 被视为保留字，不能声明具有该名称的局部变量来定义函数的参数。</p>

<h3 id="toc_18">8.3.4 函数调用时的展开运算符</h3>

<p>当需要单个值时，... 展开运算符用来拆包，或者说将元素从数组（或者其他的任何和迭代对象，例如字符串）中“展开”到上下文。我们已经在 §7.1.2 见到了展开运算符在数组字面量上的使用。展开运算符可以在函数调用中以同样方式使用：</p>

<pre><code class="language-javascript">let numbers = [5, 2, 10, -1, 9, 100, 1];
Math.min(...numbers)  // =&gt; -1
</code></pre>

<p>注意 ... 不是一个真正的运算符，因为它不能通过计算来提供一个值。它是一个可以用在数组字面量和函数调用中的特殊的 JavaScript 语法。</p>

<p>在函数定义和函数调用中使用相同的 ... 语法时，和展开运算符有着相仿的效果。在 §8.3.2 中我们看到函数定义使用 ... 将复数个函数实参合并到一个数组中。剩余参数和展开运算符经常一同使用，就像下面这个函数：</p>

<pre><code class="language-javascript">// This function takes a function and returns a wrapped version
function timed(f) {
    return function(...args) {  // Collect args into a rest parameter array
        console.log(`Entering function ${f.name}`);
        let startTime = Date.now();
        try {
            // Pass all of our arguments to the wrapped function
            return f(...args);  // Spread the args back out again
        }
        finally {
            // Before we return the wrapped return value, print elapsed time.
            console.log(`Exiting ${f.name} after ${Date.now()-startTime}ms`);
        }
    };
}

// Compute the sum of the numbers between 1 and n by brute force
function benchmark(n) {
    let sum = 0;
    for(let i = 1; i &lt;= n; i++) sum += i;
    return sum;
}

// Now invoke the timed version of that test function
timed(benchmark)(1000000) // =&gt; 500000500000; this is the sum of the numbers
</code></pre>

<h3 id="toc_19">8.3.5 实参解构到形参中</h3>

<p>用实参列表调用函数时，实参的值最终赋值给函数定义的参数。函数调用初始化阶段非常像变量赋值。所以我们不必惊讶于可以将解构赋值（见 §3.10.3）用于函数。</p>

<p>如果一个函数的参数带有方括号，就说明函数要给每一个方括号传一个数组。在一个调用进程中，数组实参会被拆包传递给对应的参数。例如，假设我们将 2D 矢量表示为两个数字的数组，其中第一个元素是 X 坐标，第二个元素是 Y 坐标。用这个简单的数据结构，编写下面这个函数计算两个矢量的和：</p>

<pre><code class="language-javascript">function vectorAdd(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
}
vectorAdd([1,2], [3,4])  // =&gt; [4,6]
</code></pre>

<p>如果下面这种方式解构这两个矢量实参，这段代码将更容易理解：</p>

<pre><code class="language-javascript">function vectorAdd([x1,y1], [x2,y2]) { // Unpack 2 arguments into 4 parameters
    return [x1 + x2, y1 + y2];
}
vectorAdd([1,2], [3,4])  // =&gt; [4,6]
</code></pre>

<p>同样，如果定义一个函数时需要对象实参，你能对这个对象进行参数解构。再次实用矢量的例子，这一次，我们用 x 和 y 参数包装成对象来描述矢量：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} by a scalar value
function vectorMultiply({x, y}, scalar) {
    return { x: x*scalar, y: y*scalar };
}
vectorMultiply({x: 1, y: 2}, 2)  // =&gt; {x: 2, y: 4}
</code></pre>

<p>这个例子将一个简单的对象实参解构成两个参数是很简单的，因为参数的名字和我们在对象中使用的属性名是匹配的。当您需要将同一个名称的属性解构为具有不同名称的参数时，语法更加冗长和难懂。下面是一个矢量加法的例子，基于对象矢量的实现：</p>

<pre><code class="language-javascript">function vectorAdd(
    {x: x1, y: y1}, // Unpack 1st object into x1 and y1 params
    {x: x2, y: y2}  // Unpack 2nd object into x2 and y2 params
)
{
    return { x: x1 + x2, y: y1 + y2 };
}
vectorAdd({x: 1, y: 2}, {x: 3, y: 4})  // =&gt; {x: 4, y: 6}
</code></pre>

<p>像 {x:x1, y:y1} 的解构语法棘手的是记住哪一个是属性名哪一个是参数名。牢记解构赋值和解构函数调用的规则，声明的变量或参数在对象字面量中的位置固定。属性名总是在冒号的左边，参数（或变量）名在右边。</p>

<p>可以使用解构参数定义参数默认值。下面是适用于 2D 或 3D 矢量的矢量乘法：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} or {x,y,z} by a scalar value
function vectorMultiply({x, y, z=0}, scalar) {
    return { x: x*scalar, y: y*scalar, z: z*scalar };
}
vectorMultiply({x: 1, y: 2}, 2)  // =&gt; {x: 2, y: 4, z: 0}
</code></pre>

<p>一些语言（像 Python）允许函数的调用者以 <code>name=value</code> 型式指定实参，这在有很多可选实参或者参数列表长到难以记住正确的顺序时是非常方便的。JavaScript 不允许直接这样做，但可以通过解构对象实参到函数参数中。构思一个函数将指定数量的元素从一个数组复制到另一个数组中，可以随意地为每个数组指定起始偏移量。如下有五个可传入参数，其中一些有默认值，并且调用者很难记住参数的顺序来传递实参，可以像这样定义和调用 arraycopy() 方法：</p>

<pre><code class="language-javascript">function arraycopy({from, to=from, n=from.length, fromIndex=0, toIndex=0}) {
    let valuesToCopy = from.slice(fromIndex, fromIndex + n);
    to.splice(toIndex, 0, ...valuesToCopy);
    return to;
}
let a = [1,2,3,4,5], b = [9,8,7,6,5];
arraycopy({from: a, n: 3, to: b, toIndex: 4}) // =&gt; [9,8,7,6,1,2,3,5]
</code></pre>

<p>当解构一个数组，在其被拆包时，可以定义一个剩余参数将其余值放在数组中。 在方括号中的剩余参数和真正的函数中的剩余参数是完全不同的：</p>

<pre><code class="language-javascript">// This function expects an array argument. The first two elements of that
// array are unpacked into the x and y parameters. Any remaining elements
// are stored in the coords array. And any arguments after the first array
// are packed into the rest array.
function f([x, y, ...coords], ...rest) {
    return [x+y, ...rest, ...coords];  // Note: spread operator here
}
f([1, 2, 3, 4], 5, 6)   // =&gt; [3, 5, 6, 3, 4]
</code></pre>

<p>在 ES2018，也可以用剩余参数解构对象。剩余参数是一个没有解构的属性的对象。对象剩余参数经常与对象展开运算符连用，这是 ES2018 的新特性：</p>

<pre><code class="language-javascript">// Multiply the vector {x,y} or {x,y,z} by a scalar value, retain other props
function vectorMultiply({x, y, z=0, ...props}, scalar) {
    return { x: x*scalar, y: y*scalar, z: z*scalar, ...props };
}
vectorMultiply({x: 1, y: 2, w: -1}, 2)  // =&gt; {x: 2, y: 4, z: 0, w: -1}
</code></pre>

<p>最后，请记住，除了可以解构实参对象和数组，也可以解构数组对象，对象有数组属性，并且对象还有对象的属性。构思一个将圆表示为具有 x、y、半径和颜色属性的对象的图形代码，颜色属性是一个数组由 RGB 组成。你可以定义一个函数，该函数希望将单个圆对象传递给它，但其解构为六个单独的参数：</p>

<pre><code class="language-javascript">function drawCircle({x, y, radius, color: [r, g, b]}) {
    // Not yet implemented
}
</code></pre>

<p>如果函数实参解构比这更复杂，代码会变得更难读，而不是更简单。有时，显示地对对象属性访问和数组索引会让代码更清晰。</p>

<h3 id="toc_20">8.3.6 实参类型</h3>

<p>JavaScript 方法的形参并未声明类型，在形参传入函数体之前也未做任何类型检查。可以采用语义化的单词来给函数实参命名，并在函数注释给每一个实参详细描述，以此使代码自文本化。</p>

<p>§3.9 已经提到，JavaScript 在必要时会进行类型转换。因此如果函数期 望接收一个字符串实参，而调用函数时传入其他类型的值，所传入的值会在函数体内将其用做字符串的地方转换为字符串类型。所有的原始类型都可以转换为字符串，所有的对象都包含 toString() 方法（尽管不一定有用），所以这种场景下是不会有任何错误的。</p>

<p>然而事情不总是这样，回头看一下刚才提到的 arraycopy() 方法。这个方法期望获得一个或两个实参，并且这些实参的类型错误会导致函数执行失败。除非所写的私有函数只会被附近的代码调用，你应当添加类似的实参类型检查逻辑。因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错，相比而言，逻辑执行时的报错消息不甚清晰且更难处理。下面这个例子中的函数就做了这种类型检查：</p>

<pre><code class="language-javascript">// Return the sum of the elements an iterable object a.
// The elements of a must all be numbers.
function sum(a) {
    let total = 0;
    for(let element of a) { // Throws TypeError if a is not iterable
        if (typeof element !== &quot;number&quot;) {
            throw new TypeError(&quot;sum(): elements must be numbers&quot;);
        }
        total += element;
    }
    return total;
}
sum([1,2,3])    // =&gt; 6
sum(1, 2, 3);   // !TypeError: 1 is not iterable
sum([1,2,&quot;3&quot;]); // !TypeError: element 2 is not a number
</code></pre>

<h2 id="toc_21">8.4 函数作为值</h2>

<p>函数可以定义，也可以调用，这是函数最重要的特性。函数定义和调用是  JavaScript 的词法特性，对于其他大多数编程语言来说亦是如此。然而在 JavaScript 中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup></p>

<p>To understand how functions can be JavaScript data as well as JavaScript syntax, consider this function definition:</p>

<blockquote>
<p>为了便于理解 JavaScript 中的函数是如何用做 Javascript 数据以及 JavaScript 语法的，来看一下这样一个函数定义：</p>
</blockquote>

<pre><code class="language-javascript">function square(x) { return x*x; }
</code></pre>

<p>这个定义创建一个新的函数对象，并将其赋值给变量 square。函数的名字实际上是无形的，它（square）仅仅是变量的名称，这个变量是函数对象的引用。函数还可以赋值给其他的变量，并且仍可以正常工作：</p>

<pre><code class="language-javascript">let s = square;  // Now s refers to the same function that square does
square(4)        // =&gt; 16
s(4)             // =&gt; 16
</code></pre>

<p>除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性。当函数作为对象的属性调用时，函数就称为“方法”：</p>

<pre><code class="language-javascript">let o = {square: function(x) { return x*x; }}; // An object literal
let y = o.square(16);                          // y == 256
</code></pre>

<p>函数甚至不需要带名字，就像把它们赋值给数组元素：</p>

<pre><code class="language-javascript">let a = [x =&gt; x*x, 20]; // An array literal
a[0](a[1])              // =&gt; 400
</code></pre>

<p>上面的例子看起来很奇怪，但的确是合法的函数调用表达式！</p>

<p>举一个例子来说明将函数当作值来对待的益处，考虑下 Array.sort() 方法。这个方法用来对数组元素进行排序。因为排序的规则有很多（基于数值大小、字母表顺序、日期大小、从小到大、从大到小等），sort() 方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单：对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。这个函数参数使得 Array.sort() 具有更完美的通用性和无限可扩展性，它可以对任何类型的数据进行任意排序。§7.8.6 有示例代码。</p>

<p>例 8-1 展示了将函数用做值时的一些例子，这段代码可能会难读一些，但注释解释了代码的具体含义：</p>

<p>例 8-1：用函数做值</p>

<pre><code class="language-javascript">// We define some simple functions here
function add(x,y) { return x + y; }
function subtract(x,y) { return x - y; }
function multiply(x,y) { return x * y; }
function divide(x,y) { return x / y; }

// Here&#39;s a function that takes one of the preceding functions
// as an argument and invokes it on two operands
function operate(operator, operand1, operand2) {
    return operator(operand1, operand2);
}

// We could invoke this function like this to compute the value (2+3) + (4*5):
let i = operate(add, operate(add, 2, 3), operate(multiply, 4, 5));

// For the sake of the example, we implement the simple functions again,
// this time within an object literal;
const operators = {
    add:      (x,y) =&gt; x+y,
    subtract: (x,y) =&gt; x-y,
    multiply: (x,y) =&gt; x*y,
    divide:   (x,y) =&gt; x/y,
    pow:      Math.pow  // This works for predefined functions too
};

// This function takes the name of an operator, looks up that operator
// in the object, and then invokes it on the supplied operands. Note
// the syntax used to invoke the operator function.
function operate2(operation, operand1, operand2) {
    if (typeof operators[operation] === &quot;function&quot;) {
        return operators[operation](operand1, operand2);
    }
    else throw &quot;unknown operator&quot;;
}

operate2(&quot;add&quot;, &quot;hello&quot;, operate2(&quot;add&quot;, &quot; &quot;, &quot;world&quot;)) // =&gt; &quot;hello world&quot;
operate2(&quot;pow&quot;, 10, 2)  // =&gt; 100
</code></pre>

<h3 id="toc_22">8.4.1 自定义函数属性</h3>

<p>JavaScript 中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。比如，假设你想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，为了做到这一点，函数必须能够跟踪它每次返回的值，而且这些值的信息需要在不同的函数调过程中持久化。可以将这些信息存放到全局变量中，但这并不是必需的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中，下面这个例子就实现了这样一个函数，每次调用函数都会返回一个唯一的整数：</p>

<pre><code class="language-javascript">// Initialize the counter property of the function object.
// Function declarations are hoisted so we really can
// do this assignment before the function declaration.
uniqueInteger.counter = 0;

// This function returns a different integer each time it is called.
// It uses a property of itself to remember the next value to be returned.
function uniqueInteger() {
    return uniqueInteger.counter++;  // Return and increment counter property
}
uniqueInteger()  // =&gt; 0
uniqueInteger()  // =&gt; 1
</code></pre>

<p>来看另外一个例子，下面这个函数 factorial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：</p>

<pre><code class="language-javascript">// Compute factorials and cache results as properties of the function itself.
function factorial(n) {
    if (Number.isInteger(n) &amp;&amp; n &gt; 0) {           // Positive integers only
        if (!(n in factorial)) {                  // If no cached result
            factorial[n] = n * factorial(n-1);    // Compute and cache it
        }
        return factorial[n];                      // Return the cached result
    } else {
        return NaN;                               // If input was bad
    }
}
factorial[1] = 1;  // Initialize the cache to hold this base case.
factorial(6)  // =&gt; 720
factorial[5]  // =&gt; 120; the call above caches this value
</code></pre>

<h2 id="toc_23">8.5 函数作为命名空间</h2>

<p>变量声明在函数内对于函数体外是不可见的。因此，有时定义函数作为临时命名空间非常有用，您可以在其中定义变量而不弄乱全局命名空间。</p>

<p>比如，假设你写了一段 JavaScript 模块代码，这段代码将要用在不同的 JavaScript 程序中（对于客户端 JavaScript 来讲通常是用在各种各样的网页中）。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量：</p>

<pre><code class="language-javascript">function chunkNamespace() {
    // Chunk of code goes here
    // Any variables defined in the chunk are local to this function
    // instead of cluttering up the global namespace.
}
chunkNamespace();  // But don&#39;t forget to invoke the function!
</code></pre>

<p>这段代码仅仅定义了一个单独的全局变量：名为 chunkNamespace 的函数。如果还是太麻烦，可以用一个单独的表达式定义一个匿名函数并调用它：</p>

<pre><code class="language-javascript">(function() {  // chunkNamespace() function rewritten as an unnamed expression.
    // Chunk of code goes here
}());          // End the function literal and invoke it now.
</code></pre>

<p>这种定义匿名函数并立即在单个表达式中调用它的写法非常常见，并给它起了个名字“匿名调用函数表达式”。注意上面代码的圆括号的用法，function 之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript 解释器会试图将关键字 function 解析为函数声明语句。使用圆括号 JavaScript 解释器才会正确地将其解析为函数定义表达式。使用前导括号也有助于人类阅读时区分函数定义是立即执行还是供以后使用。</p>

<p>函数用作命名空间很常用，在命名空间函数中定义一个或多个函数使用其中的变量，然后将他们作为函数命名空间的返回值。这样的函数称为闭包，它们是下一节的主题。</p>

<h2 id="toc_24">8.6 闭包</h2>

<p>和其他大多数现代编程语言一样，JavaScript 也采用词法作用域。也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须包括对函数定义出现的作用域的引用。将函数对象可和作用域相互关联起来（一对变量的绑定），函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p>

<p>从技术的角度讲，所有的 JavaScript 函数都是闭包，但是大多数函数调用和定义在同一个作用域内，通常不会注意这里有涉及到闭包。当调用函数不和其定义处于同一作用域内时，事情就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在 JavaScript 中非常常见。当你第一次碰到闭包时可能会觉得非常让人费解，一旦你理解掌握了闭包之后，就能非常自如地使用它了，了解这一点至关重要。</p>

<p>理解闭包首先要了解嵌套函数的词法作用域规则。看一下这段代码：</p>

<pre><code class="language-javascript">let scope = &quot;global scope&quot;;          // A global variable
function checkscope() {
    let scope = &quot;local scope&quot;;       // A local variable
    function f() { return scope; }   // Return the value in scope here
    return f();
}
checkscope()                         // =&gt; &quot;local scope&quot;
</code></pre>

<p>checkscope() 函数声明了一个局部变量，然后定义并执行了一个函数 f() ，函数 f() 返回了这个变量的值，最后将函数 f() 的执行结果返回。你应当非常清楚为什么调用 checkscope() 会返回 local scope。现在我们对这段代码做一点改动。你知道这段代码返回什么吗？</p>

<pre><code class="language-javascript">let scope = &quot;global scope&quot;;          // A global variable
function checkscope() {
    let scope = &quot;local scope&quot;;       // A local variable
    function f() { return scope; }   // Return the value in scope here
    return f;
}
let s = checkscope()();              // What does this return?
</code></pre>

<p>在这段代码中，我们将函数内的一对圆括号移动到了 checkscope() 之后。checkscope() 现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？</p>

<p>回想一下词法作用域的基本规则：JavaScript 函数的执行用到了作用域，这个作用域是函数定义的时候创建的。嵌套的函数 f() 定义在变量 scope 绑定的值是“local scope”的作用域里，这个绑定无论 f 函数在何处调用都依然有效。因此最后一行代码返回“local scope”，而不是“global scope”。简言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到它们的外部函数所绑定的局部变量（和参数）。</p>

<p>在 §8.4.1 中定义了 uniqueInteger() 函数，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致 uniquenterger() 函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用做私有状态。下面是如何用立即调用函数表达式重写 uniqueInteger() 来定义命名空间和闭包来保持其状态私有化：</p>

<pre><code class="language-javascript">let uniqueInteger = (function() {  // Define and invoke
    let counter = 0;               // Private state of function below
    return function() { return counter++; };
}());
uniqueInteger()  // =&gt; 0
uniqueInteger()  // =&gt; 1
</code></pre>

<p>你需要仔细阅读这段代码才能理解其含义。粗略来看，第一行代码看起来像将函数赋值给一个变量 uniqueInteger，实际上，这段代码定义了一个立即调用的函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量 uniqueInteger。现在，我们来看函数体，这个函数的返回值是另外一个函数。这是一个嵌套的函数，我们将它赋值给变量 uniqueInteger。嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的 counter 变量。当外部函数返回之后，其他任何代码都无法访问 counter 变量：只有内部的函数才能访问到它。</p>

<p>像 counter 一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域，看一下这段代码：</p>

<pre><code class="language-javascript">function counter() {
    let n = 0;
    return {
        count: function() { return n++; },
        reset: function() { n = 0; }
    };
}

let c = counter(), d = counter();   // Create two counters
c.count()                           // =&gt; 0
d.count()                           // =&gt; 0: they count independently
c.reset();                          // reset() and count() methods share state
c.count()                           // =&gt; 0: because we reset c
d.count()                           // =&gt; 1: d was not reset
</code></pre>

<p>counter() 函数返回了一个“计数器”对象，这个对象包含两个方法：count() 返回下一个整数，reset() 重置内部状态。首先要理解，这两个方法都可以访问私有变量n。再者，每次调用 counter() 都会创建一个新的作用域链和一个新的私有变量。因此，如果调用 counter() 两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的 count() 或 reset() 不会影响到另外一个对象。</p>

<p>从技术角度看，其实可以将这个闭包合并为属性存取器方法 getter 和 setter。下面这段代码所示的 counter() 函数的版本是 §6.10.6 中代码的变种，所不同的是，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现：</p>

<pre><code class="language-javascript">function counter(n) {  // Function argument n is the private variable
    return {
        // Property getter method returns and increments private counter var.
        get count() { return n++; },
        // Property setter doesn&#39;t allow the value of n to decrease
        set count(m) {
            if (m &gt; n) n = m;
            else throw Error(&quot;count can only be set to a larger value&quot;);
        }
    };
}

let c = counter(1000);
c.count            // =&gt; 1000
c.count            // =&gt; 1001
c.count = 2000;
c.count            // =&gt; 2000
c.count = 2000;    // !Error: count can only be set to a larger value
</code></pre>

<p>需要注意的是，这个版本的 counter() 函数并未声明局部变量，而只是使用参数 n 来保存私有状态并与属性存取器方法共享。这样的话，调用 counter() 的函数就可以指定私有变量的初始值了。</p>

<p>例 8-2是这种使用闭包技术来共享的私有状态的通用做法。这个例子定义了 addPrivateProperty() 函数，这个函数定义了一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值。它将这些嵌套函数添加为所指定对象的方法：</p>

<p>例 8-2：利用闭包实现的私有属性存取器方法</p>

<pre><code class="language-javascript">// This function adds property accessor methods for a property with
// the specified name to the object o. The methods are named get&lt;name&gt;
// and set&lt;name&gt;. If a predicate function is supplied, the setter
// method uses it to test its argument for validity before storing it.
// If the predicate returns false, the setter method throws an exception.
//
// The unusual thing about this function is that the property value
// that is manipulated by the getter and setter methods is not stored in
// the object o. Instead, the value is stored only in a local variable
// in this function. The getter and setter methods are also defined
// locally to this function and therefore have access to this local variable.
// This means that the value is private to the two accessor methods, and it
// cannot be set or modified except through the setter method.
function addPrivateProperty(o, name, predicate) {
    let value;  // This is the property value

    // The getter method simply returns the value.
    o[`get${name}`] = function() { return value; };

    // The setter method stores the value or throws an exception if
    // the predicate rejects the value.
    o[`set${name}`] = function(v) {
        if (predicate &amp;&amp; !predicate(v)) {
            throw new TypeError(`set${name}: invalid value ${v}`);
        } else {
            value = v;
        }
    };
}

// The following code demonstrates the addPrivateProperty() method.
let o = {};  // Here is an empty object

// Add property accessor methods getName and setName()
// Ensure that only string values are allowed
addPrivateProperty(o, &quot;Name&quot;, x =&gt; typeof x === &quot;string&quot;);

o.setName(&quot;Frank&quot;);       // Set the property value
o.getName()               // =&gt; &quot;Frank&quot;
o.setName(0);             // !TypeError: try to set a value of the wrong type
</code></pre>

<p>我们已经看到了很多例子，在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包，了解这一点也很重要。看一下下面这段代码：</p>

<pre><code class="language-javascript">// This function returns a function that always returns v
function constfunc(v) { return () =&gt; v; }

// Create an array of constant functions:
let funcs = [];
for(var i = 0; i &lt; 10; i++) funcs[i] = constfunc(i);

// The function at array element 5 returns the value 5.
funcs[5]()    // =&gt; 5
</code></pre>

<p>这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：</p>

<pre><code class="language-javascript">// Return an array of functions that return the values 0-9
function constfuncs() {
    let funcs = [];
    for(var i = 0; i &lt; 10; i++) {
        funcs[i] = () =&gt; i;
    }
    return funcs;
}

let funcs = constfuncs();
funcs[5]()    // =&gt; 10; Why doesn&#39;t this return 5?
</code></pre>

<p>上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量 i。当 constfuncs() 返回时，变量 i 的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域都是“活动的”，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照。从根本上讲，这里的问题是，使用 var 声明的变量，它的定义贯穿整个函数。我们的 for 循环使用 var i 声明循环变量，因此变量 i 在整个函数中都有定义，而不是更狭义地作用于循环的主体。该代码演示了 ES6 之前的常见 Bug 类别，但在 ES6 中引入块级变量作用域解决了这个问题。如果我们只是用 let 或 const 替换 var， 那么问题就消失了。由于 let 和 const 是块级作用域，因此循环的每个迭代都定义了一个独立于所有其他迭代的作用域，并且每个作用域都有其自己的独立绑定 i。</p>

<p>书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，而不是变量。正如之前讨论的，箭头函数从包含它们的函数中继承 this 值，但是用 function 关键字定义的函数不是。所以如果写一个闭包需要使用包含它的函数的 this 值，要在闭包返回之前使用箭头函数或者用调用 bind()，或者将 this 值赋值给一个变量，这样你的闭包会继承它：</p>

<pre><code class="language-javascript">const self = this;  // Make the this value available to nested functions
</code></pre>

<h2 id="toc_25">8.7 函数属性、方法、和构造函数</h2>

<p>我们看到在 JavaScript 程序中，函数是值。对函数执行 typeof 运算会返回字符串“function”，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用 Function() 构造函数来创建新的函数对象。接下来几节就会着重介绍函数 length、name 和 prototype 属性；call()、 apply()、 bind() 和 toString() 方法；以及 Function() 构造函数。</p>

<h3 id="toc_26">8.7.1 length 属性</h3>

<p>函数的只读属性 length 指定函数参数个数--声明在其参数列表中的参数个数，大多数函数期望的实参个数。如果一个函数有一个剩余函数，它的参数个数不被计算入 length 属性。（经测试，可选参数也不计算 length。）</p>

<h3 id="toc_27">8.7.2 name 属性</h3>

<p>如果使用名称定义函数，只读属性 name 指定函数定义时用的名称，或未命名函数表达式在首次创建时分配给的变量或属性的名称。此属性在编写调试或错误消息时很有用。</p>

<h3 id="toc_28">8.7.3 prototype 属性</h3>

<p>所有函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做原型对象。每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。§6.2.3 讨论了原型和 prototype 属性，在第9章里会有进一步讨论。</p>

<h3 id="toc_29">8.7.4 call() 和 apply() 方法</h3>

<p>我们可以将 call() 和 apply () 看做是某个对象的方法，通过调用方法的形式来间接调用（见 §8.2.4）函数。call() 和 apply() 的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内变成 this 关键字的值。要想以对象 o 的方法来调用函数 f()（没有实参传递），可以这样使用 call() 和 apply()：</p>

<pre><code class="language-javascript">f.call(o);
f.apply(o);
</code></pre>

<p>每行代码和下面代码的功能类似（假设对象 o 中预先不存在名为 m 的属性）:</p>

<pre><code class="language-javascript">o.m = f;     // Make f a temporary method of o.
o.m();       // Invoke it, passing no arguments.
delete o.m;  // Remove the temporary method.
</code></pre>

<p>不要忘了，箭头函数从它定义的位置的上下文继承 this 值。这不能被 call() 和 apply() 方法重写。如果通过箭头函数调用它俩任何一个方法，第一个实参实际上都被忽略。</p>

<p>对于 call() 来说，除了第一个作为调用上下文实参，之后的所有实参就是要传入待调用函数的值（并且，这部分实参对于箭头函数来说不被忽略）。比如，以对象 o 的方法的形式调用函数 f()，并传入两个数，可以使用这样的代码：</p>

<pre><code class="language-javascript">f.call(o, 1, 2);
</code></pre>

<p>apply() 方法和 call() 类似，但传入实参的形式和 call() 有所不同，它的实参都放入一个数组中：</p>

<pre><code class="language-javascript">f.apply(o, [1,2]);
</code></pre>

<p>如果一个函数的实参可以是任意数量，用 apply() 方法允许你传入的参数数组可以是任意长度的。在 ES6 之后，我们可以用展开运算符，但是在 ES5 的代码中你可以看到这种情况是用 apply() 来替代。比如，不用展开运算符找出数组中最大的数值元素，调用 Math.max() 方法的时候可以给  apply() 传入一个包含任意个元素的数组：</p>

<pre><code class="language-javascript">let biggest = Math.max.apply(Math, arrayOfNumbers);
</code></pre>

<p>下面定义的 trace() 与 §8.3.4 中定义的 timed() 函数类似，但是它对方法有效而不是函数。它使用 apply() 方法而不是展开运算符，通过这样做，它能够调用具有相同参数和与被包装方法相同的 this 值的包装方法。</p>

<pre><code class="language-javascript">// Replace the method named m of the object o with a version that logs
// messages before and after invoking the original method.
function trace(o, m) {
    let original = o[m];         // Remember original method in the closure.
    o[m] = function(...args) {   // Now define the new method.
        console.log(new Date(), &quot;Entering:&quot;, m);      // Log message.
        let result = original.apply(this, args);      // Invoke original.
        console.log(new Date(), &quot;Exiting:&quot;, m);       // Log message.
        return result;                                // Return result.
    };
}
</code></pre>

<h3 id="toc_30">8.7.5 bind() 方法</h3>

<p>The primary purpose of bind() is to bind a function to an object. When you invoke the bind() method on a function f and pass an object o, the method returns a new function. Invoking the new function (as a function) invokes the original function f as a method of o. Any arguments you pass to the new function are passed to the original function. For example:</p>

<blockquote>
<p>bind() 方法的主要作用就是将函数绑定至某个对象。当在函数 f() 上调用 bind() 方法并传入一个对象 o 作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数 f() 当做 o 的方法来调用。传入新函数的任何实参都将传入原始函数，比如：</p>
</blockquote>

<pre><code class="language-javascript">function f(y) { return this.x + y; } // This function needs to be bound
let o = { x: 1 };                    // An object we&#39;ll bind to
let g = f.bind(o);                   // Calling g(x) invokes f() on o
g(2)                                 // =&gt; 3
let p = { x: 10, g };                // Invoke g() as a method of this object
p.g(2)                               // =&gt; 3: g is still bound to o, not p.
</code></pre>

<p>箭头函数从它们定义的上下文中继承 this 值，并且其不可被 bind() 方法重写，所以如果上面的代码用箭头函数定义函数 f()，这个绑定不会生效。调用 bind() 方法的最常用场景是让不带箭头的函数的行为像箭头函数一样，所以实际上绑定箭头函数的 this 局限性并不是一个问题。</p>

<p>但是 bind() 方法不仅仅是将函数绑定至一个对象。它还附带一些其他应用：除了第一个实参之外，传入 bind() 的实参也会绑定至 this 值。这个附带的应用在箭头函数上也同样生效。是一种常见的函数式编程技术，有时也被称为“柯里化”。参照下面这个例子中的 bind() 方法的实现：</p>

<pre><code class="language-javascript">let sum = (x,y) =&gt; x + y;      // Return the sum of 2 args
let succ = sum.bind(null, 1);  // Bind the first argument to 1
succ(2)  // =&gt; 3: x is bound to 1, and we pass 2 for the y argument

function f(y,z) { return this.x + y + z; }
let g = f.bind({x: 1}, 2);     // Bind this and y
g(3)     // =&gt; 6: this.x is bound to 1, y is bound to 2 and z is 3
</code></pre>

<p>bind() 返回函数的名称属性是调用 bind() 的函数的名称属性前面加上前缀为单词&quot;bound&quot;。</p>

<h3 id="toc_31">8.7.6 toString() 方法</h3>

<p>和所有的 JavaScript 对象一样，函数也有 toString() 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的 toString() 方法的实现都返回函数的完整源码。内置函数往往返回一个类似”[native code]”的字符串作为函数体。</p>

<h3 id="toc_32">8.7.7 Function() 构造函数</h3>

<p>因为函数是对象，有一个 Function() 构造函数可以用来创建新的函数：</p>

<pre><code class="language-javascript">const f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);
</code></pre>

<p>这一行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价：</p>

<pre><code class="language-javascript">const f = function(x, y) { return x*y; };
</code></pre>

<p>Function() 构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体——即可。</p>

<p>注意，Function() 构造函数并不需要通过传入实参以指定函数名。就像函数字面量一样，Function() 构造函数创建一个匿名函数。</p>

<p>关于 Function() 构造函数有几点需要特别注意：</p>

<p>Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数。</p>

<p>每次调用 Function() 构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。</p>

<p>最后一点，也是关于 Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，如下面代码所示：</p>

<pre><code class="language-javascript">let scope = &quot;global&quot;;
function constructFunction() {
    let scope = &quot;local&quot;;
    return new Function(&quot;return scope&quot;);  // Doesn&#39;t capture local scope!
}
// This line returns &quot;global&quot; because the function returned by the
// Function() constructor does not use the local scope.
constructFunction()()  // =&gt; &quot;global&quot;
</code></pre>

<p>我们可以将 Function() 构造函数认为是在全局作用域中执行的 eval()（见  §4.12.2），eval() 可以在自己的私有作用域内定义新变量和函数，Function() 构造函数在实际编程过程中很少会用到。</p>

<h2 id="toc_33">8.8 函数式编程</h2>

<p>和 Lisp、Haskell 不同，JavaScript 并非函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术。数组方法诸如 map() 和 reduce() 就可以非常适合用于函数式编程风格。接下来的几节将会着重介绍 JavaScript 中的函数式编程技术。函数式编程旨在扩展对 JavaScript 函数功能功能的探索，而不是为了良好的编程风格。</p>

<h3 id="toc_34">8.8.1 用函数处理数组</h3>

<p>假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样：</p>

<pre><code class="language-javascript">let data = [1,1,3,5,5];  // This is our array of numbers

// The mean is the sum of the elements divided by the number of elements
let total = 0;
for(let i = 0; i &lt; data.length; i++) total += data[i];
let mean = total/data.length;  // mean == 3; The mean of our data is 3

// To compute the standard deviation, we first sum the squares of
// the deviation of each element from the mean.
total = 0;
for(let i = 0; i &lt; data.length; i++) {
    let deviation = data[i] - mean;
    total += deviation * deviation;
}
let stddev = Math.sqrt(total/(data.length-1));  // stddev == 2
</code></pre>

<p>可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其简洁（参照 §7.8.1 来查看这些方法）：</p>

<pre><code class="language-javascript">// First, define two simple functions
const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;

// Then use those functions with Array methods to compute mean and stddev
let data = [1,1,3,5,5];
let mean = data.reduce(sum)/data.length;  // mean == 3
let deviations = data.map(x =&gt; x-mean);
let stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1));
stddev  // =&gt; 2
</code></pre>

<p>这个新版本的代码看起来跟第一版有很大不同，但是它仍然调用对象的方法，所以它还是面向对象编程。接下来用函数版本的 map() 和 reduce() 方法：</p>

<pre><code class="language-javascript">const map = function(a, ...args) { return a.map(...args); };
const reduce = function(a, ...args) { return a.reduce(...args); };
</code></pre>

<p>用这两个函数定义了 map() 和 reduce()，我们计算平均值和标准差变成这样：</p>

<pre><code class="language-javascript">const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;

let data = [1,1,3,5,5];
let mean = reduce(data, sum)/data.length;
let deviations = map(data, x =&gt; x-mean);
let stddev = Math.sqrt(reduce(map(deviations, square), sum)/(data.length-1));
stddev  // =&gt; 2
</code></pre>

<h3 id="toc_35">8.8.2 高阶函数</h3>

<p>所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数。来看这个例子：</p>

<pre><code class="language-javascript">// This higher-order function returns a new function that passes its
// arguments to f and returns the logical negation of f&#39;s return value;
function not(f) {
    return function(...args) {             // Return a new function
        let result = f.apply(this, args);  // that calls f
        return !result;                    // and negates its result.
    };
}

const even = x =&gt; x % 2 === 0; // A function to determine if a number is even
const odd = not(even);         // A new function that does the opposite
[1,1,3,5,5].every(odd)         // =&gt; true: every element of the array is odd
</code></pre>

<p>上面的 not() 函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的 mapper() 函数，它也是接收一个函数作为实参，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的 map() 函数，但要首先理解这两个函数有哪里不 同，理解这一点至关重要：</p>

<pre><code class="language-javascript">// Return a function that expects an array argument and applies f to
// each element, returning the array of return values.
// Contrast this with the map() function from earlier.
function mapper(f) {
    return a =&gt; map(a, f);
}

const increment = x =&gt; x+1;
const incrementAll = mapper(increment);
incrementAll([1,2,3])  // =&gt; [2,3,4]
</code></pre>

<p>这里是一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())：</p>

<pre><code class="language-javascript">// Return a new function that computes f(g(...)).
// The returned function h passes all of its arguments to g, then passes
// the return value of g to f, then returns the return value of f.
// Both f and g are invoked with the same this value as h was invoked with.
function compose(f, g) {
    return function(...args) {
        // We use call for f because we&#39;re passing a single value and
        // apply for g because we&#39;re passing an array of values.
        return f.call(this, g.apply(this, args));
    };
}

const sum = (x,y) =&gt; x+y;
const square = x =&gt; x*x;
compose(square, sum)(2,3)  // =&gt; 25; the square of the sum
</code></pre>

<p>本章后续几节中定义了 partial() 和 memoize() 函数，这两个函数是非常重要的高阶函数。</p>

<h3 id="toc_36">8.8.3 局部应用函数</h3>

<p>函数 f()（见 §8.7.5）的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数“绑定至”对象并传入一部分参数。bind() 方法只是将实参放在（完整实参列表的）左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在（完整实参列表的）右侧：</p>

<pre><code class="language-javascript">// The arguments to this function are passed on the left
function partialLeft(f, ...outerArgs) {
    return function(...innerArgs) { // Return this function
        let args = [...outerArgs, ...innerArgs]; // Build the argument list
        return f.apply(this, args);              // Then invoke f with it
    };
}

// The arguments to this function are passed on the right
function partialRight(f, ...outerArgs) {
    return function(...innerArgs) {  // Return this function
        let args = [...innerArgs, ...outerArgs]; // Build the argument list
        return f.apply(this, args);              // Then invoke f with it
    };
}

// The arguments to this function serve as a template. Undefined values
// in the argument list are filled in with values from the inner set.
function partial(f, ...outerArgs) {
    return function(...innerArgs) {
        let args = [...outerArgs]; // local copy of outer args template
        let innerIndex=0;          // which inner arg is next
        // Loop through the args, filling in undefined values from inner args
        for(let i = 0; i &lt; args.length; i++) {
            if (args[i] === undefined) args[i] = innerArgs[innerIndex++];
        }
        // Now append any remaining inner arguments
        args.push(...innerArgs.slice(innerIndex));
        return f.apply(this, args);
    };
}

// Here is a function with three arguments
const f = function(x,y,z) { return x * (y - z); };
// Notice how these three partial applications differ
partialLeft(f, 2)(3,4)         // =&gt; -2: Bind first argument: 2 * (3 - 4)
partialRight(f, 2)(3,4)        // =&gt;  6: Bind last argument: 3 * (4 - 2)
partial(f, undefined, 2)(3,4)  // =&gt; -6: Bind middle argument: 3 * (2 - 4)
</code></pre>

<p>利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数，参照下面这个例子：</p>

<pre><code class="language-javascript">const increment = partialLeft(sum, 1);
const cuberoot = partialRight(Math.pow, 1/3);
cuberoot(increment(26))  // =&gt; 3
</code></pre>

<p>当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了 not() 函数，它用到了刚才提到的不完全调用：</p>

<pre><code class="language-javascript">const not = partialLeft(compose, x =&gt; !x);
const even = x =&gt; x % 2 === 0;
const odd = not(even);
const isNumber = not(isNaN);
odd(3) &amp;&amp; isNumber(2)  // =&gt; true
</code></pre>

<p>我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程：</p>

<pre><code class="language-javascript">// sum() and square() functions are defined above. Here are some more:
const product = (x,y) =&gt; x*y;
const neg = partial(product, -1);
const sqrt = partial(Math.pow, undefined, .5);
const reciprocal = partial(Math.pow, undefined, neg(1));

// Now compute the mean and standard deviation.
let data = [1,1,3,5,5];   // Our data
let mean = product(reduce(data, sum), reciprocal(data.length));
let stddev = sqrt(product(reduce(map(data,
                                     compose(square,
                                             partial(sum, neg(mean)))),
                                 sum),
                          reciprocal(sum(data.length,neg(1)))));
[mean, stddev]  // =&gt; [3, 2]
</code></pre>

<p>注意，这段代码计算平均值和标准差完全是函数调用;没有涉及运算符，并且括号的数量增长如此之大让 JavaScript 开始看起来像 Lisp 代码。同样，这不是我提倡的 JavaScript 编程风格，但它是一个有趣的练习，看看 JavaScript 代码的功能有多深。</p>

<h3 id="toc_37">8.8.4 记忆（Memoization）</h3>

<p>在 §8.4.1 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数:</p>

<pre><code class="language-javascript">// Return a memoized version of f.
// It only works if arguments to f all have distinct string representations.
function memoize(f) {
    const cache = new Map();  // Value cache stored in the closure.

    return function(...args) {
        // Create a string version of the arguments to use as a cache key.
        let key = args.length + args.join(&quot;+&quot;);
        if (cache.has(key)) {
            return cache.get(key);
        } else {
            let result = f.apply(this, args);
            cache.set(key, result);
            return result;
        }
    };
}
</code></pre>

<p>memorize() 函数创建一个新的对象，这个对象被当做缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用 memorize()：</p>

<pre><code class="language-javascript">// Return the Greatest Common Divisor of two integers using the Euclidian
// algorithm: http://en.wikipedia.org/wiki/Euclidean_algorithm
function gcd(a,b) {  // Type checking for a and b has been omitted
    if (a &lt; b) {           // Ensure that a &gt;= b when we start
        [a, b] = [b, a];   // Destructuring assignment to swap variables
    }
    while(b !== 0) {       // This is Euclid&#39;s algorithm for GCD
        [a, b] = [b, a%b];
    }
    return a;
}

const gcdmemo = memoize(gcd);
gcdmemo(85, 187)  // =&gt; 17

// Note that when we write a recursive function that we will be memoizing,
// we typically want to recurse to the memoized version, not the original.
const factorial = memoize(function(n) {
    return (n &lt;= 1) ? 1 : n * factorial(n-1);
});
factorial(5)      // =&gt; 120: also caches values for 4, 3, 2 and 1.
</code></pre>

<h2 id="toc_38">8.9 总结</h2>

<p>本章关键点总结如下：</p>

<ul>
<li>可以用函数关键字和 ES6 =&gt; 箭头函数来定义函数。</li>
<li>可以以方法和构造函数的方式调用函数。</li>
<li>一些 ES6 特性，允许参数设定默认值，可以用剩余参数将多个参数搜集到一个数组中，可以解构对象和数组实参到函数参数中。</li>
<li>可以用 ... 展开运算符传递数组元素或者其他可迭代对象到函数调用。</li>
<li>封闭函数内部定义并返回的函数保留对其词法作用域的访问，因此可以读取和写入外部函数内定义的变量。用这种方式使用的函数称为闭包，这是一种值得理解的技术。</li>
<li>函数是可由 JavaScript 操作的对象，这使 JavaScript 支持函数式编程。</li>
</ul>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>这个术语最初是由 Martin Fowler 提出的，参见<a href="http://martinfowler.com/dslwip/MethodChaining.html%E3%80%82">http://martinfowler.com/dslwip/MethodChaining.html。</a>&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>这看起来不足为奇，但如果你对 Python 很熟悉，你会发现 Python 中的函数是程序的一 部分，但无法被程序操作。&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>这似乎并不是一个特别有趣的点，除非你熟悉更多的静态语言，其中函数是程序的一部分，但不能由程序操作。&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 9 章 类]]></title>
    <link href="2019919.xyz/16118386693796.html"/>
    <updated>2021-01-28T20:57:49+08:00</updated>
    <id>2019919.xyz/16118386693796.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">9.1 类和原型</a>
</li>
<li>
<a href="#toc_1">9.2 类和构造函数</a>
<ul>
<li>
<a href="#toc_2">9.2.1 构造函数、类标识和 instanceof</a>
</li>
<li>
<a href="#toc_3">9.2.2 constructor 属性</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">9.3 使用 class 关键字的类</a>
<ul>
<li>
<a href="#toc_5">9.3.1 静态方法</a>
</li>
<li>
<a href="#toc_6">9.3.2 Getter、Setter 和其他方法</a>
</li>
<li>
<a href="#toc_7">9.3.3 公有、私有和静态字段</a>
</li>
<li>
<a href="#toc_8">9.3.4 示例：一个复数类</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">9.4 为类添加方法</a>
</li>
<li>
<a href="#toc_10">9.5 子类</a>
<ul>
<li>
<a href="#toc_11">9.5.1 子类和原型</a>
</li>
<li>
<a href="#toc_12">9.5.2 子类与 extends 和 super</a>
</li>
<li>
<a href="#toc_13">9.5.3 委托代替继承</a>
</li>
<li>
<a href="#toc_14">9.5.4 Hierarchies 类和抽象类</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">9.6 总结</a>
</li>
</ul>


<p>第 6 章详细介绍了 JavaScript 对象，每个 JavaScript 对象都是一个属性集合，相互之间没有任何联系。在 JavaScript 中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。例如，假设有一个名为 Complex 的类用来表示复数，同时还定义了一些复数运算。一个 Complex 实例应当包含复数的实部和虚部（状态），同样 Complex 类还会定义复数的加法和乘法操作（行为）。</p>

<p>在 JavaScript 中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。JavaScript 原型和继承在 §6.2.3 和 §6.3.2 节中有详细讨论，为了更好地理解本章的内容，请务必首先阅读这两个章节。本章将会在 §9.1 中对原型做进一步讨论。</p>

<p>如果两个对象继承自同一个原型，往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。我们已经在 §4.6、§6.2.2 和 §8.2.3 节中详细讲解了构造函数，§9.2 会有进一步讨论。</p>

<p>JavaScript 一直允许定义类。ES6 引入了全新的语法（包括 class 关键字），使创建类更加容易。这些新的 JavaScript 类的工作方式与旧式类相同，本章首先解释创建类的旧方法，因为这更清楚地展示了类是如何工作的。一旦我们解释了这些基本原理，我们将改变并开始使用新的、简化的类定义语法。</p>

<p>如果你对诸如 Java 和 C++ 这种强类型的面向对象编程比较熟悉，你会发现 JavaScript 中的类和 Java 以及 C++ 中的类有很大不同。尽管在写法上类似，而且在 JavaScript 中也能“模拟”出很多经典的类的特性，但是最好要理解 JavaScript 的类和基于原型的继承机制，以及和传统的 Java（当然还有类似 Java 的语言）的类和基于类的继承机制的不同之处。</p>

<h2 id="toc_0">9.1 类和原型</h2>

<p>在 JavaScript 中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在示例 6-1 中定义了 inherit() 函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过 inherit() 函数创建一个继承自它的对象，这样就定义了一个 JavaScript 类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象，参照示例 9-1。示例 9-1 给一个表示“值的范围”的类定义了原型对象，还定义了一个“工厂”函数用以创建并初始化类的实例。</p>

<p>示例 9-1：一个简单的 JavaScript 类</p>

<pre><code class="language-javascript">// This is a factory function that returns a new range object.
function range(from, to) {
    // Use Object.create() to create an object that inherits from the
    // prototype object defined below.  The prototype object is stored as
    // a property of this function, and defines the shared methods (behavior)
    // for all range objects.
    let r = Object.create(range.methods);

    // Store the start and end points (state) of this new range object.
    // These are noninherited properties that are unique to this object.
    r.from = from;
    r.to = to;

    // Finally return the new object
    return r;
}

// This prototype object defines methods inherited by all range objects.
range.methods = {
    // Return true if x is in the range, false otherwise
    // This method works for textual and Date ranges as well as numeric.
    includes(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; },

    // A generator function that makes instances of the class iterable.
    // Note that it only works for numeric ranges.
    *[Symbol.iterator]() {
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
    },

    // Return a string representation of the range
    toString() { return &quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;; }
};

// Here are example uses of a range object.
let r = range(1,3);      // Create a range object
r.includes(2)            // =&gt; true: 2 is in the range
r.toString()             // =&gt; &quot;(1...3)&quot;
[...r]                   // =&gt; [1, 2, 3]; convert to an array via iterator
</code></pre>

<p>在示例 9-1 的代码中有一下几点值得注意：</p>

<p>这段代码定义了一个工厂函数 range() 用来创建一个新的 Range 对象。</p>

<p>用 range() 函数的 methods 属性来存放定义类的原型对象。只是将原型对象随意的放在一个地方，并不是一个规约或者习惯。</p>

<p>range() 函数在每个 Range 对象中都定义 from 和 to 属性。它们是非共享、非继承属性，是每个独立的 Range 对象的独特自有状态。</p>

<p>range.methods 对象应用了 ES6 的速记语法来定义方法，这是为什么没有看到 function 关键字的原因。（参照 §6.10.5 来复习对象字面量速记方法语法。）</p>

<p>原型中的一个方法 Symbol.iterator 使用了计算属性名（§6.10.2），表明它是为 Range 对象定义一个迭代器。方法名称带有一个前缀 *，标识它是一个生成器函数而不是普通的函数。迭代器和生成器在第 12 章会详细描述。现在，只需要知道 Range 类的实例可以用 for/of 循环和可以用 ... 展开运算符。</p>

<p>定义在 range.methods 中的共享继承方法都使用在 range() 工厂函数初始化的 from 和 to 属性。在这些方法被调用时，为了引用 from 和 to 属性，都使用 this 关键字来获取对象的引用。this 这种用法是任何类中方法的基本特征。</p>

<h2 id="toc_1">9.2 类和构造函数</h2>

<p>示例 9-1 展示了一个简单方式来定义一个 JavaScript 类。但是这种方法并不常用，因为它没有定义一个构造函数。构造函数是用来初始化新建对象的。如 §8.2.3 中所述构造函数用 new 关键字来调用。使用 new 调用构造函数会自动创建一个新对象，因此构造函数本身只需初始化这个新对象的状态即可。§6.2.3 介绍并强调了虽然所有对象都有原型，但是只有一部分对象有一个 prototype 属性。最后，我们可以澄清这一点：是函数对象具有 prototype 属性。这意味着所有用同一构造函数创建的对象继承同一个对象，因此它们是同一类的成员。示例 9-2 说明了如何使用一个构造函数来替代示例 9-1 中的工厂函数来修改 Range 类。示例 9-2 演示了在不支持 ES6 class 关键字版本的 JavaScript 中创建一个类的通用方法。即使是 class 已经很好支持的今天，仍然有很多旧 JavaScript 代码用这种方式定义类，并且你必须熟悉这种习惯用法，以便于阅读旧代码，也能够在使用 class 关键字时明白在底层中发生了什么。</p>

<p>示例 9-2：使用构造函数的 Range 类</p>

<pre><code class="language-javascript">// This is a constructor function that initializes new Range objects.
// Note that it does not create or return the object. It just initializes this.
function Range(from, to) {
    // Store the start and end points (state) of this new range object.
    // These are noninherited properties that are unique to this object.
    this.from = from;
    this.to = to;
}

// All Range objects inherit from this object.
// Note that the property name must be &quot;prototype&quot; for this to work.
Range.prototype = {
    // Return true if x is in the range, false otherwise
    // This method works for textual and Date ranges as well as numeric.
    includes: function(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; },

    // A generator function that makes instances of the class iterable.
    // Note that it only works for numeric ranges.
    [Symbol.iterator]: function*() {
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
    },

    // Return a string representation of the range
    toString: function() { return &quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;; }
};

// Here are example uses of this new Range class
let r = new Range(1,3);   // Create a Range object; note the use of new
r.includes(2)             // =&gt; true: 2 is in the range
r.toString()              // =&gt; &quot;(1...3)&quot;
[...r]                    // =&gt; [1, 2, 3]; convert to an array via iterator
</code></pre>

<p>将示例 9-1 和示例 9-2 中的代码做一个仔细的对比，可以发现两种类定义技术的差别。首先，注意当工厂函数 range() 转化为构造函数时被重命名为 Range()。这里遵循了一个常见的编程约定：从某种意义上讲，定义构造函数即是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。</p>

<p>再者，注意 Range() 构造函数是通过 new 关键字调用的（在示例代码的末尾）， 而 range() 工厂函数则不必使用 new。示例 9-1 通过调用普通函数（§8.2.1）来创建新对象，示例 9-2 则使用构造函数调用（§8.2.3）来创建新对象。由于 Range() 构造函数是通过 new 关键字调用的，因此不必调用 Object.create() 或其他什么逻辑来创建新对象。在调用构造函数之前就已经创建了新对象，并且通过 this 关键字可以获取这个新对象。Range() 构造函数只不过是初始化 this 而已。构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。构造函数调用与常规函数调用如此不同，实际上，这是我们为构造函数命名以大写字母为名的另一个原因。构造函数就是用来“构造新对象”的，它必须通过关键字 new 调用，如果将构造函数用做普通函数的话，往往不会正常工作。开发者可以通过命名规约来（构造函数首字母大写，普通方法首字母小写）判断是否应当在函数之前冠以关键字 new。</p>

<p><strong>构造函数和 new.target</strong></p>

<p>在函数正文中，可以使用特殊的表达式 new.target 来判断函数是否以构造函数的方式调用。如果定义了该表达式的值，那么这个函数是通过 new 关键字调用的构造函数。当我们在 §9.5 中讨论子类时，我们会看到 new.target 不总是其所在的构造函数的引用：它可能还引用子类的构造函数。</p>

<p>如果 new.target 是 undefined，那么包含它的函数是作为函数调用的，没有使用 new 关键字。JavaScript 很多异常构造函数可以不使用 new 来调用，如果想模仿这个特性可以这样写：</p>

<pre><code class="language-javascript">function C() {
    if (!new.target) return new C();
    // initialization code goes here
}
</code></pre>

<p>这个老式技巧只在构造函数定义时生效。类使用 class 关键字创建，不允许不使用 new 调用它的构造函数。</p>

<p>示例 9-1 和 9-2 之间的另一个关键区别是原型对象的命名方式。在第一个示例中，原型是 range.methods。这是一个方便和描述性的名称，但随意。在第二个示例中，原型为 Range.prototype，此名称是规定的。Range() 构造函数的调用自动使用 Range.prototype 作为新 Range 对象的原型。</p>

<p>最后，还要注意示例 9-1 和 9-2 之间不变的部分：对两个类来说，range 方法以相同的方式定义和调用。由于示例 9-2 演示了在 ES6 之前在 JavaScript 版本中创建类的惯用方法，因此它没原型对象中使用 ES6 速记方法语法，并且使用 function 关键字显式拼出方法名。但是，可以看到，在这两个示例中，方法的实现是相同的。</p>

<p>请注意，在定义构造函数或方法时，两个 range 示例都没使用箭头函数。回想一下，从 §8.1.3 中，用这种方式定义的函数没有原型属性，因此不能用作构造函数。此外，箭头函数从定义它们的上下文中继承 this 关键字，而不是基于调用它们的对象设置 this 值，这使得箭头函数对方法毫无用处，因为方法的定义特征是方法使用 this 关键字来引用调用方法的实例。</p>

<p>幸运的是，新的 ES6 类语法不允许使用 arrow 函数定义方法，因此这不是使用该语法时可能会意外犯的错误。我们将很快介绍 ES6 类关键字，但首先，有更多关于构造函数的详细信息。</p>

<h3 id="toc_2">9.2.1 构造函数、类标识和 instanceof</h3>

<p>正如我们所看到的，原型对象是类的基本标识：只有两个对象继承同一原型对象时，这两个对象是同一类实例。构造函数的关键点不是初始化新创建对象的状态：两个构造函数可能具有指向同一原型对象的原型属性。那么，两个构造函数都可用于创建同一类的实例。</p>

<p>尽管构造函数不像原型那样重要，但是构造函数充当 class 的大众脸。最明显的是，构造函数的名称通常用作类的名称。例如，我们说 Range() 构造函数创建 Range 对象。然而，更重要的是测试类中对象的成员关系，构造函数在右边被用作 instanceof 运算符的操作数。如果有一个对象 r，并且想知道它是不是一个 Range 对象，可以这样写：</p>

<pre><code class="language-javascript">r instanceof Range   // =&gt; true: r inherits from Range.prototype
</code></pre>

<p>instanceof 运算符在 §4.9.4 中有描述。左边的操作数是想要测试的对象，右边的操作数是命名类的构造函数。表达式 <code>o instanceof C</code> 计算结果为 true 时，o 继承自 C.prototype。不需要直接继承：如果 o 继承于一个继承了 C.prototype 的对象，表达式的计算结果也仍会是 true。</p>

<p>从技术上讲，在上一个代码示例中，instanceof 运算符的实例没有检查 r 是否实际由 Range 构造函数初始化。相反，它是检查 r 是否继承 Range.prototype。如果我们定义一个函数 Strange() 并将其原型设置与 Range.prototype 相同，则使用新 Strange() 创建的对象用 instanceof 运算符将算作 Range 对象（但是，它们实际上不会作为 Range 对象工作，因为它们的 from 和 to 属性尚未初始化）：</p>

<pre><code class="language-javascript">function Strange() {}
Strange.prototype = Range.prototype;
new Strange() instanceof Range   // =&gt; true
</code></pre>

<p>实际上即使 instanceof 不能验证使用了构造函数，它仍然使用构造函数作为其右侧，因为构造函数是类的公共标识。</p>

<p>如果要为特定原型测试对象的原型链，并且不想将构造函数用作媒介，可以使用 isPrototypeOf() 方法。例如，在示例 9-1 中，我们定义了一个没有构造函数的类，因此无法将 instanceof 与该类一起使用。但是，我们可以测试对象 r 是否是具有此代码的无构造函数类的成员：</p>

<pre><code class="language-javascript">range.methods.isPrototypeOf(r);  // range.methods is the prototype object.
</code></pre>

<h3 id="toc_3">9.2.2 constructor 属性</h3>

<p>在示例 9-2 中，将 Range.prototype 定义为一个新对象，这个对象包含类所需要的方法。其实没有必要新创建一个对象，用单个对象字面量的属性就可以方便地定义原型上的方法。任何普通 JavaScript 函数（除箭头函数、生成器函数和异步函数之外）都可以用做构造函数，并且调用构造函数是需要一个 prototype 属性的。因此，每个 JavaScript 函数都自动拥有一个 prototype 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor。constructor 属性的值是一个函数对象：</p>

<pre><code class="language-javascript">let F = function() {}; // This is a function object.
let p = F.prototype;   // This is the prototype object associated with F.
let c = p.constructor; // This is the function associated with the prototype.
c === F                // =&gt; true: F.prototype.constructor === F for any F
</code></pre>

<p>可以看到构造函数的原型中存在预先定义好的 constructor 属性，这意味着对象通常继承的 constructor 是它们的构造函数的引用。由于构造函数是类的“公共标识”， 因此这个 constructor 属性为对象提供了类。</p>

<pre><code class="language-javascript">let o = new F();      // Create an object o of class F
o.constructor === F   // =&gt; true: the constructor property specifies the class
</code></pre>

<p>如图 9-1 所示，图 9-1 展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例。</p>

<p>图 9-1：构造函数，原型，实例</p>

<p><img src="media/16101520446472/16118384534713.jpg" alt="图 9-1：构造函数，原型，实例"/></p>

<p>需要注意的是，图 9-1 用 Range() 构造函数作为示例。但实际上，示例 9-2 中定义的 Range 类使用它自身的一个新对象重写了预定义的 Range.prototype 对象。这个新定义的原型对象不含有 constructor 属性。因此 Range 类的实例也不含有 constructor 属性。我们可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：</p>

<pre><code class="language-javascript">Range.prototype = {
    constructor: Range,  // Explicitly set the constructor back-reference

    /* method definitions go here */
};
</code></pre>

<p>另一种常见的解决办法是使用预定义的原型对象，预定义的原型对象包含 constructor 属性，然后依次给原型对象添加方法：</p>

<pre><code class="language-javascript">// Extend the predefined Range.prototype object so we don&#39;t overwrite
// the automatically created Range.prototype.constructor property.
Range.prototype.includes = function(x) {
    return this.from &lt;= x &amp;&amp; x &lt;= this.to;
};
Range.prototype.toString = function() {
    return &quot;(&quot; + this.from + &quot;...&quot; + this.to + &quot;)&quot;;
};
</code></pre>

<h2 id="toc_4">9.3 使用 class 关键字的类</h2>

<p>类自第一个版本以来一直是 JavaScript 的一部分，但在 ES6 中，它们最终引入 class 关键字得到了自己的语法。示例 9-3 显示了使用此新语法编写 Range 类的实现。</p>

<p>示例 9-3：使用 class 编写 Range 类</p>

<pre><code class="language-javascript">class Range {
    constructor(from, to) {
        // Store the start and end points (state) of this new range object.
        // These are noninherited properties that are unique to this object.
        this.from = from;
        this.to = to;
    }

    // Return true if x is in the range, false otherwise
    // This method works for textual and Date ranges as well as numeric.
    includes(x) { return this.from &lt;= x &amp;&amp; x &lt;= this.to; }

    // A generator function that makes instances of the class iterable.
    // Note that it only works for numeric ranges.
    *[Symbol.iterator]() {
        for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
    }

    // Return a string representation of the range
    toString() { return `(${this.from}...${this.to})`; }
}

// Here are example uses of this new Range class
let r = new Range(1,3);   // Create a Range object
r.includes(2)             // =&gt; true: 2 is in the range
r.toString()              // =&gt; &quot;(1...3)&quot;
[...r]                    // =&gt; [1, 2, 3]; convert to an array via iterator
</code></pre>

<p>重要的是要了解，在示例 9-2 和 9-3 中定义的类的工作方式完全相同。将 class 关键字引入语言并不会改变 JavaScript 基于原型的类的基本性质。尽管示例 9-3 使用 class 关键字，但生成的 Range 对象是一个构造函数，就像示例 9-2 中定义的版本一样。新的 class 语法更清洁方便，但是最好将其看作示例 9-2 所示的基本类定义机制的语法糖。</p>

<p>注意在示例 9-3 中关于 class 语法的一下几点：</p>

<p>用 class 关键字声明类，后面接一个类名，最后是花括号包含类的正文。</p>

<p>类正文包括使用对象字面量方法速记定义的方法（我们在示例 9-1 中也使用了），其中省略了函数关键字。但是，与对象字面量不同，没有用逗号将方法彼此分开。（虽然类正文表面上与对象字面量相似，但它们不是一回事。与对象不同，类不支持具有名/值对的属性的定义。</p>

<p>关键字 constructor 用于定义类的构造函数。但是，定义的函数实际上并不命名为 constructor。类声明语句定义一个新的变量 Range，并将此特殊构造函数的值分配给该变量。</p>

<p>如果类不需要执行任何初始化，可以省略构造函数关键字及其正文，并将隐式创建一个空构造函数。</p>

<p>如果要定义子类（或继承来自另一个类的类），可以使用 extends 关键字与 class 关键字：</p>

<pre><code class="language-javascript">// A Span is like a Range, but instead of initializing it with
// a start and an end, we initialize it with a start and a length
class Span extends Range {
    constructor(start, length) {
        if (length &gt;= 0) {
            super(start, start + length);
        } else {
            super(start + length, start);
        }
    }
}
</code></pre>

<p>创建子类是完整的一节。我们将在 §9.5 重新讲到它，并解释这里的 extends 和 super 关键字。</p>

<p>与函数声明一样，类声明同时具有语句和表达式形式。正如我们可以写：</p>

<pre><code class="language-javascript">let square = function(x) { return x * x; };
square(3)  // =&gt; 9
we can also write:

let Square = class { constructor(x) { this.area = x * x; } };
new Square(3).area  // =&gt; 9
</code></pre>

<p>与函数定义表达式一样，类定义表达式可以包含可选类名。如果提供这样的名称，则该名称仅在类正文本身中有定义。</p>

<p>尽管函数表达式很常见（尤其是使用箭头函数），但 JavaScript 编程中，类定义表达式可能并不是经常使用，除非正在编写一个以类为实参并返回子类的函数。</p>

<p>结束对 class 关键字的介绍前，最后提几个重要但是不易注意的类语法：</p>

<p>类声明正文中的所有代码都隐式采用严格模式（§5.6.3），即使未出现&quot;use strict&quot;指令。例如，这意味着不能在类正文中使用八进制整数字面量或 with 语句，并且如果在使用变量之前忘记声明变量，则更有可能出现语法错误。</p>

<p>与函数声明不同，类声明不是&quot;声明提前&quot;的。回想一下 §8.1.1 中，函数定义的行为就像它们被移动到封闭文件的顶部或封闭函数的顶部一样，这意味着可以在函数实际定义之前的代码中调用函数。尽管类声明在某些方面与函数声明一样，但它们不共享这种提前行为：在声明类之前，不能实例化类。</p>

<h3 id="toc_5">9.3.1 静态方法</h3>

<p>可以通过使用 static 关键字作为方法声明前缀来定义类正文中的静态方法。静态方法定义为构造函数的属性，而不是原型对象的属性。</p>

<p>例如，假设我们将以下代码添加到示例 9-3 中：</p>

<pre><code class="language-javascript">static parse(s) {
    let matches = s.match(/^\((\d+)\.\.\.(\d+)\)$/);
    if (!matches) {
        throw new TypeError(`Cannot parse Range from &quot;${s}&quot;.`)
    }
    return new Range(parseInt(matches[1]), parseInt(matches[2]));
}
</code></pre>

<p>此代码定义的方法是 Range.parse()， 而不是 Range.prototype.parse()， 必须通过构造函数而不是通过实例调用它：</p>

<pre><code class="language-javascript">let r = Range.parse(&#39;(1...10)&#39;); // Returns a new Range object
r.parse(&#39;(1...10)&#39;);             // TypeError: r.parse is not a function
</code></pre>

<p>有时会看到静态方法称为类方法，因为它们是使用类/构造函数的名称调用的。使用此术语时，将类方法与在类实例上调用的常规实例方法进行对比，由于静态方法在构造函数上调用，而不是在任何特定实例上调用，因此在静态方法中使用 this 关键字几乎从来就没有意义。</p>

<p>我们将在示例 9-4 中看到静态方法的示例。</p>

<h3 id="toc_6">9.3.2 Getter、Setter 和其他方法</h3>

<p>在类正文中，可以定义 getter 和 setter 方法（§6.10.6），就像在对象字面量中一样。唯一的区别是，在类正文中，不会将逗号放在 getter 或 setter 之后。示例 9-4 包括类中 getter 方法的实际示例。</p>

<p>通常，对象字面量中允许的所有速记方法定义语法也允许在类正文中使用。这包括生成器方法（用 * 标记）和名称为方括号中表达式值的方法。事实上，已经看到了（在示例 9-3 中）具有计算名称的生成器方法，该方法使 Range 类可重复：</p>

<pre><code class="language-javascript">*[Symbol.iterator]() {
    for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
}
</code></pre>

<h3 id="toc_7">9.3.3 公有、私有和静态字段</h3>

<p>在此处对使用 class 关键字定义的类的讨论中，我们只描述了类正文中方法的定义。ES6 标准只允许创建方法（包括 getter、setter 和生成器）和静态方法；它不包括用于定义字段的语法。如果要在类实例上定义字段（这只是面向对象中&quot;属性&quot;的同义词），则必须在构造函数函数或其中一个方法中这样做。必须在类正文之外类定义后，才能为类定义静态字段。示例 9-4 包括这各种字段的示例。</p>

<p>但是，对于允许以公有和私有形式定义实例和静态字段的扩展类语法正在进行标准化。本节其余部分中显示的代码在 2020 年初还不是标准 JavaScript，但在 Chrome 中已经支持，并且 Firefox 中已部分支持（仅使公有实例字段）。使用 React 框架和 Babel 编译器的 JavaScript 程序员常用公有实例字段的语法。</p>

<p>假设你正在编写一个这样的类，其中一个构造函数初始化了三个字段：</p>

<pre><code class="language-javascript">class Buffer {
    constructor() {
        this.size = 0;
        this.capacity = 4096;
        this.buffer = new Uint8Array(this.capacity);
    }
}
</code></pre>

<p>使用可能标准化的新实例字段语法，可以这样编写：</p>

<pre><code class="language-javascript">class Buffer {
    size = 0;
    capacity = 4096;
    buffer = new Uint8Array(this.capacity);
}
</code></pre>

<p>字段初始化代码已移出构造函数，现在直接显示在类正文中。（当然，该代码仍作为构造函数的一部分运行。如果不定义构造函数，则字段初始化为隐式创建的构造函数的一部分。赋值左侧的 this. 前缀消失，但请注意即使是在初始化赋值的右侧，仍必须使用 this. 前缀引用这些字段。这种方式初始化实例字段的优点是，此语法允许（但不需要）将初始化放在类定义的顶部，使读者清楚地了解字段在每个实例将保存的状态。可以通过字段名后面跟一个分号来只声明不初始化一个字段。如果这样做，字段的初始值将是 undefined。显式设定初始化字段的值是比较好的风格。</p>

<p>在添加字段语法之前，类正文看起来很像使用快捷方法语法的对象字面量，只不过逗号被删除。字段语法（使用等号和分号代替冒号和逗号）清楚地表明类正文与对象字面量不完全相同。</p>

<p>标准化中的实例字段同时也定义了私有实例字段。如果使用上例中所示的实例字段初始化语法来定义其名称以 # 开头的字段（在 JavaScript 标识符中通常不是合法字符），则该字段在类正文中可用（使用 # 前缀），但对类正文之外的任何代码不可见且不可访问（因此不可变）。如果对于前面的 Buffer 类，要确保类的用户不会无意中修改实例的 size 字段，可以改为使用私有 #size 字段，然后定义 getter 函数以提供对值的只读访问：</p>

<pre><code class="language-javascript">class Buffer {
    #size = 0;
    get size() { return this.#size; }
}
</code></pre>

<p>请注意，必须先使用新字段语法声明私有字段，然后才能使用它们。你不能只在类的构造函数中写 <code>this.#size = 0;</code>，除非直接在类正文中包含字段的&quot;声明&quot;。</p>

<p>最后，在标准化过程中相关建议字段使用 static 关键字。如果在公有或私有字段声明之前添加静态字段，这些字段将创建为构造函数的属性，而不是实例的属性。思考我们定义的静态 Range.parse() 方法。它包括一个相当复杂的正则表达式，将其拆分到它自有的静态字段中可能会更好。使用建议的新静态字段语法，我们可以这编写：</p>

<pre><code class="language-javascript">static integerRangePattern = /^\((\d+)\.\.\.(\d+)\)$/;
static parse(s) {
    let matches = s.match(Range.integerRangePattern);
    if (!matches) {
        throw new TypeError(`Cannot parse Range from &quot;${s}&quot;.`)
    }
    return new Range(parseInt(matches[1]), matches[2]);
}
</code></pre>

<p>如果我们希望此静态字段只能在类中访问，我们可以使用像 #pattern 这样的名称将其私有化。</p>

<h3 id="toc_8">9.3.4 示例：一个复数类</h3>

<p>示例 9-4 定义了一个表示复数的类。该类相对简单，但它包括实例方法（包括 getters）、静态方法、实例字段和静态字段。它包括一些注释掉的代码，演示如何使用尚未加入标准的语法定义类正文中的实例字段和静态字段。</p>

<p>示例 9-4：Complex.js：一个复数类</p>

<pre><code class="language-javascript">/**
 * Instances of this Complex class represent complex numbers.
 * Recall that a complex number is the sum of a real number and an
 * imaginary number and that the imaginary number i is the square root of -1.
 */
class Complex {
    // Once class field declarations are standardized, we could declare
    // private fields to hold the real and imaginary parts of a complex number
    // here, with code like this:
    //
    // #r = 0;
    // #i = 0;

    // This constructor function defines the instance fields r and i on every
    // instance it creates. These fields hold the real and imaginary parts of
    // the complex number: they are the state of the object.
    constructor(real, imaginary) {
        this.r = real;       // This field holds the real part of the number.
        this.i = imaginary;  // This field holds the imaginary part.
    }

    // Here are two instance methods for addition and multiplication
    // of complex numbers. If c and d are instances of this class, we
    // might write c.plus(d) or d.times(c)
    plus(that) {
        return new Complex(this.r + that.r, this.i + that.i);
    }
    times(that) {
        return new Complex(this.r * that.r - this.i * that.i,
                           this.r * that.i + this.i * that.r);
    }

    // And here are static variants of the complex arithmetic methods.
    // We could write Complex.sum(c,d) and Complex.product(c,d)
    static sum(c, d) { return c.plus(d); }
    static product(c, d) { return c.times(d); }

    // These are some instance methods that are defined as getters
    // so they&#39;re used like fields. The real and imaginary getters would
    // be useful if we were using private fields this.#r and this.#i
    get real() { return this.r; }
    get imaginary() { return this.i; }
    get magnitude() { return Math.hypot(this.r, this.i); }

    // Classes should almost always have a toString() method
    toString() { return `{${this.r},${this.i}}`; }

    // It is often useful to define a method for testing whether
    // two instances of your class represent the same value
    equals(that) {
        return that instanceof Complex &amp;&amp;
            this.r === that.r &amp;&amp;
            this.i === that.i;
    }

    // Once static fields are supported inside class bodies, we could
    // define a useful Complex.ZERO constant like this:
    // static ZERO = new Complex(0,0);
}

// Here are some class fields that hold useful predefined complex numbers.
Complex.ZERO = new Complex(0,0);
Complex.ONE = new Complex(1,0);
Complex.I = new Complex(0,1);
</code></pre>

<p>定义了示例 9-4 的 Complex 类后，我们可以将构造函数、实例字段、实例方法、类字段和类方法如下使用：</p>

<pre><code class="language-javascript">let c = new Complex(2, 3);     // Create a new object with the constructor
let d = new Complex(c.i, c.r); // Use instance fields of c
c.plus(d).toString()           // =&gt; &quot;{5,5}&quot;; use instance methods
c.magnitude                    // =&gt; Math.hypot(2,3); use a getter function
Complex.product(c, d)          // =&gt; new Complex(0, 13); a static method
Complex.ZERO.toString()        // =&gt; &quot;{0,0}&quot;; a static property
</code></pre>

<h2 id="toc_9">9.4 为类添加方法</h2>

<p>JavaScript 基于原型的继承机制是动态的：对象从其原型继承属性，即使原型的属性在创建对象后发生更改。这意味着我们只需向原型对象添加新方法，即可扩展 JavaScript 类。</p>

<p>例如，下面是将计算共轭复数的方法添加到示例 9-4 的 Complex 类的代码：</p>

<pre><code class="language-javascript">// Return a complex number that is the complex conjugate of this one.
Complex.prototype.conj = function() { return new Complex(this.r, -this.i); };
</code></pre>

<p>JavaScript 类内置的原型对象也是这样展现的，这意味着我们可以向数字、字符串、数组、函数等添加方法。这对于在旧版本的语言中实现新特性非常有用：</p>

<pre><code class="language-javascript">// If the new String method startsWith() is not already defined...
if (!String.prototype.startsWith) {
    // ...then define it like this using the older indexOf() method.
    String.prototype.startsWith = function(s) {
        return this.indexOf(s) === 0;
    };
}
</code></pre>

<p>这是另外一个例子：</p>

<pre><code class="language-javascript">// Invoke the function f this many times, passing the iteration number
// For example, to print &quot;hello&quot; 3 times:
//     let n = 3;
//     n.times(i =&gt; { console.log(`hello ${i}`); });
Number.prototype.times = function(f, context) {
    let n = this.valueOf();
    for(let i = 0; i &lt; n; i++) f.call(context, i);
};
</code></pre>

<p>向这样在内置类型的原型添加方法通常被认为是一个坏主意，因为如果新版本的 JavaScript 定义具有相同名称的方法，将来就会造成混淆和兼容性问题。甚至可以向 Object.prototype 添加方法，使它们可作用于所有对象。但这从来就不是一件好事，因为添加到 Object.prototype 的属性对 for/in 循环可见（尽管可以使用 Object.defineProperty()（§14.1）来使新属性不可枚举来避免这种情况）。</p>

<h2 id="toc_10">9.5 子类</h2>

<p>在面向对象的编程中，B 类可以扩展 A 类或成为 A 类子类。我们称 A 是父类，B 是子类。B 的实例继承 A 的方法。B 类可以定义自有方法，使用相同名称可以重写类 A 中的方法。如果 B 的方法重写 A 方法，则 B 中的重写方法通常需要调用 A 中的重写方法。同样，子类构造函数 B() 通常必须调用父类构造函数 A()，以确保实例完全初始化。</p>

<p>本节首先演示 ES6 之前如何定义子类，然后演示使用 class 和 extends 关键字的子类和使用 super 关键字调用父类构造函数。再接下来一节是关于避免使用子类而依靠对象组合代替继承。本章最后结束于一个扩展的示例，定义 Set 类的层次结构和演示如何使用抽象类将接口与实现分离。</p>

<h3 id="toc_11">9.5.1 子类和原型</h3>

<p>假设我们想要给示例 9-2 中 Range 类定义 Span 子类。此子类的工作方式与 Range 一样，但我们初始化改为指定开始和范围，而不是制定开始和结束。Span 类的实例也是父类 Range 的实例。Span 实例从 Span.prototype 继承自定义的 toString() 方法，但为了成为 Range 的子类，它还必须从 Range.prototype 继承方法（如 includes()）。</p>

<p>实例 9-5：Span.js：Range 一个简单的子类</p>

<pre><code class="language-javascript">// This is the constructor function for our subclass
function Span(start, span) {
    if (span &gt;= 0) {
        this.from = start;
        this.to = start + span;
    } else {
        this.to = start;
        this.from = start + span;
    }
}

// Ensure that the Span prototype inherits from the Range prototype
Span.prototype = Object.create(Range.prototype);

// We don&#39;t want to inherit Range.prototype.constructor, so we
// define our own constructor property.
Span.prototype.constructor = Span;

// By defining its own toString() method, Span overrides the
// toString() method that it would otherwise inherit from Range.
Span.prototype.toString = function() {
    return `(${this.from}... +${this.to - this.from})`;
};
</code></pre>

<p>为了使 Span 成为 Range 的子类，我们需要使 Span.prototype 从 Range.prototype 继承。前面示例中的关键代码行是此代码行，如果能理解子类使如何工作的，它是非常有意义的：</p>

<pre><code class="language-javascript">Span.prototype = Object.create(Range.prototype);
</code></pre>

<p>使用 Span() 构造函数创建的对象将从 Span.prototype 对象继承。但是，我们创建了该对象并继承 Range.prototype，因此 Span 对象将同时从 Span.prototype 和 Range.prototype 继承。</p>

<p>可能会注意到，我们的 Span() 构造函数设置与 Range() 构造函数相同的 from 和 to 属性，因此不需要调用 Range() 构造函数来初始化新对象。同样，Span 的 toString() 方法完全重新实现字符串转换，而无需调用 Range 版本的 toString()。这使得 Span 成为特例，我们必须摆脱这种子类，因为这种情况是我们知道父类的实现细节。一个健壮的子类机制需要允许类调用其父类的方法和构造函数，但在 ES6 之前，JavaScript 没有一个简单的方法来执行这些操作。</p>

<p>幸运的是，ES6 用 super 关键字作为类语法一部分解决了这些问题。下一节演示它是如何工作的。</p>

<h3 id="toc_12">9.5.2 子类与 extends 和 super</h3>

<p>在 ES6 之后，可以简单的在类声明时接一个 extends 从句添加一个父类，即使对于内置类也可以这样做：</p>

<pre><code class="language-javascript">// A trivial Array subclass that adds getters for the first and last elements.
class EZArray extends Array {
    get first() { return this[0]; }
    get last() { return this[this.length-1]; }
}

let a = new EZArray();
a instanceof EZArray  // =&gt; true: a is subclass instance
a instanceof Array    // =&gt; true: a is also a superclass instance.
a.push(1,2,3,4);      // a.length == 4; we can use inherited methods
a.pop()               // =&gt; 4: another inherited method
a.first               // =&gt; 1: first getter defined by subclass
a.last                // =&gt; 3: last getter defined by subclass
a[1]                  // =&gt; 2: regular array access syntax still works.
Array.isArray(a)      // =&gt; true: subclass instance really is an array
EZArray.isArray(a)    // =&gt; true: subclass inherits static methods, too!
</code></pre>

<p>EZArray 子类定义了两个简单的 getter 方法。EZArray 实例的行为类似于普通数组，我们可以使用继承的方法和属性，如 push()、pop() 和 length。但是，我们也可以使用子类中定义的 first 和 last getter 方法。不仅继承实例方法如 pop() ，也继承 Array.isArray 等静态方法。这是 ES6 类语法启用的新特性：EZArray() 是一个函数，但它从 Array() 继承：</p>

<pre><code class="language-javascript">// EZArray inherits instance methods because EZArray.prototype
// inherits from Array.prototype
Array.prototype.isPrototypeOf(EZArray.prototype) // =&gt; true

// And EZArray inherits static methods and properties because
// EZArray inherits from Array. This is a special feature of the
// extends keyword and is not possible before ES6.
Array.isPrototypeOf(EZArray) // =&gt; true
</code></pre>

<p>EZArray 子类太简单了，没有教育意义。示例 9-6 是一个更充实的示例。它定义了内置 Map 类的 TypedMap 子类，该子类添加类型检查以确保映射的键和值是指定的类型（根据 typeof）。重要的是，此示例演示了使用 super 关键字来调用父类的构造函数和方法。</p>

<p>示例 9-6：TypedMap.js：一个检测 key 和 value 类型的 Map 子类</p>

<pre><code class="language-javascript">class TypedMap extends Map {
    constructor(keyType, valueType, entries) {
        // If entries are specified, check their types
        if (entries) {
            for(let [k, v] of entries) {
                if (typeof k !== keyType || typeof v !== valueType) {
                    throw new TypeError(`Wrong type for entry [${k}, ${v}]`);
                }
            }
        }

        // Initialize the superclass with the (type-checked) initial entries
        super(entries);

        // And then initialize this subclass by storing the types
        this.keyType = keyType;
        this.valueType = valueType;
    }

    // Now redefine the set() method to add type checking for any
    // new entries added to the map.
    set(key, value) {
        // Throw an error if the key or value are of the wrong type
        if (this.keyType &amp;&amp; typeof key !== this.keyType) {
            throw new TypeError(`${key} is not of type ${this.keyType}`);
        }
        if (this.valueType &amp;&amp; typeof value !== this.valueType) {
            throw new TypeError(`${value} is not of type ${this.valueType}`);
        }

        // If the types are correct, we invoke the superclass&#39;s version of
        // the set() method, to actually add the entry to the map. And we
        // return whatever the superclass method returns.
        return super.set(key, value);
    }
}
</code></pre>

<p>TypedMap() 构造函数的前两个实参是所需的键和值类型。这些实参应该是字符串，如&quot;number&quot;和&quot;boolean&quot;，这些字符串应该是 typeof 运算符的返回值。还可以指定第三个实参：指定 map 中初始条目的 [key,value] 数组（或任何可迭代对象）。如果指定任何初始条目，则构造函数要做的第一件事是验证其类型是否正确。接下来，构造函数调用父类构造函数，使用 super 关键字，就像它是一个函数名称一样。Map() 构造函数采用一个可选实参：可迭代对象 [key,value] 的数组。因此，TypedMap() 构造函数的第三个可选实参是 Map() 构造函数的第一个可选实参，我们用 <code>super(entries)</code> 将它传递给父类的构造函数。</p>

<p>调用父类构造函数初始化父类状态后，接下来 TypedMap() 构造函数初始化其自己的子类状态 this.keyType 和 this.valueType。它需要设置这些属性，以便它可以在 set() 方法中再次使用它们。</p>

<p>在构造函数中使用 super() 需要了解一些重要规则：</p>

<p>如果使用 extends 关键字定义类，则类的构造函数必须使用 super() 调用父类构造函数。</p>

<p>如果未在子类中定义构造函数，将自动为你定义一个构造函数。此隐式定义的构造函数只将传递给它值传递给 super()。</p>

<p>在使用 super() 调用父类构造函数之前，不能在构造函数中使用 this 关键字。这个强制规则确保父类先于子类初始化。</p>

<p>在未使用 new 关键字调用的函数中，new.target 表达式是 undefined。但是，在构造函数中，new.target 是引用调用的构造函数。当调用子类构造函数并使用 super() 调用父类构造函数时，该父类构造函数将看到子类构造函数作为 new.target 的值。虽然设计良好的父类不需要知道它是否有子类，但，在日志记录消息的场景中使用 new.target.name 会很有用。</p>

<p>在构造函数之后，示例 9-6 的下一部分是名为 set() 的方法。Map 父类定义了名为 set() 的方法，以向 Map 添加新条目。TypedMap 中的 set() 方法将重写其父类的 set() 方法。这个简单的 TypedMap 子类对向 Map 添加新条目一无所知，但它知道如何检查类型，因此它首先会这样做，验证要添加到地图中的键和值的类型是否正确，如果它们不正确则抛出异常。此 set() 方法无法将键和值添加到 Map 本身，但这就是父类 set() 方法的用途。因此，我们再次使用 super 关键字来调用父类版本的 set() 方法。在此上下文中，super 的工作方式与 this 关键字的工作方式非常相似：它引用当前对象，但允许访问在父级类中定义的被重写方法。</p>

<p>在构造函数中，需要先调用父类构造函数，然后才能访问 this 和初始化新对象。但重写方法时没有此类规则。调用重写父类方法时不需要调用父类方法。如果它确实使用 super 来调用父类中的重写方法（或任何方法），它可以在重写方法的开头、中间或末尾调用。</p>

<p>最后，在将 TypedMap 示例抛在脑后之前，值得注意的是，此类是使用私有字段的理想场景。现在编写类时，用户可以更改 keyType 或 valueType 属性以破坏类型检查。一旦支持私有字段，我们可以将这些属性改为 #keyType 和 #valueType，以便它们不能从外部更改。</p>

<h3 id="toc_13">9.5.3 委托代替继承</h3>

<p>extends 关键字便于创建子类。但这并不意味着应该创建大量的子类。如果要编写某些其他类共享的行为的类，可以尝试通过创建子类来继承该行为。但是，通常将期望的行为编写在类中比用类创建其他类的实例并根据需要委托给该实例更简单也更灵活。创建新类不将其作为子类，而是通过包装或&quot;组合&quot;其他类。这种委托方法通常称为&quot;组合&quot;，它是一种面向对象编程经常被引用的座右铭&quot;倾向于组合而不是继承&quot;。 <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p>

<p>例如，假设我们想要一个行为类似于 JavaScript 的 Set 类的 Histogram 类，只不过，它不只是跟踪是否给集合添加了值，还维护该值添加次数的计数。由于 Histogram 类的 API 与 Set 类似，因此我们可以考虑 Set 子类并添加 count() 方法。另一方面，一旦我们开始考虑如何实现 count() 方法，我们可能会意识到 Histogram 类更像是一个 Map 而不是一个 Set，因为它需要维护值与添加它们次数之间的映射。因此，我们可以创建一个类，该类定义一个类似 Set 的 API，但委托内部 Map 对象来实现这些方法，而不是创建 Set 的子类。示例 9-7 显示了我们如何做到这一点。</p>

<p>示例 9-7：Histogram.js：使用委托实现一个类似 Set 的类</p>

<pre><code class="language-javascript">/**
 * A Set-like class that keeps track of how many times a value has
 * been added. Call add() and remove() like you would for a Set, and
 * call count() to find out how many times a given value has been added.
 * The default iterator yields the values that have been added at least
 * once. Use entries() if you want to iterate [value, count] pairs.
 */
class Histogram {
    // To initialize, we just create a Map object to delegate to
    constructor() { this.map = new Map(); }

    // For any given key, the count is the value in the Map, or zero
    // if the key does not appear in the Map.
    count(key) { return this.map.get(key) || 0; }

    // The Set-like method has() returns true if the count is non-zero
    has(key) { return this.count(key) &gt; 0; }

    // The size of the histogram is just the number of entries in the Map.
    get size() { return this.map.size; }

    // To add a key, just increment its count in the Map.
    add(key) { this.map.set(key, this.count(key) + 1); }

    // Deleting a key is a little trickier because we have to delete
    // the key from the Map if the count goes back down to zero.
    delete(key) {
        let count = this.count(key);
        if (count === 1) {
            this.map.delete(key);
        } else if (count &gt; 1) {
            this.map.set(key, count - 1);
        }
    }

    // Iterating a Histogram just returns the keys stored in it
    [Symbol.iterator]() { return this.map.keys(); }

    // These other iterator methods just delegate to the Map object
    keys() { return this.map.keys(); }
    values() { return this.map.values(); }
    entries() { return this.map.entries(); }
}
</code></pre>

<p>在示例 9-7 中，Histogram() 构造函数创建一个 Map 对象。大多数方法都是单行，它们只是委托给 Map 的方法，使得实现变得非常简单。因为我们使用委托而不是继承，所以 Histogram 对象不是 Set 或 Map 的实例。但是，Histogram 实现了许多常用的 Set 方法，并没有过多的使用额外的 JavaScript，这通常足够好：有条理的继承关系有时是不错，但通常是可选的。</p>

<h3 id="toc_14">9.5.4 Hierarchies 类和抽象类</h3>

<p>示例 9-6 演示了如创建 Map 的子类。示例 9-7 演示了如何在不创建子类的情况下将委托给 Map 对象。使用 JavaScript 类封装数据和模块化代码通常是一种很好的技术，你可能会发现自己经常使用类关键字。但是，你可能会发现，你更喜欢组合而不是继承，而且很少需要使用 extends（除非使用需要扩展的库或框架）。</p>

<p>但是，在某些情况下，多个级别的子类是合适的，我们将举一个扩展示例来结束本章，通过描述不同种类的集合来演示类的层次结构。（示例 9-8 中定义的类跟 JavaScript 中的内置 Set 类很相似，但不完全兼容。）</p>

<p>示例 9-8 定义了大量子类，但它也演示了如何定义抽象类（不包括完整实现的类）作为一组相关子类的通用父类。抽象父类可以定义所有子类继承和共享的部分实现。因此，子类只需要通过实现父类定义的抽象方法（没有实现）来定义它们自己的独特行为。请注意，JavaScript 对抽象方法或抽象类没有任何正式定义；我只是将这个名字用于未实现的方法和不完全实现的类。</p>

<p>示例 9-8 评论良好，并且独立。我鼓励你把它作为本章关于类的顶级示例。示例 9-8 用 &amp;、| 和 ~ 运算符执行大量位操作，可以在 §4.8.3 中查看这些运算符。</p>

<p>示例 9-8：Sets.js：抽象类和实体类的层次</p>

<pre><code class="language-javascript">/**
 * The AbstractSet class defines a single abstract method, has().
 */
class AbstractSet {
    // Throw an error here so that subclasses are forced
    // to define their own working version of this method.
    has(x) { throw new Error(&quot;Abstract method&quot;); }
}

/**
 * NotSet is a concrete subclass of AbstractSet.
 * The members of this set are all values that are not members of some
 * other set. Because it is defined in terms of another set it is not
 * writable, and because it has infinite members, it is not enumerable.
 * All we can do with it is test for membership and convert it to a
 * string using mathematical notation.
 */
class NotSet extends AbstractSet {
    constructor(set) {
        super();
        this.set = set;
    }

    // Our implementation of the abstract method we inherited
    has(x) { return !this.set.has(x); }
    // And we also override this Object method
    toString() { return `{ x| x ∉ ${this.set.toString()} }`; }
}

/**
 * Range set is a concrete subclass of AbstractSet. Its members are
 * all values that are between the from and to bounds, inclusive.
 * Since its members can be floating point numbers, it is not
 * enumerable and does not have a meaningful size.
 */
class RangeSet extends AbstractSet {
    constructor(from, to) {
        super();
        this.from = from;
        this.to = to;
    }

    has(x) { return x &gt;= this.from &amp;&amp; x &lt;= this.to; }
    toString() { return `{ x| ${this.from} ≤ x ≤ ${this.to} }`; }
}

/*
 * AbstractEnumerableSet is an abstract subclass of AbstractSet.  It defines
 * an abstract getter that returns the size of the set and also defines an
 * abstract iterator. And it then implements concrete isEmpty(), toString(),
 * and equals() methods on top of those. Subclasses that implement the
 * iterator, the size getter, and the has() method get these concrete
 * methods for free.
 */
class AbstractEnumerableSet extends AbstractSet {
    get size() { throw new Error(&quot;Abstract method&quot;); }
    [Symbol.iterator]() { throw new Error(&quot;Abstract method&quot;); }

    isEmpty() { return this.size === 0; }
    toString() { return `{${Array.from(this).join(&quot;, &quot;)}}`; }
    equals(set) {
        // If the other set is not also Enumerable, it isn&#39;t equal to this one
        if (!(set instanceof AbstractEnumerableSet)) return false;

        // If they don&#39;t have the same size, they&#39;re not equal
        if (this.size !== set.size) return false;

        // Loop through the elements of this set
        for(let element of this) {
            // If an element isn&#39;t in the other set, they aren&#39;t equal
            if (!set.has(element)) return false;
        }

        // The elements matched, so the sets are equal
        return true;
    }
}

/*
 * SingletonSet is a concrete subclass of AbstractEnumerableSet.
 * A singleton set is a read-only set with a single member.
 */
class SingletonSet extends AbstractEnumerableSet {
    constructor(member) {
        super();
        this.member = member;
    }

    // We implement these three methods, and inherit isEmpty, equals()
    // and toString() implementations based on these methods.
    has(x) { return x === this.member; }
    get size() { return 1; }
    *[Symbol.iterator]() { yield this.member; }
}

/*
 * AbstractWritableSet is an abstract subclass of AbstractEnumerableSet.
 * It defines the abstract methods insert() and remove() that insert and
 * remove individual elements from the set, and then implements concrete
 * add(), subtract(), and intersect() methods on top of those. Note that
 * our API diverges here from the standard JavaScript Set class.
 */
class AbstractWritableSet extends  AbstractEnumerableSet {
    insert(x) { throw new Error(&quot;Abstract method&quot;); }
    remove(x) { throw new Error(&quot;Abstract method&quot;); }

    add(set) {
        for(let element of set) {
            this.insert(element);
        }
    }

    subtract(set) {
        for(let element of set) {
            this.remove(element);
        }
    }

    intersect(set) {
        for(let element of this) {
            if (!set.has(element)) {
                this.remove(element);
            }
        }
    }
}

/**
 * A BitSet is a concrete subclass of AbstractWritableSet with a
 * very efficient fixed-size set implementation for sets whose
 * elements are non-negative integers less than some maximum size.
 */
class BitSet extends AbstractWritableSet {
    constructor(max) {
        super();
        this.max = max;  // The maximum integer we can store.
        this.n = 0;      // How many integers are in the set
        this.numBytes = Math.floor(max / 8) + 1;   // How many bytes we need
        this.data = new Uint8Array(this.numBytes); // The bytes
    }

    // Internal method to check if a value is a legal member of this set
    _valid(x) { return Number.isInteger(x) &amp;&amp; x &gt;= 0 &amp;&amp; x &lt;= this.max; }

    // Tests whether the specified bit of the specified byte of our
    // data array is set or not. Returns true or false.
    _has(byte, bit) { return (this.data[byte] &amp; BitSet.bits[bit]) !== 0; }

    // Is the value x in this BitSet?
    has(x) {
        if (this._valid(x)) {
            let byte = Math.floor(x / 8);
            let bit = x % 8;
            return this._has(byte, bit);
        } else {
            return false;
        }
    }

    // Insert the value x into the BitSet
    insert(x) {
        if (this._valid(x)) {               // If the value is valid
            let byte = Math.floor(x / 8);   // convert to byte and bit
            let bit = x % 8;
            if (!this._has(byte, bit)) {    // If that bit is not set yet
                this.data[byte] |= BitSet.bits[bit]; // then set it
                this.n++;                            // and increment set size
            }
        } else {
            throw new TypeError(&quot;Invalid set element: &quot; + x );
        }
    }

    remove(x) {
        if (this._valid(x)) {              // If the value is valid
            let byte = Math.floor(x / 8);  // compute the byte and bit
            let bit = x % 8;
            if (this._has(byte, bit)) {    // If that bit is already set
                this.data[byte] &amp;= BitSet.masks[bit];  // then unset it
                this.n--;                              // and decrement size
            }
        } else {
            throw new TypeError(&quot;Invalid set element: &quot; + x );
        }
    }

    // A getter to return the size of the set
    get size() { return this.n; }

    // Iterate the set by just checking each bit in turn.
    // (We could be a lot more clever and optimize this substantially)
    *[Symbol.iterator]() {
        for(let i = 0; i &lt;= this.max; i++) {
            if (this.has(i)) {
                yield i;
            }
        }
    }
}

// Some pre-computed values used by the has(), insert() and remove() methods
BitSet.bits = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
BitSet.masks = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~128]);
</code></pre>

<h2 id="toc_15">9.6 总结</h2>

<p>本章说明了 JavaScript 类的主要功能：</p>

<ul>
<li>同一类的成员对象从同一原型对象继承属性。原型对象是 JavaScript 类的关键特性，只有 Object.create() 方法可以定义类。</li>
<li>在 ES6 之前，典型的类定义先定义构造函数。使用 function 关键字创建的函数具有原型属性，this 属性的值是使用 new 将函数用作构造函数调用时创建的对象的原型对象。通过初始化此原型对象，可以定义类的共享方法。虽然原型对象是类的关键特性，但构造函数是类的公共标识。</li>
<li>ES6 引入了一个 class 关键字，它使定义类更加容易，但它只是个语法糖，构造函数和原型机制保持不变。</li>
<li>子类使用类声明中的 extends 关键字定义。</li>
<li>子类可以使用 super 关键字调用其父类的构造函数或父类的重写方法。</li>
</ul>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>例如，见《Design Patterns (Addison-Wesley Professional)》作者 Erich Gamma 等，或者《Effective Java (Addison-Wesley Professional)》作者 Joshua Bloch。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 原型和原型链]]></title>
    <link href="2019919.xyz/16080322533005.html"/>
    <updated>2020-12-15T19:37:33+08:00</updated>
    <id>2019919.xyz/16080322533005.html</id>
    <content type="html"><![CDATA[
<p>今天刚开始学习【重学前端】的课程，讲到装箱转换的时候提到了函数的 call 方法，而 call 方法在我的印象中就只有 call 约等于 apply ，然后就再没有然后了。在我想深入了解下 call 方法的时候又发现了有人在同时讲解原型，而于此同时我看到了知乎上的一个贴<a href="https://www.zhihu.com/question/60165921">面试一个5年的前端，却连原型链也搞不清楚，满口都是Vue，React之类的实现，这样的人该用吗？</a>，这我不看内容我就惊呆了，这标题不就是在说我吗。带着各种心情赶紧学习下到底什么是原型和原型链。</p>

<h2 id="toc_0">原型</h2>

<pre><code class="language-text">prototype  [ˈproʊtətaɪp]  原型
</code></pre>

<p>OK完了😊！</p>

<p>下面这个图很多大神都有画过，下面记录下我自己的理解和实验。</p>

<p><img src="media/16080322533005/16080400429560.jpg" alt="" style="width:450px;"/></p>

<h3 id="toc_1">构造函数视角</h3>

<p>函数可以用来做构造器，也就是 constructor，而构造器也可以称为类。<br/>
通过构造器 Apple 来创建一个对象对象 apple。</p>

<p><img src="media/16080322533005/16080397593797.jpg" alt="" style="width:198px;"/></p>

<p><strong>构造函数创建了实例对象</strong>，这是构造函数与实例对象的关系。</p>

<hr/>

<p><strong>构造函数有一个属性叫做 propotype，他指向了原型对象。</strong></p>

<p><img src="media/16080322533005/16080405364424.jpg" alt="" style="width:299px;"/></p>

<p>这里的原型对象写做 [[propotype]]，这里我猜测是为了区分propotype的属性。</p>

<h3 id="toc_2">原型对象视角</h3>

<p><strong>原型对象的 constructor 属性指向了构造函数</strong>。</p>

<p><img src="media/16080322533005/16080407735350.jpg" alt="" style="width:382px;"/></p>

<p>这里用构造器的原型对象的 constructor 方法来创建一个 badApple ，会发现它和 apple 的类型是相等的。</p>

<h3 id="toc_3">实例对象视角</h3>

<p>对象也有一个属性 __propo__，这是一个隐式属性，<strong>对象的 __propo__ 指向了他的构造函数的原型对象。</strong>也就是说 Apple 的 propotype 属性和 apple、badApple 的 __propo__ 指向了同一个地址。</p>

<p><img src="media/16080322533005/16080419126552.jpg" alt="" style="width:318px;"/></p>

<h3 id="toc_4">由函数引出原型链</h3>

<p>函数是 JS 中的第一类对象，在 Javascript 中，对象所拥有的函数也同样拥有，也就是说构造函数 Apple 也同样会有 __propo__ 属性去指向他的父类的原型对象，为了理清这乱七八糟的关系，就有了下面“对象-函数-构造函数-实例对象”这样的一个关系图，也就是原型链图。</p>

<h2 id="toc_5">原型链</h2>

<p><img src="media/16080322533005/16080423510561.jpg" alt=""/></p>

<p>这张图理解了上面的内容之后就感觉容易多了，总结一下有以下几点需要注意。</p>

<ul>
<li>任何函数的父类都是 Function 构造函数，也就是任何函数的 __proto__ 指向 Function.prototype，这里同样包含了 Function 构造函数自己。</li>
<li>Object 构造函数它也是函数，它的的 __proto__ 也指向 Function.prototype。</li>
<li>Function.prototype 的 __proto__ 指向 Object.prototype，这也就是为什么说函数也是对象。</li>
<li>Object.prototype 的 __proto__ 是 null。</li>
</ul>

<h2 id="toc_6"> ES6 中的类</h2>

<p>类的写法也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性会被卸载原型对象之上。此外最重要的是类提供了继承能力。</p>

<pre><code class="language-javascript">class Animal { 
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(this.name + &#39; makes a noise.&#39;);
  }
}
class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }
  speak() {
    console.log(this.name + &#39; barks.&#39;);
  }
}
let d = new Dog(&#39;Mitzie&#39;);
d.speak(); // Mitzie barks.
</code></pre>

<p>以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p>

<blockquote>
<p>super 关键字用于访问和调用一个对象的父对象上的函数。<br/>
在构造函数中使用时，super关键字将单独出现，并且必须在使用this关键字之前使用。</p>
</blockquote>

<pre><code class="language-javascript">super([arguments]);
// 调用 父对象/父类 的构造函数
super.functionOnParent([arguments]);
// 调用 父对象/父类 上的方法
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 10 章 模块]]></title>
    <link href="2019919.xyz/16130963383709.html"/>
    <updated>2021-02-12T10:18:58+08:00</updated>
    <id>2019919.xyz/16130963383709.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">10.1 类、对象和闭包充当模块</a>
<ul>
<li>
<a href="#toc_1">10.1.1 基于闭包的自动模块化</a>
</li>
</ul>
</li>
<li>
<a href="#toc_2">10.2 Node 中的模块</a>
<ul>
<li>
<a href="#toc_3">10.2.1 Node Exports</a>
</li>
<li>
<a href="#toc_4">10.2.2 Node Imports</a>
</li>
<li>
<a href="#toc_5">10.2.3 Web 中的 Node 风格模块</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">10.3 ES6 中的模块</a>
<ul>
<li>
<a href="#toc_7">10.3.1 ES6 导出</a>
</li>
<li>
<a href="#toc_8">10.3.2 ES6 导入</a>
</li>
<li>
<a href="#toc_9">10.3.3 导入导出重命名</a>
</li>
<li>
<a href="#toc_10">10.3.4 再导出</a>
</li>
<li>
<a href="#toc_11">10.3.5 JavaScript Modules on the Web</a>
</li>
<li>
<a href="#toc_12">10.3.6 Dynamic Imports with import()</a>
</li>
<li>
<a href="#toc_13">10.3.7 import.meta.url</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">10.4 Summary</a>
</li>
</ul>


<p>模块化编程的目标是允许使用来自不同作者和源的代码模块来组装大型程序，并且即使出现了不同模块作者没有预料到的代码，所有这些代码也能正确运行。作为一个实际问题，模块化主要是关于封装或隐藏私有实现细节和保持全局名称空间整洁，以便模块不会意外地修改其他模块定义的变量、函数和类。</p>

<p>直到最近，JavaScript 还没有对模块的内置支持，在大型代码库上工作的程序员尽力使用类、对象和闭包的弱模块性。基于闭包的模块化在代码捆绑工具的支持下，实际使用中形成了一种基于 require() 函数的模块化形式，Node 采用了这种形式。基于 require() 的模块是 Node 编程环境的基本部分，但从未被作为 JavaScript 语言的正式部分采用。相反，ES6 使用 import 和 import 关键字定义模块。虽然 import 和 export 已经成为语言的一部分很多年了，但是它们只是最近才被 web 浏览器和 Node 实现。而且，作为一个实际问题，JavaScript 模块化仍然依赖于代码捆绑工具。</p>

<p>以下各节包括:</p>

<ul>
<li>使用类、对象和闭包自己做模块</li>
<li>使用 require() 的 Node 模块</li>
<li>使用 export、import 和 import() 的ES6模块</li>
</ul>

<h2 id="toc_0">10.1 类、对象和闭包充当模块</h2>

<p>尽管这可能很明显，但值得指出的是，类的重要特性之一是它们充当其方法的模块。回想一下示例 9-8。该示例定义了许多不同的类，所有这些类都有一个名为 has() 的方法。但是，在编写使用该示例中的多个 set 类的程序时没有问题：例如，SingletonSet 的 has() 实现不会覆盖 BitSet 的 has() 方法。</p>

<p>一个类的方法独立于其他不相关类的方法的原因是，每个类的方法都被定义为独立原型对象的属性。类是模块化的原因是对象是模块化的：在 JavaScript 对象中定义属性非常类似于声明变量，但是向对象添加属性不会影响程序的全局命名空间，也不会影响其他对象的属性。JavaScript 定义了很多数学函数和常量，但它们不是全局定义的，而是分组为 Math 全局对象的单个属性。同样的技术也可以用在示例 9-8 中。不使用 SingletonSet 和 BitSet 这样的名称定义全局类，这个示例可以编写为只有一个 Sets 全局对象，Sets 的属性引用各种类。然后，用户可以使用这个 Sets 库通过 Sets.Singleton 和 Sets.Bit 的名称来获取类的引用。</p>

<p>使用类和对象实现模块化是 JavaScript 编程中常见而有用的技术，但这还不够。特别是，它没有提供任何方法来隐藏模块内部的实现细节。再次考虑示例 9-8。如果我们将该示例作为一个模块来编写，也许我们会希望将各种抽象类保留在模块内部，只让具体的子类对模块的用户可用。同样，在 BitSet 类中，_valid() 和 _has() 方法是内部实用程序，不应该向类的用户公开它们。BitSet.bits 和 BitSet.masks 是实现细节，最好隐藏起来。</p>

<p>正如我们在 §8.6 中看到的，在函数中声明的局部变量和嵌套函数是该函数私有的。这意味着我们可以使用立即调用函数表达式来实现一种模块化，方法是将实现细节和实用函数隐藏在封装的函数中，而将模块的公共 API 作为函数的返回值。在 BitSet 类的情况下，我们可以像这样构造模块:</p>

<pre><code class="language-javascript">const BitSet = (function() { // Set BitSet to the return value of this function
    // Private implementation details here
    function isValid(set, n) { ... }
    function has(set, byte, bit) { ... }
    const BITS = new Uint8Array([1, 2, 4, 8, 16, 32, 64, 128]);
    const MASKS = new Uint8Array([~1, ~2, ~4, ~8, ~16, ~32, ~64, ~128]);

    // The public API of the module is just the BitSet class, which we define
    // and return here. The class can use the private functions and constants
    // defined above, but they will be hidden from users of the class
    return class BitSet extends AbstractWritableSet {
        // ... implementation omitted ...
    };
}());
</code></pre>

<p>当模块中有多个条目时，这种模块化方法就变得更有趣了。例如，下面的代码定义了一个迷你统计模块，它导出 mean() 和 stddev() 函数，同时隐藏实现细节:</p>

<pre><code class="language-javascript">// This is how we could define a stats module
const stats = (function() {
    // Utility functions private to the module
    const sum = (x, y) =&gt; x + y;
    const square = x =&gt; x * x;

    // A public function that will be exported
    function mean(data) {
        return data.reduce(sum)/data.length;
    }

    // A public function that we will export
    function stddev(data) {
        let m = mean(data);
        return Math.sqrt(
            data.map(x =&gt; x - m).map(square).reduce(sum)/(data.length-1)
        );
    }

    // We export the public function as properties of an object
    return { mean, stddev };
}());

// And here is how we might use the module
stats.mean([1, 3, 5, 7, 9])   // =&gt; 5
stats.stddev([1, 3, 5, 7, 9]) // =&gt; Math.sqrt(10)
</code></pre>

<h3 id="toc_1">10.1.1 基于闭包的自动模块化</h3>

<p>请注意，通过在文件的开头和结尾插入一些文本来将 JavaScript 代码文件转换为这种模块是相当机械的过程。所需要做的只是为 JavaScript 代码文件提供一些约定，以指示要导出的值和不导出的值。</p>

<p>想象一下一个工具，它需要一组文件，将每个文件的内容包装在立即调用的函数表达式中，跟踪每个函数的返回值，并将所有内容连接到一个大文件中。结果可能看起来像这样：</p>

<pre><code class="language-javascript">const modules = {};
function require(moduleName) { return modules[moduleName]; }

modules[&quot;sets.js&quot;] = (function() {
    const exports = {};

    // The contents of the sets.js file go here:
    exports.BitSet = class BitSet { ... };

    return exports;
}());

modules[&quot;stats.js&quot;] = (function() {
    const exports = {};

    // The contents of the stats.js file go here:
    const sum = (x, y) =&gt; x + y;
    const square = x = &gt; x * x;
    exports.mean = function(data) { ... };
    exports.stddev = function(data) { ... };

    return exports;
}());
</code></pre>

<p>如上一个示例所示，将模块捆绑到单个文件中，可以想象编写如下代码来利用这些模块：</p>

<pre><code class="language-javascript">// Get references to the modules (or the module content) that we need
const stats = require(&quot;stats.js&quot;);
const BitSet = require(&quot;sets.js&quot;).BitSet;

// Now write code using those modules
let s = new BitSet(100);
s.insert(10);
s.insert(20);
s.insert(30);
let average = stats.mean([...s]); // average is 20
</code></pre>

<p>这段代码概述了用于网络浏览器的代码捆绑工具（例如 webpack 和 Parcel）的工作方式，并且是对 require() 函数（如 Node 程序中使用的函数）的简单介绍。</p>

<h2 id="toc_2">10.2 Node 中的模块</h2>

<p>In Node programming, it is normal to split programs into as many files as seems natural. These files of JavaScript code are assumed to all live on a fast filesystem. Unlike web browsers, which have to read files of JavaScript over a relatively slow network connection, there is no need or benefit to bundling a Node program into a single JavaScript file.</p>

<p>In Node, each file is an independent module with a private namespace. Constants, variables, functions, and classes defined in one file are private to that file unless the file exports them. And values exported by one module are only visible in another module if that module explicitly imports them.</p>

<p>Node modules import other modules with the require() function and export their public API by setting properties of the Exports object or by replacing the module.exportsobject entirely.</p>

<h3 id="toc_3">10.2.1 Node Exports</h3>

<p>Node defines a global exports object that is always defined. If you are writing a Node module that exports multiple values, you can simply assign them to the properties of this object:</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; x + y;
const square = x =&gt; x * x;

exports.mean = data =&gt; data.reduce(sum)/data.length;
exports.stddev = function(d) {
    let m = exports.mean(d);
    return Math.sqrt(d.map(x =&gt; x - m).map(square).reduce(sum)/(d.length-1));
};
</code></pre>

<p>Often, however, you want to define a module that exports only a single function or class rather than an object full of functions or classes. To do this, you simply assign the single value you want to export to module.exports:</p>

<pre><code class="language-javascript">module.exports = class BitSet extends AbstractWritableSet {
    // implementation omitted
};
</code></pre>

<p>The default value of module.exports is the same object that exports refers to. In the previous stats module, we could have assigned the mean function to module.exports.mean instead of exports.mean. Another approach with modules like the stats module is to export a single object at the end of the module rather than exporting functions one by one as you go:</p>

<pre><code class="language-javascript">// Define all the functions, public and private
const sum = (x, y) =&gt; x + y;
const square = x =&gt; x * x;
const mean = data =&gt; data.reduce(sum)/data.length;
const stddev = d =&gt; {
    let m = mean(d);
    return Math.sqrt(d.map(x =&gt; x - m).map(square).reduce(sum)/(d.length-1));
};

// Now export only the public ones
module.exports = { mean, stddev };
</code></pre>

<h3 id="toc_4">10.2.2 Node Imports</h3>

<p>A Node module imports another module by calling the require() function. The argument to this function is the name of the module to be imported, and the return value is whatever value (typically a function, class, or object) that module exports.</p>

<p>If you want to import a system module built in to Node or a module that you have installed on your system via a package manager, then you simply use the unqualified name of the module, without any “/” characters that would turn it into a filesystem path:</p>

<pre><code class="language-javascript">// These modules are built in to Node
const fs = require(&quot;fs&quot;);           // The built-in filesystem module
const http = require(&quot;http&quot;);       // The built-in HTTP module

// The Express HTTP server framework is a third-party module.
// It is not part of Node but has been installed locally
const express = require(&quot;express&quot;);
</code></pre>

<p>When you want to import a module of your own code, the module name should be the path to the file that contains that code, relative to the current module’s file. It is legal to use absolute paths that begin with a / character, but typically, when importing modules that are part of your own program, the module names will begin with ./ or sometimes ../ to indicate that they are relative to the current directory or the parent directory. For example:</p>

<pre><code class="language-javascript">const stats = require(&#39;./stats.js&#39;);
const BitSet = require(&#39;./utils/bitset.js&#39;);
</code></pre>

<p>(You can also omit the .js suffix on the files you’re importing and Node will still find the files, but it is common to see these file extensions explicitly included.)</p>

<p>When a module exports just a single function or class, all you have to do is require it. When a module exports an object with multiple properties, you have a choice: you can import the entire object, or just import the specific properties (using destructuring assignment) of the object that you plan to use. Compare these two approaches:</p>

<pre><code class="language-javascript">// Import the entire stats object, with all of its functions
const stats = require(&#39;./stats.js&#39;);

// We&#39;ve got more functions than we need, but they&#39;re neatly
// organized into a convenient &quot;stats&quot; namespace.
let average = stats.mean(data);

// Alternatively, we can use idiomatic destructuring assignment to import
// exactly the functions we want directly into the local namespace:
const { stddev } = require(&#39;./stats.js&#39;);

// This is nice and succinct, though we lose a bit of context
// without the &#39;stats&#39; prefix as a namspace for the stddev() function.
let sd = stddev(data);
</code></pre>

<h3 id="toc_5">10.2.3 Web 中的 Node 风格模块</h3>

<p>Node 中内置了带有 Exports 对象和 require() 函数的模块。 但是，如果要使用诸如 webpack 之类的捆绑工具来处理代码，则也可以将这种样式的模块用于要在网络浏览器中运行的代码。直到最近，这还是一种非常常用的做法，可能会看到很多基于 Web 的代码仍然这样做。</p>

<p>现在，JavaScript 具有自己的标准模块语法，但是使用捆绑程序的开发人员更喜欢将正式的 JavaScript 模块与 import 和 export 语句一起使用。</p>

<h2 id="toc_6">10.3 ES6 中的模块</h2>

<p>ES6 给 JavaScript 添加了 import 和 export 关键字，并且最终支持真正的模块化，将其作为核心语言特性。ES6 模块化概念上和 Node 的模块化相同：每个文件是它们自己的模块，定义在文件中的常量、变量、函数和类是模块私有成员，除非它们是被显示导出。</p>

<p>首先，请注意，ES6 模块在某些重要方面也与常规 JavaScript “脚本”不同。最明显的区别是模块化本身：在常规脚本中，变量，函数和类的顶级声明在所有脚本共享的一个全局上下文中。模块每个文件都有其自己的专用上下文，并且可以使用 import 和 export 语句。但是模块和脚本之间也存在其他差异。ES6 模块内的代码（类似 ES6 类内定义的代码）将自动进入严格模式（请参见 §5.6.3）。这意味着，当使用 ES6 模块时，无需再写“use strict”。这意味着模块中的代码不能使用 with 语句或 arguments 对象或未声明的变量。ES6 模块甚至比严格模式稍微严格：在严格模式下，在作为函数调用的函数中，this 是 undefined。在模块中，this 在顶层代码中也是 undefined。（相比之下，Web 浏览器和 Node 中的脚本将 this 设置为全局对象。）</p>

<p><strong>WEB 和 NODE 中的 ES6 模块</strong></p>

<p>ES6模块在诸如 webpack 之类的代码打包器的帮助下已在 Web 上使用多年，该打包器将 JavaScript 代码的独立模块组合成适合于包含在网页中的大型非模块化捆绑包。但是，在撰写本文时，除 Internet Explorer 之外，所有 Web 浏览器都支持 ES6 模块。本地使用时，ES6 模块通过特殊的 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签添加到HTML页面中，本章稍后将进行介绍。</p>

<p>同时，由于拥有 JavaScript 模块化的先驱，Node 处于必须支持两个不完全兼容的模块系统的尴尬境地。Node 13 支持 ES6 模块，但是到目前为止，绝大多数 Node 程序仍在使用 Node 模块。</p>

<h3 id="toc_7">10.3.1 ES6 导出</h3>

<p>要从 ES6 模块导出常量，变量，函数或类，只需在声明之前添加关键字 export：</p>

<pre><code class="language-javascript">export const PI = Math.PI;

export function degreesToRadians(d) { return d * PI / 180; }

export class Circle {
    constructor(r) { this.r = r; }
    area() { return PI * this.r * this.r; }
}
</code></pre>

<p>作为在整个模块中散播 export 关键字的替代方法，可以像平常一样定义常量、变量、函数和类，无需导出语句，然后（通常在模块末尾）编写一个导出语句，在一个位置精确的声明要导出的所有内容。因此，我们可以在末尾写入一行代码，而不是在上述代码中编写三个单独的导出：</p>

<pre><code class="language-javascript">export { Circle, degreesToRadians, PI };
</code></pre>

<p>这种语法看起来像导出关键字，后跟对象字面量（使用速记符号）。但在这种情况下，花括号实际上并不是定义对象字面量。此导出语法只需要在大括号中的标识符列表用逗号分隔。</p>

<p>编写只导出一个值（通常是一个函数或类）的模块是很常见的，在这种情况下，我们通常使用 export default 而不是 export：</p>

<pre><code class="language-javascript">export default class BitSet {
    // implementation omitted
}
</code></pre>

<p>默认导出比非默认导出更容易导入，因此，当只有一个导出值时，使用默认导出可以使模块的使用更容易。</p>

<p>带 export 的常规导出只能在具有名称的声明上进行。export default 默认导出可以导出任何表达式，包括匿名函数表达式和匿名类表达式。这意味着，如果使用默认导出，则可以导出对象字面量。因此，与导出语法不同，如果在默认导出后看到花括号，则它实际上是要导出的对象字面量。</p>

<p>同时有 export 和 export default 的模块是合法的，但是不常用。如果模块的默认导出最多仅有一个。</p>

<p>最后，请注意 export 关键字只能出现在 JavaScript 代码的顶层。 不能从类，函数，循环或条件内导出值。（这是 ES6 模块系统的重要特性，并且可以进行静态分析：每次运行时模块导出都是相同的，并且可以在模块实际运行之前确定导出的符号。）</p>

<h3 id="toc_8">10.3.2 ES6 导入</h3>

<p>使用 import 关键字导入其他模块导出的值。最简单的导入形式是导入默认导出定义的模块：</p>

<pre><code class="language-javascript">import BitSet from &#39;./bitset.js&#39;;
</code></pre>

<p>import 关键字后面跟一个标识符，然后是 from 关键字，后接要导入的默认导出字符串字面量模块名称。模块指定的默认导出值将编程当前模块内指定的标识符的值。</p>

<p>赋导入值的标识符是一个常量，就像它使用了 const 关键字声明一样。和导出一样，只能在模块的顶层导入，不能在类、函数、循环或条件中导入。根据近似通用规约，需要在模块的开头进行模块导入。但有趣的是，这不是必须的：就像函数声明，导入“提前”到顶部，所有的导入值在整个模块代码中运行时可以使用。</p>

<p>被导入的模块用单引号或双引号括上的字符串字面量常量指定。（不可以使用变量或其他值为字符串的表达式，也不可以使用带反引号的字符串，因为模板字面量可以插入变量，它不总是一个常量值。）在 Web 浏览器中，字符串像 URL 一样描述导入模块的相对位置。（在 Node中，或者使用代码捆绑工具时，字符串描述一个对于当前模块的相对文件名，这在事件中略有不同。）以“/”开始的模块指定字符串时绝对路径，“./”和“../”开头的是相对路径，或者是带有协议和主机名的完整 URL。ES6 明确规定不允许使用诸如“util.js”这样的不合规范的字符串，因为它是否是相对路径还是绝对路径上有歧义。（诸如 webpack 之类的代码捆绑工具不能满足对“裸模块说明符”的这种限制，可以将其轻松配置为在指定的库中查找裸模块。）未来版本 JavaScript 可能允许使用“裸模块说明符”，但目前不允许这样做。 如果要从与当前目录相同的目录中导入模块，只需在模块名称前放置“./”，然后从“./util.js”而不是“ util.js”导入。</p>

<p>到目前为止，我们仅考虑了从使用默认导出的模块中导入单个值的情况。要从导出多个值的模块导入值，我们使用略有不同的语法：</p>

<pre><code class="language-javascript">import { mean, stddev } from &quot;./stats.js&quot;;
</code></pre>

<p>回想一下，默认导出不需要在定义它们的模块中具有名称。而是在导入这些值时提供一个本地名称。但是，模块的非默认导出在导出模块中具有名称，并且当我们导入这些值时，我们通过这些名称来引用它们。导出模块可以导出任意数量的命名值。导入语句引用模块，可以简单地通过在花括号中列出它们的名称来导入这些名称对应的值的任何子集。花括号使这种导入语句看起来像是一个解构赋值，而解构赋值实际上是很好的案例来解释导入的这种风格。花括号中的标识符都被提前到导入模块的顶部，并且行为如同常量。</p>

<p>有时，风格指南建议显示导入模块将使用的每个符号。但是，从定义许多导出的模块进行导入时，可以使用如下的 import 语句轻松导入所有内容：</p>

<pre><code class="language-javascript">import * as stats from &quot;./stats.js&quot;;
</code></pre>

<p>像这样的导入语句创建一个对象并将其赋值给一个名为 stats 的常量。模块中每一个非默认导出被导入成 stats 对象的一个属性。非默认导出始终有名称，在对象中它们被用作属性名。那些属性实际上是常量：它们不能被重写或删除。通过前面例子中展示的通配符导入，导入的模块通过 stats 对象使用 mean() 和 stddev() 函数，用 stats.mean() 和 stats.stddev() 来调用它们。</p>

<p>模块通常定义一个默认导出或者多个命名导出。模块内同时使用导出和默认导出是合法的，但是不常见。但是当一个模块这样做了，可以通过下面这种方式将默认值和命名值通过一个导入语句导入：</p>

<pre><code class="language-javascript">import Histogram, { mean, stddev } from &quot;./histogram-stats.js&quot;;
</code></pre>

<p>到目前为止，我们已经了解了如何从具有默认导出的模块以及具有非默认或命名导出的模块导入。但是 import 语句还有另一种形式，可以用于没有导出的模块。要将无导出模块包含到程序中，只需使用 import 关键字和模块说明符：</p>

<pre><code class="language-javascript">import &quot;./analytics.js&quot;;
</code></pre>

<p>这样的模块在首次运行时导入。（并且随后的导入不执行任何操作。）仅定义函数的模块只有在导出至少一个函数时才有用。但是，如果模块运行一些代码，那么即使没有符号也可以导入。Web 应用程序的分析模块可能会运行代码来注册各种事件处理器，然后使用这些事件处理程序在适当的时间将遥测数据发送回服务器。该模块是独立的，不需要导出任何东西，但是我们仍然需要导入它，以便它实际上可以作为程序的一部分运行。</p>

<p>请注意，即使对于具有导出的模块，也可以使用不导入任何内容的导入语法。如果模块定义的有用行为与导出的值无关，并且程序不需要任何导出的值，则仍可以用 . 导入模块，这仅用于默认导出。</p>

<h3 id="toc_9">10.3.3 导入导出重命名</h3>

<p>如果两个模块使用相同的名称导出两个不同的值，并且要导入这两个值，则在导入时必须重命名一个或两个值。同样，如果模块要导入值的名称已在模块中使用，则需要重命名导入的值。可以在命名导入中使用 as 关键字，以在导入它们时重命名它们：</p>

<pre><code class="language-javascript">import { render as renderImage } from &quot;./imageutils.js&quot;;
import { render as renderUI } from &quot;./ui.js&quot;;
</code></pre>

<p>这些行将两个功能导入当前模块。这些函数在定义它们的模块中都被命名为 render()，但使用更具描述性和消除歧义性的 renderImage() 和 renderUI() 名称导入。</p>

<p>回想一下，默认导出没有名称。导入默认导出时，导入模块始终选择名称。因此，在这种情况下，不需要特殊的语法来重命名。</p>

<p>话虽如此，导入重命名的可能性提供另外一种导入，从模块导入同时定义默认导出和命名导出。回顾上一节中的“ ./histogram-stats.js”模块。这是同时导入该模块的默认导出和命名导出的另一种方法：</p>

<pre><code class="language-javascript">import { default as Histogram, mean, stddev } from &quot;./histogram-stats.js&quot;;
</code></pre>

<p>在这种情况下，JavaScript 关键字 default 用作占位符，并允许我们指示我们要导入并为模块的默认导出提供名称。</p>

<p>也可以在导出时重命名值，但仅在使用 export 语句的花括号时才可以。这样做通常并不常见，但是如果选择在模块内部使用简短的简短名称，则可能更喜欢使用描述性较强的名称导出值，这些名称不太可能与其他模块发生冲突。与导入一样，可以使用 as 关键字执行此操作：</p>

<pre><code class="language-javascript">export {
    layout as calculateLayout,
    render as renderLayout
};
</code></pre>

<p>请记住，尽管花括号看起来像对象字面量，但实际上并非如此，并且 export 关键字期望在 as 之前有一个标识符，而不是表达式。不幸的是，这意味着不能像这样使用导出重命名：</p>

<pre><code class="language-javascript">export { Math.sin as sin, Math.cos as cos }; // SyntaxError
</code></pre>

<h3 id="toc_10">10.3.4 再导出</h3>

<p>在本章中，我们讨论了一个假定的“./stats.js”模块，该模块导出了 mean() 和 stddev() 函数。如果我们正在编写这样一个模块，并且该模块的用户只想要一个函数或另一个函数，那么我们可能想在“./stats/mean.js”模块中定义 mean()，并定义在“./stats/stddev.js”模块中的 stddev()。这样，程序仅需要完全导入所需的功能，而不会因导入不需要的代码而肿。</p>

<p>但是，即使我们在单个模块中定义了这些统计函数，我们也可能有很多程序需要这两个功能，并且希望使用一行代码方便的导入“./stats.js”模块。</p>

<p>鉴于实现现在位于单独的文件中，因此定义这样的“./stat.js”模块会非常简单：</p>

<pre><code class="language-javascript">import { mean } from &quot;./stats/mean.js&quot;;
import { stddev } from &quot;./stats/stddev.js&quot;;
export { mean, stdev };
</code></pre>

<p>ES6 模块预见了这种使用场景，并为此提供了一种特殊的语法。可以使用 export 和 from 关键字合并导入和导出到一个单独的“再导出”语句中，而不是简单地再次导入即可导入符号：</p>

<pre><code class="language-javascript">export { mean } from &quot;./stats/mean.js&quot;;
export { stddev } from &quot;./stats/stddev.js&quot;;
</code></pre>

<p>请注意，此代码中并未实际使用名称 mean 和 stddev。如果我们不选择再导出，而只是想从另一个模块中导出所有命名值，则可以使用通配符：</p>

<pre><code class="language-javascript">export * from &quot;./stats/mean.js&quot;;
export * from &quot;./stats/stddev.js&quot;;
</code></pre>

<p>再导出语法允许重命名，就像常规的导入和导出语句一样。 假设我们要再导出 mean() 函数，但还要将该函数定义为 average()。 我们可以这样做：</p>

<pre><code class="language-javascript">export { mean, mean as average } from &quot;./stats/mean.js&quot;;
export { stddev } from &quot;./stats/stddev.js&quot;;
</code></pre>

<p>所有的再导出示例中，“./stats/mean.js”和“./stats/stddev.js”模块都使用导出而不是默认导出来导出它们的函数。但是，实际上，由于这些模块仅具有单个导出，因此使用导出默认定义它们是更明智的。如果我们这样做，那么再导出语法会稍微复杂一点，因为它需要为未命名的默认导出定义一个名称。 我们可以这样做：</p>

<pre><code class="language-javascript">export { default as mean } from &quot;./stats/mean.js&quot;;
export { default as stddev } from &quot;./stats/stddev.js&quot;;
</code></pre>

<p>如果要从另一个模块中再导出命名符号作为模块的默认导出，则可以先进行导入，然后再默认导出，或者可以将以下两个语句组合在一起：</p>

<pre><code class="language-javascript">// Import the mean() function from ./stats.js and make it the
// default export of this module
export { mean as default } from &quot;./stats.js&quot;
</code></pre>

<p>最后，要将另一个模块的默认导出再导出为模块的默认导出（尽管不清楚为什么要这样做，因为用户可以直接导入另一个模块），可以这样编写：</p>

<pre><code class="language-javascript">// The average.js module simply re-exports the stats/mean.js default export
export { default } from &quot;./stats/mean.js&quot;
</code></pre>

<h3 id="toc_11">10.3.5 JavaScript Modules on the Web</h3>

<p>The preceding sections have described ES6 modules and their import and export declarations in a somewhat abstract manner. In this section and the next, we’ll be discussing how they actually work in web browsers, and if you are not already an experienced web developer, you may find the rest of this chapter easier to understand after you have read Chapter 15.</p>

<blockquote>
<p>前面的章节以某种抽象的方式描述了 ES6 模块及其导入和导出声明。在本节和下一部分中，我们将讨论它们在 Web 浏览器中的实际工作方式，如果您还不是经验丰富的 Web 开发人员，则在阅读第 15 章之后，可能会发现本章的其余部分更容易理解。</p>
</blockquote>

<p>As of early 2020, production code using ES6 modules is still generally bundled with a tool like webpack. There are trade-offs to doing this, [<sup>1]</sup> but on the whole, code bundling tends to give better performance. That may well change in the future as network speeds grow and browser vendors continue to optimize their ES6 module implementations.</p>

<blockquote>
<p>截至 2020 年初，使用 ES6 模块的生产代码通常仍与 webpack 之类的工具捆绑在一起。 这样做是有折衷的 [<sup>1]，但是总的来说，代码捆绑往往会提供更好的性能。随着网络速度的增长以及浏览器供应商继续优化其</sup> ES6 模块的实现，将来这种情况可能会发生很大的变化。</p>
</blockquote>

<p>Even though bundling tools may still be desirable in production, they are no longer required in development since all current browsers provide native support for JavaScript modules. Recall that modules use strict mode by default, this does not refer to a global object, and top-level declarations are not shared globally by default. Since modules must be executed differently than legacy non-module code, their introduction requires changes to HTML as well as JavaScript. If you want to natively use import directives in a web browser, you must tell the web browser that your code is a module by using a <code>&lt;script type=&quot;module&quot;&gt;</code> tag.</p>

<blockquote>
<p>即使在生产中仍可能需要捆绑工具，但由于当前所有的浏览器都为 JavaScript 模块提供了本机支持，因此在开发中不再需要捆绑工具。回想一下，默认情况下模块使用严格模式，this 不引用全局对象，并且顶级声明默认不全局共享。由于模块的执行方式必须不同于传统的非模块代码，因此其引入 requires 对 HTML 和 JavaScript 进行更改。如果要在 Web 浏览器本地使用 import 指令，则必须通过使用 <code>&lt;script type =“ module”&gt;</code> 标记来告知 Web 浏览器您的代码是模块。</p>
</blockquote>

<p>One of the nice features of ES6 modules is that each module has a static set of imports. So given a single starting module, a web browser can load all of its imported modules and then load all of the modules imported by that first batch of modules, and so on, until a complete program has been loaded. We’ve seen that the module specifier in an import statement can be treated as a relative URL. A <code>&lt;script type=&quot;module&quot;&gt;</code> tag marks the starting point of a modular program. None of the modules it imports are expected to be in <code>&lt;script&gt;</code> tags, however: instead, they are loaded on demand as regular JavaScript files and are executed in strict mode as regular ES6 modules. Using a <code>&lt;script type=&quot;module&quot;&gt;</code> tag to define the main entry point for a modular JavaScript program can be as simple as this:</p>

<pre><code class="language-javascript">&lt;script type=&quot;module&quot;&gt;import &quot;./main.js&quot;;&lt;/script&gt;
</code></pre>

<p>Code inside an inline <code>&lt;script type=&quot;module&quot;&gt;</code> tag is an ES6 module, and as such can use the export statement. There is not any point in doing so, however, because the HTML <code>&lt;script&gt;</code> tag syntax does not provide any way to define a name for inline modules, so even if such a module does export a value, there is no way for another module to import it.</p>

<p>Scripts with the type=&quot;module&quot; attribute are loaded and executed like scripts with the defer attribute. Loading of the code begins as soon as the HTML parser encounters the <code>&lt;script&gt;</code> tag (in the case of modules, this code-loading step may be a recursive process that loads multiple JavaScript files). But code execution does not begin until HTML parsing is complete. And once HTML parsing is complete, scripts (both modular and non) are executed in the order in which they appear in the HTML document.</p>

<p>You can modify the execution time of modules with the async attribute, which works the same way for modules that it does for regular scripts. An async module will execute as soon as the code is loaded, even if HTML parsing is not complete and even if this changes the relative ordering of the scripts.</p>

<p>Web browsers that support <code>&lt;script type=&quot;module&quot;&gt;</code> must also support <code>&lt;script nomodule&gt;</code>. Browsers that are module-aware ignore any script with the nomodule attribute and will not execute it. Browsers that do not support modules will not recognize the nomodule attribute, so they will ignore it and run the script. This provides a powerful technique for dealing with browser compatibility issues. Browsers that support ES6 modules also support other modern JavaScript features like classes, arrow functions, and the for/of loop. If you write modern JavaScript and load it with <code>&lt;script type=&quot;module&quot;&gt;</code>, you know that it will only be loaded by browsers that can support it. And as a fallback for IE11 (which, in 2020, is effectively the only remaining browser that does not support ES6), you can use tools like Babel and webpack to transform your code into non-modular ES5 code, then load that less-efficient transformed code via <code>&lt;script nomodule&gt;</code>.</p>

<p>Another important difference between regular scripts and module scripts has to do with cross-origin loading. A regular <code>&lt;script&gt;</code> tag will load a file of JavaScript code from any server on the internet, and the internet’s infrastructure of advertising, analytics, and tracking code depends on that fact. But <code>&lt;script type=&quot;module&quot;&gt;</code> provides an opportunity to tighten this up, and modules can only be loaded from the same origin as the containing HTML document or when proper CORS headers are in place to securely allow cross-origin loads. An unfortunate side effect of this new security restriction is that it makes it difficult to test ES6 modules in development mode using file: URLs. When using ES6 modules, you will likely need to set up a static web server for testing.</p>

<p>Some programmers like to use the filename extension .mjs to distinguish their modular JavaScript files from their regular, non-modular JavaScript files with the traditional .js extension. For the purposes of web browsers and <code>&lt;script&gt;</code> tags, the file extension is actually irrelevant. (The MIME type is relevant, however, so if you use .mjs files, you may need to configure your web server to serve them with the same MIME type as .js files.) Node’s support for ES6 does use the filename extension as a hint to distinguish which module system is used by each file it loads. So if you are writing ES6 modules and want them to be usable with Node, then it may be helpful to adopt the .mjs naming convention.</p>

<h3 id="toc_12">10.3.6 Dynamic Imports with import()</h3>

<p>We’ve seen that the ES6 import and export directives are completely static and enable JavaScript interpreters and other JavaScript tools to determine the relationships between modules with simple text analysis while the modules are being loaded without having to actually execute any of the code in the modules. With statically imported modules, you are guaranteed that the values you import into a module will be ready for use before any of the code in your module begins to run.</p>

<p>On the web, code has to be transferred over a network instead of being read from the filesystem. And once transfered, that code is often executed on mobile devices with relatively slow CPUs. This is not the kind of environment where static module imports—which require an entire program to be loaded before any of it runs—make a lot of sense.</p>

<p>It is common for web applications to initially load only enough of their code to render the first page displayed to the user. Then, once the user has some preliminary content to interact with, they can begin to load the often much larger amount of code needed for the rest of the web app. Web browsers make it easy to dynamically load code by using the DOM API to inject a new <code>&lt;script&gt;</code> tag into the current HTML document, and web apps have been doing this for many years.</p>

<p>Although dynamic loading has been possible for a long time, it has not been part of the language itself. That changes with the introduction of import() in ES2020 (as of early 2020, dynamic import is supported by all browsers that support ES6 modules). You pass a module specifier to import() and it returns a Promise object that represents the asynchronous process of loading and running the specified module. When the dynamic import is complete, the Promise is “fulfilled” (see Chapter 13 for complete details on asynchronous programming and Promises) and produces an object like the one you would get with the import * as form of the static import statement.</p>

<p>So instead of importing the “./stats.js” module statically, like this:</p>

<pre><code class="language-javascript">import * as stats from &quot;./stats.js&quot;;
we might import it and use it dynamically, like this:

import(&quot;./stats.js&quot;).then(stats =&gt; {
    let average = stats.mean(data);
})
</code></pre>

<p>Or, in an async function (again, you may need to read Chapter 13 before you’ll understand this code), we can simplify the code with await:</p>

<pre><code class="language-javascript">async analyzeData(data) {
    let stats = await import(&quot;./stats.js&quot;);
    return {
        average: stats.mean(data),
        stddev: stats.stddev(data)
    };
}
</code></pre>

<p>The argument to import() should be a module specifier, exactly like one you’d use with a static import directive. But with import(), you are not constrained to use a constant string literal: any expression that evaluates to a string in the proper form will do.</p>

<p>Dynamic import() looks like a function invocation, but it actually is not. Instead, import() is an operator and the parentheses are a required part of the operator syntax. The reason for this unusual bit of syntax is that import() needs to be able to resolve module specifiers as URLs relative to the currently running module, and this requires a bit of implementation magic that would not be legal to put in a JavaScript function. The function versus operator distinction rarely makes a difference in practice, but you’ll notice it if you try writing code like console.log(import); or let require = import;.</p>

<p>Finally, note that dynamic import() is not just for web browsers. Code-packaging tools like webpack can also make good use of it. The most straightforward way to use a code bundler is to tell it the main entry point for your program and let it find all the static import directives and assemble everything into one large file. By strategically using dynamic import() calls, however, you can break that one monolithic bundle up into a set of smaller bundles that can be loaded on demand.</p>

<h3 id="toc_13">10.3.7 import.meta.url</h3>

<p>There is one final feature of the ES6 module system to discuss. Within an ES6 module (but not within a regular <code>&lt;script&gt;</code>or a Node module loaded with require()), the special syntax import.meta refers to an object that contains metadata about the currently executing module. The url property of this object is the URL from which the module was loaded. (In Node, this will be a file:// URL.)</p>

<p>The primary use case of import.meta.url is to be able to refer to images, data files, or other resources that are stored in the same directory as (or relative to) the module. The URL() constructor makes it easy to resolve a relative URL against an absolute URL like import.meta.url. Suppose, for example, that you have written a module that includes strings that need to be localized and that the localization files are stored in an l10n/ directory, which is in the same directory as the module itself. Your module could load its strings using a URL created with a function, like this:</p>

<pre><code class="language-javascript">function localStringsURL(locale) {
    return new URL(`l10n/${locale}.json`, import.meta.url);
}
</code></pre>

<h2 id="toc_14">10.4 Summary</h2>

<p>The goal of modularity is to allow programmers to hide the implementation details of their code so that chunks of code from various sources can be assembled into large programs without worrying that one chunk will overwrite functions or variables of another. This chapter has explained three different JavaScript module systems:</p>

<ul>
<li>In the early days of JavaScript, modularity could only be achieved through the clever use of immediately invoked function expressions.</li>
<li>Node added its own module system on top of the JavaScript language. Node modules are imported with require() and define their exports by setting properties of the Exports object, or by setting the module.exports property.</li>
<li>In ES6, JavaScript finally got its own module system with import and export keywords, and ES2020 is adding support for dynamic imports with import().</li>
</ul>

<hr/>

<ol>
<li>For example: web apps that have frequent incremental updates and users who make frequent return visits may find that using small modules instead of large bundles can result in better average load times because of better utilization of the user’s browser cache.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 12 章 迭代器和生成器]]></title>
    <link href="2019919.xyz/16135261093456.html"/>
    <updated>2021-02-17T09:41:49+08:00</updated>
    <id>2019919.xyz/16135261093456.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">12.1 迭代器是如何工作的</a>
</li>
<li>
<a href="#toc_1">12.2 可迭代对象的实现</a>
<ul>
<li>
<a href="#toc_2">12.2.1 关闭迭代器：Return 方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">12.3 生成器</a>
<ul>
<li>
<a href="#toc_4">12.3.1 生成器示例</a>
</li>
<li>
<a href="#toc_5">12.3.2 yield* 和递归生成器</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">12.4 高级生成器特性</a>
<ul>
<li>
<a href="#toc_7">12.4.1 生成器函数的返回值</a>
</li>
<li>
<a href="#toc_8">12.4.2 yield 表达式的值</a>
</li>
<li>
<a href="#toc_9">12.4.3 生成器的 return() 和 throw() 方法</a>
</li>
<li>
<a href="#toc_10">12.4.4 关于生成器的最后一个注意点</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">12.5 总结</a>
</li>
</ul>


<p>可迭代对象及其关联的迭代器是 ES6 的一个特性，在本书中我们已经多次看到。数组（包括 typedarray）是可迭代的，字符串、Set 和 Map 对象也是如此。这意味着这些数据结构的内容可以被 for/of 循环遍历，就像我们在 §5.4.4 中看到的那样：</p>

<pre><code class="language-javascript">let sum = 0;
for(let i of [1,2,3]) { // Loop once for each of these values
    sum += i;
}
sum   // =&gt; 6
</code></pre>

<p>迭代器还可以用 ... 运算符将可迭代对象展开或“扩展”到数组初始化或函数调用中，如 §7.1.2 所示：</p>

<pre><code class="language-javascript">let chars = [...&quot;abcd&quot;]; // chars == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
let data = [1, 2, 3, 4, 5];
Math.max(...data)        // =&gt; 5
</code></pre>

<p>迭代器可以与析构赋值一起使用：</p>

<pre><code class="language-javascript">let purpleHaze = Uint8Array.of(255, 0, 255, 128);
let [r, g, b, a] = purpleHaze; // a == 128
</code></pre>

<p>当你迭代一个 Map 对象时，返回的值是 [key, value] 对，这在 for/of 循环的解构赋值中很好用：</p>

<pre><code class="language-javascript">let m = new Map([[&quot;one&quot;, 1], [&quot;two&quot;, 2]]);
for(let [k,v] of m) console.log(k, v); // Logs &#39;one 1&#39; and &#39;two 2&#39;
</code></pre>

<p>如果只迭代键或只迭代值而不是一对，可以使用 keys() 和 values() 方法:</p>

<pre><code class="language-javascript">[...m]            // =&gt; [[&quot;one&quot;, 1], [&quot;two&quot;, 2]]: default iteration
[...m.entries()]  // =&gt; [[&quot;one&quot;, 1], [&quot;two&quot;, 2]]: entries() method is the same
[...m.keys()]     // =&gt; [&quot;one&quot;, &quot;two&quot;]: keys() method iterates just map keys
[...m.values()]   // =&gt; [1, 2]: values() method iterates just map values
</code></pre>

<p>最后，通常用于数组对象的许多内置函数和构造函数实际上被编写（在ES6及以后版本中）为接受任意实参的迭代器。Set() 构造函数就是这样一种API：</p>

<pre><code class="language-javascript">// Strings are iterable, so the two sets are the same:
new Set(&quot;abc&quot;) // =&gt; new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
</code></pre>

<p>本章说明了迭代器是如何工作的，并演示了如何创建自己的可迭代的数据结构。在说明了基本的迭代器之后，本章将介绍生成器，这是 ES6 的一个强大的新特性，它是一种特别简单的方法创建迭代器。</p>

<h2 id="toc_0">12.1 迭代器是如何工作的</h2>

<p>for/of 循环和展开运算符可与可迭代对象无缝配合，但是值得了解使迭代工作的实际情况。需要了解三种独立的类型才能理解 JavaScript 中的迭代。首先，可迭代的对象：可以迭代的是诸如 Array，Set 和 Map 之类的类型。其次，迭代器对象本身，它执行迭代。第三，一个迭代结果对象，该对象保存迭代的每个步骤的结果。</p>

<p>任何对象具有特殊迭代器方法，并且该方法返回迭代器对象，那么该对象为可迭代对象。迭代器对象具有 next() 方法，该方法返回迭代结果对象。迭代结果对象是具有名为 value 和 done 的属性的对象。要迭代一个可迭代的对象，首先要调用其迭代器方法以获取一个迭代器对象。然后，重复调用迭代器对象的 next() 方法，直到返回的值的 done 属性设置为 true。棘手的事情是，可迭代对象的迭代器方法没有常规名称，而是使用 Symbol Symbol.iterator 作为其名称。因此，也可以用很复杂的方式编写可迭代对象的简单 for/of 循环，如下所示：</p>

<pre><code class="language-javascript">let iterable = [99];
let iterator = iterable[Symbol.iterator]();
for(let result = iterator.next(); !result.done; result = iterator.next()) {
    console.log(result.value)  // result.value == 99
}
</code></pre>

<p>内置可迭代数据类型的迭代器对象本身是可迭代的。（也就是说，它具有一个名为 Symbol.iterator 的方法，该方法会自行返回。）当要通过“部分使用”的迭代器进行迭代时，以下代码中有时会很有用：</p>

<pre><code class="language-javascript">let list = [1,2,3,4,5];
let iter = list[Symbol.iterator]();
let head = iter.next().value;  // head == 1
let tail = [...iter];          // tail == [2,3,4,5]
</code></pre>

<h2 id="toc_1">12.2 可迭代对象的实现</h2>

<p>可迭代对象在 ES6 中非常有用，应该考虑使自己的数据类型在可以表示迭代的任何时候都可迭代。第 9 章示例 9-2 和 9-3 中显示的 Range 类是可迭代的。这些类使用生成器函数使其可迭代。我们将在本章稍后介绍生成器，但首先，我们将再次实现 Range 类，使其无需依赖生成器即可迭代。</p>

<p>为了使类可迭代，必须实现一个名称为 Symbol Symbol.iterator 的方法。该方法必须返回一个具有 next() 方法的迭代器对象。并且 next() 方法必须返回具有 value 属性和或或布尔型 done 属性的迭代结果对象。示例 12-1 实现了一个可迭代的 Range 类，并演示了如何创建可迭代的、迭代器和迭代结果对象。</p>

<p>示例 12-1 一个可迭代数值范围类</p>

<pre><code class="language-javascript">/*
 * A Range object represents a range of numbers {x: from &lt;= x &lt;= to}
 * Range defines a has() method for testing whether a given number is a member
 * of the range. Range is iterable and iterates all integers within the range.
 */
class Range {
    constructor (from, to) {
        this.from = from;
        this.to = to;
    }

    // Make a Range act like a Set of numbers
    has(x) { return typeof x === &quot;number&quot; &amp;&amp; this.from &lt;= x &amp;&amp; x &lt;= this.to; }

    // Return string representation of the range using set notation
    toString() { return `{ x | ${this.from} ≤ x ≤ ${this.to} }`; }

    // Make a Range iterable by returning an iterator object.
    // Note that the name of this method is a special symbol, not a string.
    [Symbol.iterator]() {
        // Each iterator instance must iterate the range independently of
        // others. So we need a state variable to track our location in the
        // iteration. We start at the first integer &gt;= from.
        let next = Math.ceil(this.from);  // This is the next value we return
        let last = this.to;               // We won&#39;t return anything &gt; this
        return {                          // This is the iterator object
            // This next() method is what makes this an iterator object.
            // It must return an iterator result object.
            next() {
                return (next &lt;= last)   // If we haven&#39;t returned last value yet
                    ? { value: next++ } // return next value and increment it
                    : { done: true };   // otherwise indicate that we&#39;re done.
            },

            // As a convenience, we make the iterator itself iterable.
            [Symbol.iterator]() { return this; }
        };
    }
}

for(let x of new Range(1,10)) console.log(x); // Logs numbers 1 to 10
[...new Range(-2,2)]                          // =&gt; [-2, -1, 0, 1, 2]
</code></pre>

<p>除了使类可迭代外，定义返回可迭代值的函数也非常有用。考虑 JavaScript 数组的 map() 和 filter() 方法的这些基于迭代的替代方法：</p>

<pre><code class="language-javascript">// Return an iterable object that iterates the result of applying f()
// to each value from the source iterable
function map(iterable, f) {
    let iterator = iterable[Symbol.iterator]();
    return {     // This object is both iterator and iterable
        [Symbol.iterator]() { return this; },
        next() {
            let v = iterator.next();
            if (v.done) {
                return v;
            } else {
                return { value: f(v.value) };
            }
        }
    };
}

// Map a range of integers to their squares and convert to an array
[...map(new Range(1,4), x =&gt; x*x)]  // =&gt; [1, 4, 9, 16]

// Return an iterable object that filters the specified iterable,
// iterating only those elements for which the predicate returns true
function filter(iterable, predicate) {
    let iterator = iterable[Symbol.iterator]();
    return { // This object is both iterator and iterable
        [Symbol.iterator]() { return this; },
        next() {
            for(;;) {
                let v = iterator.next();
                if (v.done || predicate(v.value)) {
                    return v;
                }
            }
        }
    };
}

// Filter a range so we&#39;re left with only even numbers
[...filter(new Range(1,10), x =&gt; x % 2 === 0)]  // =&gt; [2,4,6,8,10]
</code></pre>

<p>可迭代对象和迭代器的一个关键特性是它们固有的惰性：当需要计算才能计算下一个值时，可以将计算推迟到实际需要该值时进行。例如，假设有一个很长的文本字符串，想将其标记为以空格分隔的单词。可以简单地使用字符串的 split() 方法，但是如果这样做，则必须先处理整个字符串，才能使用第一个单词。最后，将为返回的数组及其中的所有字符串分配大量内存。这是一个允许懒惰地迭代字符串的祖母而无需一次将所有单词都保留在内存中的函数（在 ES2020 中，使用 §11.3.2 中描述的迭代器返回 matchAll() 方法可以更轻松地实现此函数。）：</p>

<pre><code class="language-javascript">function words(s) {
    var r = /\s+|$/g;                     // Match one or more spaces or end
    r.lastIndex = s.match(/[^ ]/).index;  // Start matching at first nonspace
    return {                              // Return an iterable iterator object
        [Symbol.iterator]() {             // This makes us iterable
            return this;
        },
        next() {                          // This makes us an iterator
            let start = r.lastIndex;      // Resume where the last match ended
            if (start &lt; s.length) {       // If we&#39;re not done
                let match = r.exec(s);    // Match the next word boundary
                if (match) {              // If we found one, return the word
                    return { value: s.substring(start, match.index) };
                }
            }
            return { done: true };        // Otherwise, say that we&#39;re done
        }
    };
}

[...words(&quot; abc def  ghi! &quot;)] // =&gt; [&quot;abc&quot;, &quot;def&quot;, &quot;ghi!&quot;]
</code></pre>

<h3 id="toc_2">12.2.1 关闭迭代器：Return 方法</h3>

<p>想象一下 words() 迭代器的（服务器端）JavaScript 变体，它不用源字符串作为实参，而是使用文件名，打开文件，从文件中读取行，然后从这些行中迭代单词。在大多数操作系统中，打开文件以从其中读取文件的程序需要记住在完成读取后关闭这些文件，因此，这个假设的迭代器将确保在 next() 方法返回文件中的最后一个字之后关闭文件。</p>

<p>但是迭代器并不总是一直运行到最后：for/of 循环可能会因中断或返回或异常而终止。同样，当迭代器用于解构赋值时，仅调用 next() 方法足够多次，以获取每个指定变量的值。迭代器可能有更多可能返回的值，但是它们永远不会被请求。</p>

<p>如果我们假设的文件中单词迭代器从未一直运行到最后，它仍然需要关闭它打开的文件。因此，迭代器对象可以实现 return() 方法与 next() 方法一起使用。如果迭代在 next() 返回完了属性设置为 true 的迭代结果之前停止（通常是因为通过 break 语句提前离开了 for/of 循环），则解释器将检查迭代器对象是否具有 return() 方法。如果存在此方法，则解释器将不带任何参数调用它，从而使迭代器有机会关闭文件，释放内存以及自行清理。return() 方法必须返回迭代器结果对象。对象的属性被忽略，但是返回非对象值是错误的。</p>

<p>for/of 循环和展开运算符是 JavaScript 真正实用功能，因此在创建 API 时，最好在尽可能的使用它们。但是必须使用一个可迭代的对象，其迭代器对象以及迭代器的结果对象，这会使过程变得有些复杂。幸运的是，生成器可以极大地简化自定义迭代器的创建，这将在本章的其余部分中看到。</p>

<h2 id="toc_3">12.3 生成器</h2>

<p>生成器是一种使用强大的新 ES6 语法定义的迭代器；当要迭代的值不是数据结构的元素而是计算结果时，此功能特别有用。</p>

<p>要创建生成器，必须首先定义一个生成器函数。生成器函数在语法上类似于常规 JavaScript 函数，但使用关键字 function* 而不是 function 定义。（从技术上讲，这不是新关键字，只是关键字 function 之后和函数名称之前的 *。）调用生成器函数时，它实际上并不执行函数主体，而是返回生成器对象。该生成器对象是一个迭代器。调用其 next() 方法会使生成器函数的主体从头开始运行（或无论其当前位置是什么），直到到达 yield 语句为止。yield 是 ES6 新特性，类似于 return 语句。yield 语句的值成为迭代器上 next() 调用返回的值。一个示例使这更加清楚：</p>

<pre><code class="language-javascript">// A generator function that yields the set of one digit (base-10) primes.
function* oneDigitPrimes() { // Invoking this function does not run the code
    yield 2;                 // but just returns a generator object. Calling
    yield 3;                 // the next() method of that generator runs
    yield 5;                 // the code until a yield statement provides
    yield 7;                 // the return value for the next() method.
}

// When we invoke the generator function, we get a generator
let primes = oneDigitPrimes();

// A generator is an iterator object that iterates the yielded values
primes.next().value          // =&gt; 2
primes.next().value          // =&gt; 3
primes.next().value          // =&gt; 5
primes.next().value          // =&gt; 7
primes.next().done           // =&gt; true

// Generators have a Symbol.iterator method to make them iterable
primes[Symbol.iterator]()    // =&gt; primes

// We can use generators like other iterable types
[...oneDigitPrimes()]        // =&gt; [2,3,5,7]
let sum = 0;
for(let prime of oneDigitPrimes()) sum += prime;
sum                          // =&gt; 17
</code></pre>

<p>在此示例中，我们使用 function* 语句定义了生成器。但是，像常规函数一样，我们也可以在 from 表达式中定义生成器。再一次，我们只在 function 关键字之后加上一个星号：</p>

<pre><code class="language-javascript">const seq = function*(from,to) {
    for(let i = from; i &lt;= to; i++) yield i;
};
[...seq(3,5)]  // =&gt; [3, 4, 5]
</code></pre>

<p>在类和对象文字中，我们在定义方法时可以使用速记标记来完全省略 function 关键字。要在这种情况下定义生成器，我们只需在方法名称之前使用星号即可：</p>

<pre><code class="language-javascript">let o = {
    x: 1, y: 2, z: 3,
    // A generator that yields each of the keys of this object
    *g() {
        for(let key of Object.keys(this)) {
            yield key;
        }
    }
};
[...o.g()] // =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;g&quot;]
</code></pre>

<p>请注意，无法使用箭头函数语法编写生成器函数。</p>

<p>生成器通常使定义可迭代类特别容易。我们可以用更短的 <code>*[Symbol.iterator];()</code> 生成器函数代替示例 12-1 中的 <code>[Symbol.iterator]()</code> 方法，如下所示：</p>

<pre><code class="language-javascript">*[Symbol.iterator]() {
    for(let x = Math.ceil(this.from); x &lt;= this.to; x++) yield x;
}
</code></pre>

<p>请参阅第 9 章中的示例 9-3，可以看到在上下文中看到此基于生成器的迭代器函数。 </p>

<h3 id="toc_4">12.3.1 生成器示例</h3>

<p>如果生成器实际上通过执行某种计算来生成它们产生的值，则它们会更有趣。例如，这里是生成斐波那契数的生成器函数：</p>

<pre><code class="language-javascript">function* fibonacciSequence() {
    let x = 0, y = 1;
    for(;;) {
        yield y;
        [x, y] = [y, x+y];  // Note: destructuring assignment
    }
}
</code></pre>

<p>请注意，此处的 fibonacciSequence() 生成器函数具有无限循环，并且永久产生值而不会返回。如果将此生成器与 ... 展开运算符一起使用，它将循环播放直到内存耗尽且程序崩溃。小心地在 for/of 循环中使用它：</p>

<pre><code class="language-javascript">// Return the nth Fibonacci number
function fibonacci(n) {
    for(let f of fibonacciSequence()) {
        if (n-- &lt;= 0) return f;
    }
}
fibonacci(20)   // =&gt; 10946
</code></pre>

<p>这种无限生成器在使用 take() 生成器时变得更加有用，如下所示：</p>

<pre><code class="language-javascript">// Yield the first n elements of the specified iterable object
function* take(n, iterable) {
    let it = iterable[Symbol.iterator](); // Get iterator for iterable object
    while(n-- &gt; 0) {           // Loop n times:
        let next = it.next();  // Get the next item from the iterator.
        if (next.done) return; // If there are no more values, return early
        else yield next.value; // otherwise, yield the value
    }
}

// An array of the first 5 Fibonacci numbers
[...take(5, fibonacciSequence())]  // =&gt; [1, 1, 2, 3, 5]
</code></pre>

<p>这是另一个有用的生成器函数，它交错多个可迭代对象的元素：</p>

<pre><code class="language-javascript">// Given an array of iterables, yield their elements in interleaved order.
function* zip(...iterables) {
    // Get an iterator for each iterable
    let iterators = iterables.map(i =&gt; i[Symbol.iterator]());
    let index = 0;
    while(iterators.length &gt; 0) {       // While there are still some iterators
        if (index &gt;= iterators.length) {    // If we reached the last iterator
            index = 0;                      // go back to the first one.
        }
        let item = iterators[index].next(); // Get next item from next iterator.
        if (item.done) {                    // If that iterator is done
            iterators.splice(index, 1);     // then remove it from the array.
        }
        else {                              // Otherwise,
            yield item.value;               // yield the iterated value
            index++;                        // and move on to the next iterator.
        }
    }
}

// Interleave three iterable objects
[...zip(oneDigitPrimes(),&quot;ab&quot;,[0])]     // =&gt; [2,&quot;a&quot;,0,3,&quot;b&quot;,5,7]
</code></pre>

<h3 id="toc_5">12.3.2 yield* 和递归生成器</h3>

<p>除了前面示例中定义的 zip() 生成器之外，具有类似的生成器功能可能会很有用，该功能可以按顺序生成多个可迭代对象的元素，而不是交织它们。我们可以这样编写生成器：</p>

<pre><code class="language-javascript">function* sequence(...iterables) {
    for(let iterable of iterables) {
        for(let item of iterable) {
            yield item;
        }
    }
}

[...sequence(&quot;abc&quot;,oneDigitPrimes())]  // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,2,3,5,7]
</code></pre>

<p>这种生成其他可迭代对象的元素的过程在生成器函数中已经足够普遍，以至于为它 ES6 具有特殊的语法。yield* 关键字类似于 yield，除了它不产生单个值，而是迭代一个可迭代的对象并产生每个结果值。我们使用的 sequence() 生成器函数可以通过 yield* 进行简化，如下所示：</p>

<pre><code class="language-javascript">function* sequence(...iterables) {
    for(let iterable of iterables) {
        yield* iterable;
    }
}

[...sequence(&quot;abc&quot;,oneDigitPrimes())]  // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,2,3,5,7]
</code></pre>

<p>数组 forEach() 方法通常是一种循环遍历数组元素的好方法，因此可能会很想像这样编写 sequence() 函数：</p>

<pre><code class="language-javascript">function* sequence(...iterables) {
    iterables.forEach(iterable =&gt; yield* iterable );  // Error
}
</code></pre>

<p>但是，这不起作用。yield 和 yield* 只能在生成器函数中使用，但是此代码中的嵌套箭头函数是常规函数，而不是 function* 生成器函数，因此不允许 yield。</p>

<p>yield* 可用于任何种类的可迭代对象，包括使用生成器实现的可迭代对象。这意味着 yield* 允许我们定义递归生成器，例如，可以使用此功能在递归定义的树结构上进行简单的非递归迭代。</p>

<h2 id="toc_6">12.4 高级生成器特性</h2>

<p>生成器函数最常见的用途是创建迭代器，但是生成器的基本特性是它们允许我们暂停计算，产生中间结果，然后在以后恢复计算。这意味着生成器具有的功能超出了迭代器的功能，我们将在以下各节中探讨这些功能。</p>

<h3 id="toc_7">12.4.1 生成器函数的返回值</h3>

<p>到目前为止，我们看到的生成器函数还没有 return 语句，或者，如果有的话，它们只是被用来引起较早的返回，而不是产生返回值。但是，像任何函数一样，生成器函数可以返回一个值。为了了解在这种情况下会发生什么，请回忆一下迭代是如何工作的。next() 函数的返回值是一个具有 value 属性和或或 done 属性的对象。对于典型的迭代器和生成器，如果定义了 value 属性，则 done 属性是 undefined 或为 false。如果 done 为 true，那么值就是 undefined。但是，如果生成器返回一个值，则对 next 的最终调用将返回一个同时具有 value ​​和 done 定义的对象。 value 属性保存生成器函数的返回值，并且 done 属性为 true，表示没有更多的值可以迭代。最终值将被 for/of 循环和展开运算符忽略，但可用通过对 next() 的显式调用手动进行迭代：</p>

<pre><code class="language-javascript">function *oneAndDone() {
    yield 1;
    return &quot;done&quot;;
}

// The return value does not appear in normal iteration.
[...oneAndDone()]   // =&gt; [1]

// But it is available if you explicitly call next()
let generator = oneAndDone();
generator.next()           // =&gt; { value: 1, done: false}
generator.next()           // =&gt; { value: &quot;done&quot;, done: true }
// If the generator is already done, the return value is not returned again
generator.next()           // =&gt; { value: undefined, done: true }
</code></pre>

<h3 id="toc_8">12.4.2 yield 表达式的值</h3>

<p>在前面的讨论中，我们将 yield 视为带有值但没有自身值的语句。但是，实际上，yield 是一个表达式，可以有一个值。</p>

<p>调用生成器的 next() 方法时，生成器函数将运行直至到达 yield 表达式。将评估 yield 关键字之后的表达式，该值将成为 next() 调用的返回值。此时，生成器函数在评估 yield 表达式的中间立即停止执行。下次调用生成器的 next() 方法时，传递给 next() 的参数成为已暂停的 yield 表达式的值。因此，生成器将把 yield 的值返回给它的调用者，然后调用者通过 next() 将值传递给生成器。生成器和调用者是两个独立的执行流，来回传递值（和控制）。以下代码说明： </p>

<pre><code class="language-javascript">function* smallNumbers() {
    console.log(&quot;next() invoked the first time; argument discarded&quot;);
    let y1 = yield 1;    // y1 == &quot;b&quot;
    console.log(&quot;next() invoked a second time with argument&quot;, y1);
    let y2 = yield 2;    // y2 == &quot;c&quot;
    console.log(&quot;next() invoked a third time with argument&quot;, y2);
    let y3 = yield 3;    // y3 == &quot;d&quot;
    console.log(&quot;next() invoked a fourth time with argument&quot;, y3);
    return 4;
}

let g = smallNumbers();
console.log(&quot;generator created; no code runs yet&quot;);
let n1 = g.next(&quot;a&quot;);   // n1.value == 1
console.log(&quot;generator yielded&quot;, n1.value);
let n2 = g.next(&quot;b&quot;);   // n2.value == 2
console.log(&quot;generator yielded&quot;, n2.value);
let n3 = g.next(&quot;c&quot;);   // n3.value == 3
console.log(&quot;generator yielded&quot;, n3.value);
let n4 = g.next(&quot;d&quot;);   // n4 == { value: 4, done: true }
console.log(&quot;generator returned&quot;, n4.value);
</code></pre>

<p>此代码运行时，将产生以下输出，演示两个代码块之间的来回交互：</p>

<pre><code class="language-text">generator created; no code runs yet
next() invoked the first time; argument discarded
generator yielded 1
next() invoked a second time with argument b
generator yielded 2
next() invoked a third time with argument c
generator yielded 3
next() invoked a fourth time with argument d
generator returned 4
</code></pre>

<p>注意此代码中的不对称性。next() 的首次调用将启动生成器，但是生成器无法访问传递给该调用的值。</p>

<h3 id="toc_9">12.4.3 生成器的 return() 和 throw() 方法</h3>

<p>我们已经看到可以接收生成器函数产生或返回的值。可以在调用生成器的 next() 方法时将值传递给正在运行的生成器。</p>

<p>除了使用 next() 向生成器提供输入之外，还可以通过调用生成器的 return() 和 throw() 方法来更改生成器内部的控制流。顾名思义，在生成器上调用这些方法会导致其返回值或引发异常，就像生成器中的下一条语句是 return 或 throw 一样。</p>

<p>从本章前面的内容回想起，如果迭代器定义了 return() 方法且迭代提早停止，则解释器将自动调用 return() 方法，以使迭代器有机会关闭文件或进行其他清理。对于生成器，不能定义自定义的 return() 方法来处理清理，但是可以构造生成器代码以使用 try/finally 语句，以确保生成器返回时执行清理操作（在 finally 块中）。通过强制生成器返回，生成器的内置 return() 方法可确保在不再使用生成器时运行清除代码。</p>

<p>正如生成器的 next() 方法允许我们将任意值传递给正在运行的生成器一样，生成器的 throw() 方法为我们提供了一种将任意信号（以异常形式）发送到生成器的方法。调用 throw() 方法总是会在生成器内部引起异常。但是，如果生成器函数有适当的异常处理代码编，则该异常是致命的，不过这可以用作更改生成器行为的一种手段。例如，想象一下产生一个不断增加的整数序列的计数器生成器。可以这样编写，使用 throw() 发送的异常将计数器重置为零。</p>

<p>当生成器使用 yield* 从其他可迭代对象生成值时，对生成器的 next() 方法的调用会导致对可迭代对象的 next() 方法的调用。return() 和 throw() 方法也是如此。 如果生成器在定义了这些方法的可迭代对象上使用 yield*，则在生成器上调用 return() 或 throw() 会导致依次调用迭代器的 return() 或 throw() 方法。所有迭代器都必须具有 next() 方法。需要在不完整的迭代后进行清理的迭代器应定义一个 return() 方法。而且，任何迭代器都可以定义 throw() 方法，尽管我不知道有任何实际原因。</p>

<h3 id="toc_10">12.4.4 关于生成器的最后一个注意点</h3>

<p>生成器是一个非常强大的通用控制结构。它们使我们能够使用 yield 暂停计算，并在以后任意任意时间使用任意输入值重新开始计算。可以使用生成器在单线程 JavaScript 代码中创建一种协作线程系统。而且，即使某些函数调用实际上是异步的并且依赖于网络事件，也可以使用生成器来掩盖程序的异步部分，从而使代码显得顺序和同步。</p>

<p>尝试使用生成器执行这些操作会导致代码难以理解或解释。但是，它已经成为了过去时，唯一真正实用的用例是管理异步代码。为此，JavaScript 现在具有 async 和 await 关键字（请参阅第 13 章），并且不再有任何理由以这种方式滥用生成器。</p>

<h2 id="toc_11">12.5 总结</h2>

<p>在本章中，您学习了：</p>

<p>for/of 循环和 ... 展开运算符可迭代对象。</p>

<p>如果对象具有符号名称为 [Symbol.iterator] 的方法，则该方法返回迭代器对象，该对象是可迭代的。</p>

<p>迭代器对象具有 next() 方法，该方法返回迭代结果对象。</p>

<p>迭代结果对象具有一个 value 属性，该属性保存下一个迭代值（如果有）。如果迭代已完成，则结果对象必须将 done 属性设置为 true。 </p>

<p>可以通过定义返回对象的 <a href="">Symbol.iterator</a> 方法和返回迭代结果对象的 next() 方法来实现自己的可迭代对象。还可以实现接受迭代器参数并返回迭代器值的函数。 </p>

<p>生成器函数（用 function* 代替 function 定义的函数）是定义迭代器的另一种方法。</p>

<p>当调用生成器函数时，该函数的主体不会立即运行。相反，返回值是一个可迭代的迭代器对象。每次调用迭代器的 next() 方法时，都会运行另一部分生成器函数。</p>

<p>生成器函数可以使用 yield 运算符来指定迭代器返回的值。每次调用 next() 都会使生成器函数运行到下一个 yield 表达式。然后，该 yield 表达式的值将成为迭代器返回的值。当没有更多的 yield 表达式时，生成器函数将返回，并且迭代完成。 </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第 13 章 异步 JavaScript]]></title>
    <link href="2019919.xyz/16130963623880.html"/>
    <updated>2021-02-12T10:19:22+08:00</updated>
    <id>2019919.xyz/16130963623880.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">13.1 基于回调的异步编程</a>
<ul>
<li>
<a href="#toc_1">13.1.1 计时器</a>
</li>
<li>
<a href="#toc_2">13.1.2 事件</a>
</li>
<li>
<a href="#toc_3">13.1.3 网络事件</a>
</li>
<li>
<a href="#toc_4">13.1.4 Callbacks and Events in Node</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">13.2 Promise</a>
<ul>
<li>
<a href="#toc_6">13.2.1 使用 Promise</a>
<ul>
<li>
<a href="#toc_7">PROMISE 异常处理</a>
</li>
<li>
<a href="#toc_8">PROMISE 专业术语</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">13.2.2 Promise 链</a>
</li>
<li>
<a href="#toc_10">13.2.3 Promise 决议</a>
</li>
<li>
<a href="#toc_11">13.2.4 更多关于 Promise 和异常</a>
<ul>
<li>
<a href="#toc_12">CATCH 和 FINALLY 方法</a>
</li>
<li>
<a href="#toc_13">从 PROMISE 回调函数返回</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">13.2.5 并行 Promise</a>
</li>
<li>
<a href="#toc_15">13.2.6 构造 Promise</a>
<ul>
<li>
<a href="#toc_16">PROMISE 基于别的 PROMISE</a>
</li>
<li>
<a href="#toc_17">PROMISE 基于同步值</a>
</li>
<li>
<a href="#toc_18">构造函数创建 PROMISE</a>
</li>
</ul>
</li>
<li>
<a href="#toc_19">13.2.7 连续的 Promise</a>
</li>
</ul>
</li>
<li>
<a href="#toc_20">13.3 async 和 await</a>
<ul>
<li>
<a href="#toc_21">13.3.1 await 表达式</a>
</li>
<li>
<a href="#toc_22">13.3.2 async 函数</a>
</li>
<li>
<a href="#toc_23">13.3.3 等待多个 Promise</a>
</li>
<li>
<a href="#toc_24">13.3.4 实现详细</a>
</li>
</ul>
</li>
<li>
<a href="#toc_25">13.4 异步迭代</a>
<ul>
<li>
<a href="#toc_26">13.4.1 for/await 循环</a>
</li>
<li>
<a href="#toc_27">13.4.2 异步迭代器</a>
</li>
<li>
<a href="#toc_28">13.4.3 异步生成器</a>
</li>
<li>
<a href="#toc_29">13.4.4 实现异步迭代器</a>
</li>
</ul>
</li>
<li>
<a href="#toc_30">13.5 Summary</a>
</li>
</ul>


<p>一些计算机程序，如科学模拟和机器学习模型，是计算受限的：它们不停地运行，没有停顿，直到计算出结果。然而，值得注意的是现实世界中的大多数计算机程序都是异步的。这意味着在等待数据到达或某些事件发生时，它们常常不得不停止计算。web 浏览器中的 JavaScript 程序是典型地事件驱动的，这意味着它们在实际执行任何操作之前等待用户单击或点击。基于 javascript 的服务器通常在执行任何操作之前等待客户机请求通过网络到达。</p>

<p>这种异步编程在 JavaScript 中很常见，本章将介绍三种重要的语言特性，它们有助于简化异步代码的使用。Promise 是 ES6 中的新特性，是表示目前不可用结果的异步操作对象。关键字 async 和 await 是在 ES2017 中引入的，它们提供了新的语法，通过允许将基于 Promise 的代码构造成同步的方式来简化异步编程。最后，在 ES2018 中引入了异步迭代器和 for/await 循环，允许使用简单的同步循环处理异步事件流。</p>

<p>具有讽刺意味的是，尽管 JavaScript 为处理异步代码提供了这些强大的特性，但核心语言本身并没有异步的特性。因此，为了演示 Promise、async、await 和 for/await，我们将首先使用客户端和服务器端 JavaScript 来解释 web 浏览器和 Node 的一些异步特性。（可以在第 15 章和第 16 章中了解更多关于客户端和服务器端 JavaScript 的知识。）</p>

<h2 id="toc_0">13.1 基于回调的异步编程</h2>

<p>在最基本的层次上，JavaScript 中的异步编程是通过回调来完成的。回调是一个你编写的函数，然后传递给其他函数。当满足某些条件或发生某些（异步）事件时，其他函数调用（“回调”）你的函数。提供的回调函数的调用会通知你条件或事件，有时，调用将提供包含额外细节的函数实参。通过一些具体的示例会更容易理解，下面的子节将演示使用客户端 JavaScript 和 Node 的各种形式的基于回调的异步编程。</p>

<h3 id="toc_1">13.1.1 计时器</h3>

<p>当希望在经过一定时间后运行某些代码是一种最简单的异步类型。正如我们在 §11.10 中看到的，可以通过 setTimeout() 函数来做到这一点：</p>

<pre><code class="language-javascript">setTimeout(checkForUpdates, 60000);
</code></pre>

<p>setTimeout() 的第一个实参是一个函数，第二个实参是一个以毫秒为单位的时间间隔。前面的代码中，在 setTimeout() 调用后 60,000 毫秒（1分钟）后，将调用一个假定的 checkForUpdates() 函数。checkForUpdates() 是程序定义的一个回调函数，而 setTimeout() 是用于注册回调函数并指定应该在什么异步条件下调用它的函数。</p>

<p>setTimeout() 调用一次指定的回调函数，不传递任何实参，然后忘记它。如果正在编写一个检查更新的函数，可能希望它重复运行。可以使用 setInterval() 来代替 setTimeout()：</p>

<pre><code class="language-javascript">// Call checkForUpdates in one minute and then again every minute after that
let updateIntervalId = setInterval(checkForUpdates, 60000);

// setInterval() returns a value that we can use to stop the repeated
// invocations by calling clearInterval(). (Similarly, setTimeout()
// returns a value that you can pass to clearTimeout())
function stopCheckingForUpdates() {
    clearInterval(updateIntervalId);
}
</code></pre>

<h3 id="toc_2">13.1.2 事件</h3>

<p>客户端 JavaScript 程序几乎都是由事件驱动的：它们通常不等待用户执行某种预定的计算，而是等待用户执行某些操作，然后响应用户的操作。当用户按下键盘上的键，移动鼠标，单击鼠标按钮或触摸触摸屏设备时，Web 浏览器会发生事件。事件驱动的 JavaScript 程序在指定的上下文中为指定类型的事件注册回调函数，并且只要指定事件发生，Web 浏览器就会调用这些函数。这些回调函数称为事件句柄或事件监听器，并且使用 addEventListener() 注册：</p>

<pre><code class="language-javascript">// Ask the web browser to return an object representing the HTML
// &lt;button&gt; element that matches this CSS selector
let okay = document.querySelector(&#39;#confirmUpdateDialog button.okay&#39;);

// Now register a callback function to be invoked when the user
// clicks on that button.
okay.addEventListener(&#39;click&#39;, applyUpdate);
</code></pre>

<p>在此示例中，假设 applyUpdate() 是我们在某个地方实现的回调函数。调用 document.querySelector() 返回一个对象，该对象表示网页中的单个指定元素。我们在该元素上调用 addEventListener() 来注册我们的回调。然后，addEventListener() 的第一个实参是一个字符串，该字符串指定了事件的类型（在这种情况下是单击鼠标或触摸屏）。如果用户单击或点击网页上的特定元素，则浏览器将调用我们的 applyUpdate() 回调函数，并传递一个包含事件详细信息（例如时间和鼠标指针坐标）的对象。</p>

<h3 id="toc_3">13.1.3 网络事件</h3>

<p>JavaScript 编程中异步的另一个常见来源是网络请求。在浏览器中运行的 JavaScript 可以使用以下代码从 Web 服务器获取数据：</p>

<pre><code class="language-javascript">function getCurrentVersionNumber(versionCallback) { // Note callback argument
    // Make a scripted HTTP request to a backend version API
    let request = new XMLHttpRequest();
    request.open(&quot;GET&quot;, &quot;http://www.example.com/api/version&quot;);
    request.send();

    // Register a callback that will be invoked when the response arrives
    request.onload = function() {
        if (request.status === 200) {
            // If HTTP status is good, get version number and call callback.
            let currentVersion = parseFloat(request.responseText);
            versionCallback(null, currentVersion);
        } else {
            // Otherwise report an error to the callback
            versionCallback(response.statusText, null);
        }
    };
    // Register another callback that will be invoked for network errors
    request.onerror = request.ontimeout = function(e) {
        versionCallback(e.type, null);
    };
}
</code></pre>

<p>客户端 JavaScript 代码可以使用 XMLHttpRequest 类以及回调函数来发出 HTTP 请求，并在服务器响应时异步处理。<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 这里定义的 getCurrentVersionNumber() 函数（我们可以假设在 §13.1.1 提到的 checkForUpdates() 函数使用了该函数）发出 HTTP 请求并定义事件处理程序，该事件处理程序将在收到服务器的响应或超时或其他异常导致请求失败时被调用。</p>

<p>请注意，上面的代码示例未像前面的示例那样调用 addEventListener()。对于大多数 Web API（包括此API），可以通过在生成事件的对象上调用 addEventListener() 并将事件的名称与回调函数一起传递来定义事件处理程序。不过，通常，也可以通过将单个事件侦听器直接分配给对象的属性来注册它。这就是我们在此示例代码中所做的，将函数分配给 onload、onerror 和 ontimeout 属性。按照惯例，此类事件侦听器属性的名称始终以 on 开头。 addEventListener() 是更灵活的技术，因为它允许多个事件处理程序。但是，如果确定没有其他代码需要为相同的对象和事件类型注册一个侦听器，则只需将适当的属性设置为回调会更简单。</p>

<p>此示例代码中关于 getCurrentVersionNumber() 函数的另一点注意事项是，由于它发出异步请求，因此无法同步返回调用者感兴趣的值（当前版本号）。相反，调用者传递了一个回调函数，当结果准备就绪或发生异常时调用。在这种情况下，调用方提供了一个回调函数，该函数需要两个参数。如果 XMLHttpRequest 正常工作，则 getCurrentVersionNumber() 会使用 null 为第一个实参和版本号为第二个实参调用回调函数。或者，如果发生异常，则 getCurrentVersionNumber() 会在第一个实参中带有异常详细信息，而在第二个参数中使用 null。</p>

<h3 id="toc_4">13.1.4 Callbacks and Events in Node</h3>

<p>The Node.js server-side JavaScript environment is deeply asynchronous and defines many APIs that use callbacks and events. The default API for reading the contents of a file, for example, is asynchronous and invokes a callback function when the contents of the file have been read:</p>

<pre><code class="language-javascript">const fs = require(&quot;fs&quot;); // The &quot;fs&quot; module has filesystem-related APIs
let options = {           // An object to hold options for our program
    // default options would go here
};

// Read a configuration file, then call the callback function
fs.readFile(&quot;config.json&quot;, &quot;utf-8&quot;, (err, text) =&gt; {
    if (err) {
        // If there was an error, display a warning, but continue
        console.warn(&quot;Could not read config file:&quot;, err);
    } else {
        // Otherwise, parse the file contents and assign to the options object
        Object.assign(options, JSON.parse(text));
    }

    // In either case, we can now start running the program
    startProgram(options);
});
</code></pre>

<p>Node’s fs.readFile() function takes a two-parameter callback as its last argument. It reads the specified file asynchronously and then invokes the callback. If the file was read successfully, it passes the file contents as the second callback argument. If there was an error, it passes the error as the first callback argument. In this example, we express the callback as an arrow function, which is a succinct and natural syntax for this kind of simple operation.</p>

<p>Node also defines a number of event-based APIs. The following function shows how to make an HTTP request for the contents of a URL in Node. It has two layers of asynchronous code handled with event listeners. Notice that Node uses an on() method to register event listeners instead of addEventListener():</p>

<pre><code class="language-javascript">const https = require(&quot;https&quot;);

// Read the text content of the URL and asynchronously pass it to the callback.
function getText(url, callback) {
    // Start an HTTP GET request for the URL
    request = https.get(url);

    // Register a function to handle the &quot;response&quot; event.
    request.on(&quot;response&quot;, response =&gt; {
        // The response event means that response headers have been received
        let httpStatus = response.statusCode;

        // The body of the HTTP response has not been received yet.
        // So we register more event handlers to to be called when it arrives.
        response.setEncoding(&quot;utf-8&quot;);  // We&#39;re expecting Unicode text
        let body = &quot;&quot;;                  // which we will accumulate here.

        // This event handler is called when a chunk of the body is ready
        response.on(&quot;data&quot;, chunk =&gt; { body += chunk; });

        // This event handler is called when the response is complete
        response.on(&quot;end&quot;, () =&gt; {
            if (httpStatus === 200) {   // If the HTTP response was good
                callback(null, body);   // Pass response body to the callback
            } else {                    // Otherwise pass an error
                callback(httpStatus, null);
            }
        });
    });

    // We also register an event handler for lower-level network errors
    request.on(&quot;error&quot;, (err) =&gt; {
        callback(err, null);
    });
}
</code></pre>

<h2 id="toc_5">13.2 Promise</h2>

<p>现在，我们已经见过了客户端和服务器端 JavaScript 环境中基于回调和基于事件的异步编程的示例，我们接着介绍 Promise，这是一种旨在简化异步编程的核心语言特性。</p>

<p>Promise 是描述异步计算结果的对象。该结果可能准备好或尚未准备好，Promise API 故意对此含糊其词：无法同步获取 Promise 的值；只能要求 promise 在值准备好时调用回调函数。如果要像上一节中的 getText() 函数那样定义异步 API，但想使其基于 Promise，则省略 callback 参数，而返回 Promise 对象。然后，调用者可以在此 Promise 对象上注册一个或多个回调，并且在异步计算完成后将调用它们。</p>

<p>因此，最简单的说，promise 只是使用回调的另一种方式。但是，使用它有实际的好处。基于回调的异步编程的一个真正的问题是，通常在回调内部嵌套多层回调，并且代码行缩进程度很高，以至于很难阅读。Promise 允许将这种嵌套的回调作为更线性的 Promise 链重新表达，该链往往更易于阅读和推理。</p>

<p>回调的另一个问题是，它们会使处理异常变得困难。如果异步函数（或异步调用的回调）引发异常，则该异常无法传播回异步操作的发起者。这是关于异步编程的基本事实：它破坏了异常处理。替代方法是使用回调实参和返回值来精心跟踪和传播异常，但这很繁琐且难以正确处理。Promise 通过标准化处理异常的方式以及为异常通过 Promise 链正确传播的方式提供帮助。</p>

<p>请注意，promise 表示单个异步计算的未来结果。但是，它不能用于表示重复的异步计算。例如，在本章的后面，我们将写一个基于 Promise 的 setTieout() 函数替代方法。但是，我们不能使用 Promise 来代替 setInterval()，因为该函数会反复调用回调函数，而 Promise 并不是。同样，我们可以使用 Promise 代替 XMLHttpRequest 对象的“load”事件处理程序，因为该回调仅被调用一次。但是我们通常不会使用 Promise 来代替 HTML 按钮对象的“click”事件处理程序，因为我们通常希望允许用户多次单击按钮。</p>

<p>接下来的小节将：</p>

<ul>
<li>解释 Promise 术语并演示 Promise 的基本用法</li>
<li>展示如何将 Promise 链接起来</li>
<li>演示如何创建自己的基于 Promise 的 API</li>
</ul>

<p><strong>重点</strong><br/>
Promise 一开始似乎很简单，并且 Promise 的基本用例实际上也是简单明了的。但是，除了最简单的用例之外，它们还会使其他任何事情变得令人困惑。对于异步编程，Promise 是一个强大的习惯用法，但是需要深刻理解它们，才能正确、自信地使用它们。但是，它值得花时间来深入理解，我建议仔细阅读这一长篇章。</p>

<h3 id="toc_6">13.2.1 使用 Promise</h3>

<p>随着核心 JavaScript 语言中 Promise 的出现，Web 浏览器已经开始实现基于 Promise 的 API。在上一节中，我们实现了一个 getText() 函数，该函数发出一个异步 HTTP 请求，并将 HTTP 响应的主体作为字符串传递给指定的回调函数。想象一下该函数的一个变体 getJSON()，它可以解析主体 HTTP 响应的形式为 JSON，并返回 Promise 而不是接受回调参数。我们将在本章稍后实现 getJSON() 函数，但现在，让我们看一下如何使用返回 Promise 功能程序函数：</p>

<pre><code class="language-javascript">getJSON(url).then(jsonData =&gt; {
    // This is a callback function that will be asynchronously
    // invoked with the parsed JSON value when it becomes available.
});
</code></pre>

<p>getJSON() 对指定的 URL 启动一个异步 HTTP 请求，当该请求待定时，它返回一个 Promise 对象。Promise 对象定义了 then() 实例方法。我们没有将回调函数直接传递给 getJSON()，而是将其传递给 then() 方法。当 HTTP 响应时，该响应的主体将解析为 JSON，并将所解析的结果值传给我们传递给 then() 的回调函数。</p>

<p>可以将 then() 方法视为回调注册方法，例如用于在客户端 JavaScript 中注册事件处理程序的 addEventListener() 方法。如果多次调用 Promise 对象的 then() 方法，则在完成 promise 的计算后将调用指定的每个函数。</p>

<p>但是，与许多事件侦听器不同，Promise 表示单个计算，并且 then() 注册的每个函数仅被调用一次。值得注意的是，传递给 then() 的函数是异步调用的，即使调用 then() 时异步计算已经完成。</p>

<p>在简单的语法级别上，then() 方法是 Promise 独有的特性，编码中习惯于将 .then() 直接跟随返回 Promise 的函数，而无需将 Promise 对象分配给变量的中间步骤。</p>

<p>常用带有动词命名返回 Promise 的函数和使用 Promise 结果的函数，这些常用语使代码特别容易阅读：</p>

<pre><code class="language-javascript">// Suppose you have a function like this to display a user profile
function displayUserProfile(profile) { /* implementation omitted */ }

// Here&#39;s how you might use that function with a Promise.
// Notice how this line of code reads almost like an English sentence:
getJSON(&quot;/api/user/profile&quot;).then(displayUserProfile);
</code></pre>

<h4 id="toc_7">PROMISE 异常处理</h4>

<p>异步操作，尤其是涉及网络的异步操作，通常会以多种方式失败，并且必须编写健壮的代码来处理不可避免地会发生的异常。</p>

<p>对于 Promise，我们可以通过将第二个函数传递给 then() 方法来实现：</p>

<pre><code class="language-javascript">getJSON(&quot;/api/user/profile&quot;).then(displayUserProfile, handleProfileError);
</code></pre>

<p>Promise 描述在 Promise 对象创建之后发生的异步计算的未来结果。由于计算是在 Promise 对象返回给我们之后执行的，因此该计算无法传统地返回值或引发我们可以捕获的异常。我们传递给 then() 的函数提供了替代方案。当同步计算正常完成时，它仅将其结果返回给其调用者。当基于 Promise 的异步计算正常完成时，它将其结果传递给 then() 的第一个实参函数。</p>

<p>当同步计算中出现问题时，它将引发一个异常，该异常会沿调用堆栈传播，直到有一个 catch 子句来处理它为止。当异步计算运行时，它的调用者不再在堆栈上，因此，如果出现问题，则根本不可能将异常抛出给调用者。</p>

<p>而基于 Promise 的异步计算将异常（通常是某种 Error 对象，尽管这不是必需的）传递给 then() 的第二个函数。因此，在上面的代码中，如果 getJSON() 正常运行，它将其结果传递给 displayUserProfile()。如果出现异常（用户未登录，服务器关闭，用户的 Internet 连接断开，请求超时等），则 getJSON() 会将 Error 对象传递给 handleProfileError()。</p>

<p>实践中，很少有两个函数传递给 then()。在处理 Promise 时，有一种更好更常用的异常处理方式。为了理解它，首先考虑如果 getJSON() 正常完成但 displayUserProfile() 中发生异常该怎么办。当 getJSON() 返回时，该回调函数将异步调用，因此它也是异步的，并且无法有意义地引发异常（因为调用堆栈上没有代码可以处理该异常）。</p>

<p>如下所示，处理此代码中异常的更常用方式：</p>

<pre><code class="language-javascript">getJSON(&quot;/api/user/profile&quot;).then(displayUserProfile).catch(handleProfileError);
</code></pre>

<p>使用此代码，getJSON() 的正常结果仍会传递给 displayUserProfile()，但是 getJSON() 或 displayUserProfile() 中的任何异常（包括 displayUserProfile 抛出的任何异常）都将传递给 handleProfileError()。调用 then() 第一个实参为空，指定的异常处理函数为第二个实参，catch() 方法只是其简写。</p>

<p>在下一节中讨论 Promise 链时，我们将对 catch() 和这个处理异常常用方法作更多的说明。</p>

<h4 id="toc_8">PROMISE 专业术语</h4>

<p>在我们进一步讨论 Promises 之前，需要暂停定义一些术语。现实生活中，我们讨论下人类的诺言，我们说“信守”或“违背”诺言。在讨论 JavaScript Promise 时，用“已兑现（fulfilled）”和“已拒绝（rejected）”。想象一下，已经调用了 Promise 的 then() 方法，并向其传递了两个回调函数。当调用第一个回调，那么我们说 Promise 已兑现。当调用第二个回调，我们则说 Promise 已被拒绝。如果一个 Promise 既不是已兑现也不是已拒绝，那么它就是待定（pending）。一旦 Promise 已兑现或已拒绝，我们就说它已敲定（settled）。请注意，一个 Promise 永远不会同时已兑现和已拒绝。Promise 一旦敲定，就永远不会从已兑现变为已拒绝，反之亦然。</p>

<p>记住我们在本节开始时如何定义 Promise：“Promise 是描述异步计算结果的对象。”重要的是要记住，Promise 不仅仅是注册在某些异步代码完成时运行的回调的抽象方式，它们还描述了异步代码的结果。如果异步代码正常运行（并且 Promise 已兑现），那么该结果实质上就是代码的返回值。而且，如果异步代码无法正常完成（并且 Promise 已拒绝），那么结果将是 Error 对象或其他不是异步的代码可能会抛出的值。任何已敲定的 Promise 都有与其相关的值，并且该值不会改变。如果 Promise 已兑现，则该值是一个返回值，该值将传递给注册为 then() 第一个实参的回调函数。如果 Promise 已拒绝，则该值是某种异常，该异常会传递给使用 catch() 或 then() 的第二个实参注册的回调函数。</p>

<p>我希望对 Promise 术语保持精确的原因是 Promise 还可以被决议。将已决议状态与已兑现状态或已敲定状态混淆是很容易的，但是三者都不完全相同。理解已决议状态是深入了解 Promise 的关键之一，在下面讨论了 Promise 链之后，我将再次介绍它。</p>

<h3 id="toc_9">13.2.2 Promise 链</h3>

<p>Promise 的最重要的好处之一是，它们提供了一种自然的方式来表达一系列异步操作，表示 then() 方法调用的线性链，而不必将每个操作嵌套在前一个回调中。例如，一个假设的 Promise 链：</p>

<pre><code class="language-javascript">fetch(documentURL)                      // Make an HTTP request
    .then(response =&gt; response.json())  // Ask for the JSON body of the response
    .then(document =&gt; {                 // When we get the parsed JSON
        return render(document);        // display the document to the user
    })
    .then(rendered =&gt; {                 // When we get the rendered document
        cacheInDatabase(rendered);      // cache it in the local database.
    })
    .catch(error =&gt; handle(error));     // Handle any errors that occur
</code></pre>

<p>此代码表明了 Promise 链如何简化一系列异步操作。我们不会讨论这个特殊的 Promise 链。但是，我们将继续探索使用 Promise 链发出 HTTP 请求的想法。 </p>

<p>在本章的前面，我们看到了 XMLHttpRequest 对象，该对象用于在 JavaScript 中发出 HTTP 请求。这个奇怪命名的对象具有一个旧且笨拙的 API，并且在很大程度上已被较新的基于 Promise 的 Fetch API（§15.11.1）所取代。以最简单的形式，这个新的 HTTP API 只是 fetch() 函数。给它传递一个 URL，然后返回一个 Promise。当 HTTP 开始收到响应并且 HTTP 状态和标头可用时，这个 promise 已兑现：</p>

<pre><code class="language-javascript">fetch(&quot;/api/user/profile&quot;).then(response =&gt; {
    // When the promise resolves, we have status and headers
    if (response.ok &amp;&amp;
        response.headers.get(&quot;Content-Type&quot;) === &quot;application/json&quot;) {
        // What can we do here? We don&#39;t actually have the response body yet.
    }
});
</code></pre>

<p>当 fetch() 返回的 Promise 已兑现时，它将 Response 对象传递给传递给 then() 方法的函数。此响应对象可以访问请求状态和标头，并且还定义了诸如 text() 和 json() 之类的方法，这些方法可以分别以文本和 JSON 的形式访问响应的正文。但是，尽管最初的 Promise 已兑现，但响应的主体可能尚未到达。因此，这些用于访问响应正文的 text() 和 json() 方法本身返回 Promise。这是使用 fetch() 和 response.json() 方法获取 HTTP Response 响应正文的一种简单方法： </p>

<pre><code class="language-javascript">fetch(&quot;/api/user/profile&quot;).then(response =&gt; {
    response.json().then(profile =&gt; {  // Ask for the JSON-parsed body
        // When the body of the response arrives, it will be automatically
        // parsed as JSON and passed to this function.
        displayUserProfile(profile);
    });
});
</code></pre>

<p>这是 Promise 一种没经验的使用方式，因为我们像回调一样嵌套了它们，这违背了目的。首选常用方法是在顺序链中使用 Promise，其代码如下所示： </p>

<pre><code class="language-javascript">fetch(&quot;/api/user/profile&quot;)
    .then(response =&gt; {
        return response.json();
    })
    .then(profile =&gt; {
        displayUserProfile(profile);
    });
</code></pre>

<p>让我们看一下这段代码中的方法调用，忽略传递给方法的参数： </p>

<pre><code class="language-javascript">fetch().then().then()
</code></pre>

<p>当像这样在单个表达式中调用多个方法时，我们将其称为方法链。我们知道 fetch() 函数返回一个 Promise 对象，并且可以看到该链中的第一个 .then() 作为返回的 Promise 对象的方法调用。但是链中还有第二个 .then()，这意味着 then() 方法的第一次调用本身一定返回 Promise。</p>

<p>有时，当一个 API 设计为使用这种方法链接时，只有一个对象，并且该对象的每个方法都返回该对象本身以便于链接。但是，这不是 Promise 的工作方式。当我们编写一系列的 .then() 调用时，我们并未在单个 Promise 对象上注册多个回调。而是，对 then() 方法的每次调用都会返回一个新的 Promise 对象。在传递给 then() 的函数完成之前，新的 Promise 对象不会被兑现。</p>

<p>让我们回到上面原始 fetch() 链的简化形式。如果我们在其他地方定义传递给 then() 调用的函数，则可以将代码重构为如下形式：</p>

<pre><code class="language-javascript">fetch(theURL)          // task 1; returns promise 1
    .then(callback1)   // task 2; returns promise 2
    .then(callback2);  // task 3; returns promise 3
</code></pre>

<p>让我们详细介绍这段代码：</p>

<ol>
<li>在第一行，使用 URL 调用 fetch()。它针对该 URL 发起 HTTP GET请求并返回 Promise。我们将这个 HTTP 请求称为“task 1”，将 Promise 称为“promise 1”。</li>
<li>在第二行，我们调用 promise 1 的 then() 方法，并传递 promise 1 在已兑现时要调用的 callback1 函数。then() 方法将回调函数存储在某个位置，然后返回一个新的 Promise。我们将在这一步返回的新 Promise 称为“promise 2”，并且我们说当 callback1 被调用时“task 2”开始。</li>
<li>在第三行，我们调用 promise 2 的 then() 方法，并传递 promise 2 在已兑现时要调用的 callback2 函数。这个 then() 方法会记住我们的回调并返回另一个 Promise。我们说“task 3”是在调用 callback2 时开始的。我们可以将最新的 Promise 称为“promise 3”，但是我们并不需要它的名称，因为我们根本不会使用它。</li>
<li>最初执行表达式时，前三个步骤都是同步发生的。现在，在第 1 步中启动的 HTTP 请求通过 Internet 发送时，我们有了异步暂停。</li>
<li>最终，HTTP 响应开始到达。fetch() 调用的异步部分将 HTTP 状态和标头包装在 Response 对象中，并以该 Response 对象作为值来兑现 promise 1。</li>
<li>promise 1 已兑现后，其值（Response 对象）将传递到我们的 callback1() 函数，task 2 开始。以 Response 对象作为输入，此任务的工作是获得响应主体转化为 JSON 对象。</li>
<li>假设 task 2 正常完成，并且能够解析 HTTP 响应主体以生成 JSON 对象。此 JSON 对象用于兑现 promise 2。</li>
<li>兑现 promise 2 的值在传递给 callback2() 函数时成为 task 3 的输入。现在，第三个任务以某种未指定的方式向用户显示数据。当 task 3 完成时（假设它正常完成），则 promise 3 将被兑现。但是，因为我们从未对 promise 3 做任何事情，所以当 promise 3 敲定时，什么也没有发生，并且异步计算链到此结束。 </li>
</ol>

<h3 id="toc_10">13.2.3 Promise 决议</h3>

<p>在上一部分中用列表解释 URL-fetching Promise 链时，我们讨论了 promise 1、2 和 3。但是实际上也涉及第四个 Promise 对象，并且这为我们带来重要的讨论————什么是 Promise 的“已决议（resolved）”状态 。 </p>

<p>请记住，fetch() 返回一个 Promise 对象，当其已兑现时，它将 Response 对象传递给我们注册的回调函数。此 Response 对象具有 .text()、.json() 和其他方法，以各种形式请求 HTTP 响应的主体。但是由于主体可能尚未到达，因此这些方法必须返回 Promise 对象。在我们一直在研究的示例中，“task 2”调用 .json() 方法并返回其值。这是第四个 Promise 对象，它是 callback1() 函数的返回值。</p>

<p>让我们以冗长且非常用方式再次重写 URL-fetching 代码，使回调和 Promise 明确化：</p>

<pre><code class="language-javascript">function c1(response) {               // callback 1
    let p4 = response.json();
    return p4;                        // returns promise 4
}

function c2(profile) {                // callback 2
    displayUserProfile(profile);
}

let p1 = fetch(&quot;/api/user/profile&quot;);  // promise 1, task 1
let p2 = p1.then(c1);                 // promise 2, task 2
let p3 = p2.then(c2);                 // promise 3, task 3
</code></pre>

<p>为了使 Promise 链有效地工作，task 2 的输出必须成为 task 3 的输入。在此示例中，我们在这里考虑的是，task 3 的输入是从 URL 所获取的的主体，将其解析为 JSON 对象。但是，正如我们刚刚讨论的那样，回调 c1 的返回值不是 JSON 对象，而是该 JSON 对象的 Promise p4。这似乎有矛盾，但并非如此：当 p1 已兑现时，将调用 c1，并且 task 2 开始。当 p2 已兑现时，c2 被调用，task 3 开始。但是，仅仅因为 c1 被调用时开始 task 2 ，可这并不意味着 task 2 必须在 c1 返回时结束。毕竟，Promise 是关于管理异步任务的，如果 task 2 是异步的（在本例中为异步），则在回调返回时该任务将不会完成。</p>

<p>现在我们准备讨论最后的细节，需要了解这些才能真正掌握 Promise。当将回调 c 传递给 then() 方法时，then() 返回 Promise p 并安排在以后的某个时间异步调用  c。调执行一些计算并返回值 v。当回调返回时，p 用值 v 决议。当 Promise 使用不是本身的 Promise 值决议时，立即用该值兑现。因此，如果 c 返回一个非 Promise，则返回值成为 p 的值，则 p 已兑现并且任务完成。但是，如果返回值 v 本身是一个 Promise，则 p 已决议但尚未兑现。在此阶段，直到 Promise v 敲定，p 才能敲定。如果 v 已兑现，则 p 将被兑现为相同的值。如果 v 已拒绝，则 p 将因相同的原因而被拒绝。这就是一个 Promise 的“已决议（resolved）”状态的含义：Promise 已与另一个 Promise 关联或“锁定”。我们尚不知道 p 是已兑现还是拒绝，但是我们的回调 c 对此不再具有任何控制权。p 是“已决议”的，从这一方面来说它命运现在完全取决于 Promise v 会发生什么。</p>

<p>让我们回到我们的 URL-fetching 示例中。 当 c1 返回 p4 时，p2 已决议。但是已决议与已兑现并不相同，因此 task 3 尚未开始。当 HTTP 响应的全文可用时，.json() 方法可以对其进行解析，并使用该解析后的值来已兑现 p4。 当 p4 已兑现时，也会使用相同的已解析 JSON 值自动已兑现 p2。此时，已解析的 JSON 对象将传递给 c2，然后 task 3 开始。</p>

<p>这可能是 JavaScript 最难理解的部分之一，可能需要多次阅读本节。图 13-1 以可视形式显示了该过程，可能有助于对其进行说明。</p>

<p>图 13-1 用 Promise 获取 URL<br/>
<img src="media/16130963623880/fg13-1.png" alt="fg13-1"/></p>

<h3 id="toc_11">13.2.4 更多关于 Promise 和异常</h3>

<p>在本章的前面，我们看到可以将第二个回调函数传递给 .then() 方法，并且如果 Promise 被拒绝，则将调用该第二个函数。发生这种情况时，第二个回调函数的实参是一个值（通常是一个 Error 对象），它表示拒绝的原因。我们还了解到，将两个回调传递给 .then() 方法并不常见（甚至是单例的）。相反，通常通过向 Promise 链添加 .catch() 方法调用来处理与 Promise 相关的异常。现在我们已经检查了 Promise 链，我们可以返回异常处理并更详细地讨论它。在开始讨论之前，我想强调指出，进行异步编程时，仔细的异常处理非常重要。使用同步代码，如果省略了异常处理代码，则至少会得到一个异常和一个堆栈跟踪，可用于找出问题所在。对于异步代码，未处理的异常通常不会报告，异常可以静默发生，从而使调试更加困难。好消息是，使用 .catch() 方法可以更轻松地处理 Promise 的异常。</p>

<h4 id="toc_12">CATCH 和 FINALLY 方法</h4>

<p>.then() 可以处理异常，使用 null 为第一个实参，而异常处理回调为第二个实参，Promise 的 .catch() 方法只是这种 .then() 调用的一种简便写法。给定 Promise p 和回调 c，以下两行代码是等效的：</p>

<pre><code class="language-javascript">p.then(null, c);
p.catch(c);
</code></pre>

<p>首选 .catch() 速记，因为它更简单，并且名称与 try/catch 异常处理语句中的 catch 子句匹配。正如我们所讨论的，普通例外不适用于异步代码。Promise 的 .catch() 方法是一种适用于异步代码的替代方法。当同步代码中出现问题时，我们“使调用堆栈冒泡”描述一个异常，直到找到 catch 块为止。对于异步的 Promise 链，则是“向链下滴”，直到找到 .catch() 调用为止。</p>

<p>在 ES2018 中，Promise 对象还定义了一个 .finally() 方法，其目的类似于 try/catch/finally 语句中的 finally 子句。如果将 .finally() 调用添加到 Promise 链中，那么 .finally() 的调用者 Promise 的敲定的时候，传递给 .finally() 的回调将被调用。如果 Promise 已兑现或已拒绝，则将调用回调，并且它不会再作为实参传递，因此无法确定它是已兑现还是已拒绝。但是，无论哪种情况，如果都需要运行某种清理代码（例如关闭打开的文件或网络连接），则 .finally() 回调是实现此目的的理想方法。与 .then() 和 .catch() 一样，.finally() 返回一个新的 Promise 对象。.finally() 回调的返回值通常被忽略，.finally() 返回的 Promise 通常将以调用 .finally() 的 Promise 相同的值来决议或拒绝。但是，如果 .finally() 回调引发异常，则 .finally() 返回的 Promise 以该异常值拒绝。</p>

<p>我们在上一节中研究的 URL-fetching 代码没有任何异常处理。现在，使用更可行的代码版本进行更正：</p>

<pre><code class="language-javascript">fetch(&quot;/api/user/profile&quot;)    // Start the HTTP request
    .then(response =&gt; {       // Call this when status and headers are ready
        if (!response.ok) {   // If we got a 404 Not Found or similar error
            return null;      // Maybe user is logged out; return null profile
        }

        // Now check the headers to ensure that the server sent us JSON.
        // If not, our server is broken, and this is a serious error!
        let type = response.headers.get(&quot;content-type&quot;);
        if (type !== &quot;application/json&quot;) {
            throw new TypeError(`Expected JSON, got ${type}`);
        }

        // If we get here, then we got a 2xx status and a JSON content-type
        // so we can confidently return a Promise for the response
        // body as a JSON object.
        return response.json();
    })
    .then(profile =&gt; {        // Called with the parsed response body or null
        if (profile) {
            displayUserProfile(profile);
        }
        else { // If we got a 404 error above and returned null we end up here
            displayLoggedOutProfilePage();
        }
    })
    .catch(e =&gt; {
        if (e instanceof NetworkError) {
            // fetch() can fail this way if the internet connection is down
            displayErrorMessage(&quot;Check your internet connection.&quot;);
        }
        else if (e instanceof TypeError) {
            // This happens if we throw TypeError above
            displayErrorMessage(&quot;Something is wrong with our server!&quot;);
        }
        else {
            // This must be some kind of unanticipated error
            console.error(e);
        }
    });
</code></pre>

<p>让我们通过发生异常情况情况来分析此代码。我们将使用之前使用的命名方案：p1 是 fetch() 调用返回的 Promise。p2 是第一个 .then() 调用返回的 Promise，而 c1 是我们传递给该 .then() 的回调。p3 是第二个 .then() 调用返回的 Promise，而 c2 是我们传递给该调用的回调。最后，c3 是我们传递给 .catch() 的回调。（该调用返回一个 Promise，但我们不需要按名称引用它。）</p>

<p>第一个可能失败的是 fetch() 请求本身。如果网络连接断开（或由于某些其他原因而无法发出 HTTP 请求），则 Promise p1 将被 NetworkError 对象拒绝。我们没有将异常处理回调函数作为 .then() 调用的第二个实参传递，因此 p2 同样会被相同的 NetworkError 对象拒绝。（如果将异常处理程序传递给第一个 .then() 调用，则将调用该异常处理程序，并且如果该异常处理程序正常返回，伴随处理的返回值，p2 变为已决议和或或已兑现。）但是，出于相同的原因，p2 被拒绝，然后 p3 被拒绝。此时，将调用 c3 异常处理回调，并在其中运行特定于 NetworkError 的代码。</p>

<p>代码失败的另一种方式是，如果我们的 HTTP 请求返回 404 Not Found 或另一个 HTTP 异常。这些是有效的 HTTP 响应，因此 fetch() 调用不会将其视为异常。fetch() 在 Response 对象中封装了一个 404 Not Found，并用该对象已兑现 p1，从而导致 c1 被调用。我们在 c1 中的代码检查 Response 对象的 ok 属性，以检测它没有收到正常的 HTTP 响应，并通过简单地返回 null 来处理这种情况。因为此返回值不是 Promise，所以它立即已兑现 p2，并使用该值调用 c2。 我们在 c2 中的代码显式检查并处理错误值，并向用户显示不同的结果。在这种情况下，我们将异常情况视为非异常，并在不使用异常处理程序的情况下对其进行处理。</p>

<p>如果我们获得正常的 HTTP 响应代码，但 Content-Type 标头设置不正确，则 c1 中会发生更严重的异常。我们的代码需要一个 JSON 格式的响应，因此，如果服务器发送给我们的是 HTML、XML 或纯文本，那么我们将会遇到问题。c1 包含用于检查 Content-Type 标头的代码。如果标头错误，则将其视为不可恢复的问题，并引发 TypeError。当传递给 .then()（或 .catch()）的回调引发一个值时，作为 .then() 调用的返回的 Promise 将被该抛出的值拒绝。在这种情况下，c1 中的代码引发 TypeError 导致带有 TypeError 对象的 p2 一起被拒绝。由于我们没有为 p2 指定异常处理程序，因此 p3 也将被拒绝。c2 将不会被调用，并且 TypeError 将传递给 c3，后者具有显式检查和处理此类异常的代码。</p>

<p>关于此代码有些得注意。首先，请注意用常规的同步 throw 语句引发的异常对象最终会通过 Promise 链中的 .catch() 方法调用进行异步捕获。这清楚表明为什么与将第二个实参传递给 .then() 相比更偏向使用这种速记方法，以及为什么习惯以 .catch() 调用结束 Promise 链。</p>

<p>在我们结束异常处理主题之前，我想指出，尽管习惯于在每个 Promise 链中添加一个 .catch() 来清理（或至少记录日志）该链中发生的任何异常，但是在 Promise 链中的其他位置使用 .catch() 也完全有效。如果 Promise 链中的某一阶段可能因异常而失败，并且该异常是某种可恢复的异常，并且该异常不会阻止链的其余部分运行，则可以在链中插入 .catch() 调用，代码可能如下所示：</p>

<pre><code class="language-javascript">startAsyncOperation()
    .then(doStageTwo)
    .catch(recoverFromStageTwoError)
    .then(doStageThree)
    .then(doStageFour)
    .catch(logStageThreeAndFourErrors);
</code></pre>

<p>请记住，仅当前一阶段的回调引发异常时，才会调用传递给 catch() 的回调。如果该回调正常返回，则将跳过 catch() 回调，并且前一个回调的返回值将成为下一个 then() 回调的输入。还请记住，catch() 回调不仅用于异常报告，而且用于异常处理并从异常中恢复。将异常传递给 catch() 回调后，它将停止沿 Promise 链传播。catch() 回调可以引发新的异常，但是如果它正常返回，则该返回值用于决议和或或兑现关联的 Promise，并且异常停止传播。</p>

<p>让我们具体地讲一下：在前面的代码示例中，如果 startAsyncOperation() 或 doStageTwo() 引发异常，则将调用 recoveryFromStageTwoError() 函数。如果 restoreFromStageTwoError() 正常返回，则其返回值将传递给 doStageThree()，并且异步操作将正常继续。另一方面，如果 recoverFromStageTwoError() 无法恢复，则它本身将引发异常（或者重新抛出传入的异常）。在这种情况下，不会调用 doStageThree() 或 doStageFour()，并且 recoverFromStageTwoError() 引发的异常将传递给 logStageThreeAndFourErrors()。</p>

<p>有时，在复杂的网络环境中，异常可能会或多或少地随机发生，并且可以通过简单地重试异步请求来处理这些异常。假设编写了一个基于 Promise 的操作来查询数据库：</p>

<pre><code class="language-javascript">queryDatabase()
    .then(displayTable)
    .catch(displayDatabaseError);
</code></pre>

<p>现在，假设大约 1％ 的概率瞬态网络负载问题导致其失败。一个简单的解决方案可能是使用 .catch() 调用重试查询：</p>

<pre><code class="language-javascript">queryDatabase()
    .catch(e =&gt; wait(500).then(queryDatabase))  // On failure, wait and retry
    .then(displayTable)
    .catch(displayDatabaseError);
</code></pre>

<p>如果假设的失败确实是随机的，那么添加这一行代码应使错误率从 1％ 降低到 .01％。</p>

<h4 id="toc_13">从 PROMISE 回调函数返回</h4>

<p>让我们最后一次返回前面的 URL-fetching 示例，并考虑传递给第一个 .then() 调用的回调 c1。注意，c1 可以通过三种方式终止。它可以通过 .json() 调用返回的 Promise 正常返回。这将导致 p2 变为已决议，但是该 Promise 是已兑现还是拒绝取决于新返回的 Promise 发生了什么。c1 也可以正常返回 null 值，这将导致 p2 立即变成已兑现。最后，c1 可以通过引发异常来终止，从而导致 p2 变成已拒绝。这是 Promise 的三个可能结果，而 c1 中的代码演示了回调如何导致每个结果。</p>

<p>在 Promise 链中，在链的一个阶段返回（或抛出）的值成为链的下一阶段的输入，因此正确实现这一点至关重要。实际上，回调函数忘记返回值是与 Promise 相关的常见错误，而 JavaScript 的箭头函数快捷语法会加剧这种情况。回想一下我们之前看到的以下代码行：</p>

<pre><code class="language-javascript">.catch(e =&gt; wait(500).then(queryDatabase))
</code></pre>

<p>回顾第 8 章，箭头函数提供了许多快捷方式。由于仅存在一个参数（异常值），因此我们可以省略括号。由于函数的主体是单个表达式，因此我们可以省略函数主体周围的花括号，并且表达式的值成为函数的返回值。由于这些快捷方式，前面的代码是正确的。但是考虑一下这种无害的变化：</p>

<pre><code class="language-javascript">.catch(e =&gt; { wait(500).then(queryDatabase) })
</code></pre>

<p>通过添加花括号，我们不再获得自动返回。现在，此函数返回 undefined 而不是返回 Promise，这意味着将以 undefined 作为输入而不是重试查询的结果来调用此 Promise 链中的下一个阶段。这是一个细微的错误，可能不容易调试。</p>

<h3 id="toc_14">13.2.5 并行 Promise</h3>

<p>我们花了很多时间讨论 Promise 链，这些链可按顺序运行较大的异步的操作步骤。但是，有时我们想并行执行许多异步操作。函数 Promise.all() 可以做到这一点。Promise.all() 将 Promise 对象数组作为其输入，并返回 Promise。如果任何输入的 Promise 中有一个是已拒绝状态，则返回的 Promise 将被拒绝。否则，它将使用每个输入 Promise 的兑现值组成的数组来被兑现。因此，例如，如果要获取多个 URL 的文本内容，则可以使用如下代码：</p>

<pre><code class="language-javascript">// We start with an array of URLs
const urls = [ /* zero or more URLs here */ ];
// And convert it to an array of Promise objects
promises = urls.map(url =&gt; fetch(url).then(r =&gt; r.text()));
// Now get a Promise to run all those Promises in parallel
Promise.all(promises)
    .then(bodies =&gt; { /* do something with the array of strings */ })
    .catch(e =&gt; console.error(e));
</code></pre>

<p>Promise.all() 比前面描述的要灵活一些。输入数组可以包含 Promise 对象和非 Promise 值。如果数组的元素不是 Promise，则将其视为已兑现的 Promise 的值，并原封不动地复制到输出数组中。</p>

<p>当任何输入的 Promise 被拒绝时，Promise.all() 返回的 Promise 也会被拒绝。这在第一次拒绝时立即发生，可能其他输入 Promise 仍是待定状态。在 ES2020 中，Promise.allSettled() 接受输入的 Promise 数组，并返回 Promise，就像 Promise.all() 一样。但是 Promise.allSettled() 永远不会拒绝返回的 Promise，并且不会兑现这个 Promise，直到所有输入 Promise 全部已敲定。Promise 解析为一组对象，每个输入 Promise 都有一个对象。每个返回的对象中有一个状态属性设置为“已兑现”或“已拒绝”。如果状态为“已兑现”，则对象还将具有一个 value 属性，该属性提供兑现值。并且，如果状态为“已拒绝”，则对象还将具有一个 reason 属性，该属性给出相应的 Promise 的异常或拒绝值：</p>

<pre><code class="language-javascript">Promise.allSettled([Promise.resolve(1), Promise.reject(2), 3]).then(results =&gt; {
    results[0]  // =&gt; { status: &quot;fulfilled&quot;, value: 1 }
    results[1]  // =&gt; { status: &quot;rejected&quot;, reason: 2 }
    results[2]  // =&gt; { status: &quot;fulfilled&quot;, value: 3 }
});
</code></pre>

<p>有时，可能想一次运行多个 Promise，但可能只关心第一个要兑现的值。在这种情况下，可以使用 Promise.race() 代替 Promise.all()。当输入数组中的第一个 Promise 是已兑现或已拒绝状态时，它返回一个已兑现或已拒绝的 Promise。（或者，如果输入数组中有任何非 Promise 值，则只返回其中的第一个。）</p>

<h3 id="toc_15">13.2.6 构造 Promise</h3>

<p>在之前的许多示例中，我们都使用了 Promise 返回函数 fetch()，因为它是内置于 Web 浏览器中的最简单的返回 Promise 的函数之一。我们对 Promise 的讨论还依赖于假设的 Promise 返回函数 getJSON() 和 wait()。编写用于返回 Promise 的函数确实非常有用，本节说明如何创建自己的基于 Promise 的 API。特别是，我们将展示 getJSON() 和 wait() 的实现。</p>

<h4 id="toc_16">PROMISE 基于别的 PROMISE</h4>

<p>如果以 Promise 返回函数作为开头来写一个返回 Promise 的函数是很容易的。有了 Promise，总是可以通过调用 .then() 创建（并返回）一个新的 Promise。因此，如果我们使用现有的 fetch() 函数作为起点，则可以这样编写 getJSON()：</p>

<pre><code class="language-javascript">function getJSON(url) {
    return fetch(url).then(response =&gt; response.json());
}
</code></pre>

<p>该代码很简单，因为 fetch() API 的 Response 对象具有预定义的 json() 方法。我们从回调（该回调是带有单个表达式主体的箭头函数，因此返回值是隐式的）中通过 json() 方法返回一个 Promise，因此 getJSON() 返回的 Promise 解析为 response.json()。当该 Promise 兑现时，由 getJSON() 返回的 Promise 将兑现为相同的值。请注意，此 getJSON() 实现中没有异常处理。如果不能将 response 主体解析为 JSON，则无需检查 response.ok 和 Content-Type 标头，而只需允许 json() 方法拒绝它的 Promise 并返回 SyntaxError。</p>

<p>让我们编写另一个 Promise 返回函数，这次使用 getJSON() 作为初始 Promise 的来源：</p>

<pre><code class="language-javascript">function getHighScore() {
    return getJSON(&quot;/api/user/profile&quot;).then(profile =&gt; profile.highScore);
}
</code></pre>

<p>我们假设此函数是某种基于网络的游戏的一部分，并且 URL“/api/user/profile”返回的是包含 highScore 属性的 JSON 格式的数据结构。</p>

<h4 id="toc_17">PROMISE 基于同步值</h4>

<p>有时，即使要执行的计算实际上不需要任何异步操作，也可能需要实现现有的基于 Promise 的 API 并从函数返回 Promise。在这种情况下，静态方法 Promise.resolve() 和 Promise.reject() 会做您想要的。Promise.resolve() 采用一个单个实参值，并返回一个 Promise，该 Promise 将立即（但异步地）兑现为该值。同样，Promise.reject() 接受一个实参值，并返回一个 Promise，该值将作为被拒绝的原因。（请注意：这些静态方法返回的 Promise 在返回时尚未兑现或拒绝，但是它们将在当前同步代码块运行完毕后立即兑现或拒绝。通常，这种情况会在几毫秒内发生，除非有许多等待执行的待处理异步任务。）</p>

<p>回顾 §13.2.3，已决议的 Promise 与已兑现的 Promise 不同。当我们调用 Promise.resolve() 时，通常会传递兑现值以创建一个 Promise 对象，该对象将很快兑现该值。但是，该方法未命名为 Promise.fulfill()。如果将 Promise p1 传递给 Promise.resolve()，它将返回一个新的 Promise p2，该 p2 立即被决议，但是直到 p1 被兑现或拒绝，该 Promise p2 才会被兑现或拒绝。 </p>

<p>可以（但不常见）编写一个基于 Promise 的函数，同步计算的值通过通过 Promise.resolve() 异步返回。但是，在异步函数中包含同步特殊情况是很常见的，可以使用 Promise.resolve() 和 Promise.reject() 处理这些特殊情况。特别是，如果在开始异步操作之前检测到异常条件（例如异常的实参值），则可以通过返回使用 Promise.reject() 创建的 Promise 来报告该异常。（在这种情况下，也可以同步引发异常，但这被认为是较差的形式，因为函数的调用者需要同时编写同步 catch 子句并使用异步 .catch() 方法来处理异常。）最后，Promise.resolve() 有时可用于在 Promise 链中创建初始 Promise。我们将看到几个使用这种方式的示例。 </p>

<h4 id="toc_18">构造函数创建 PROMISE</h4>

<p>对于 getJSON() 和 getHighScore()，我们首先调用现有函数以获取初始 Promise，然后通过调用该初始 Promise 的 .then() 方法创建并返回新的 Promise。但是，当不能使用另一个返回 Promise 函数作为起点时，如何编写返回 Promise 函数呢？在这种情况下，可以使用 Promise() 构造函数创建一个可以完全控制的新 Promise 对象。它是这样工作的：调用 Promise() 构造函数并将一个函数作为唯一实参传递。传递的函数应编写为包含两个参数，按照惯例，应将其命名为 resolve 和 reject。构造函数会同步调用使用 resolve 和 reject 参数的函数。调用函数后，Promise() 构造函数将返回新创建的 Promise。返回的 Promise 受传递给构造函数的函数的控制。该函数应该执行一些异步操作，然后调用 resolve 函数来决议或兑现返回的 Promise，或者调用 reject 函数来拒绝返回的 Promise。函数不必是异步的：它可以同步地调用 resolve 或拒绝，但是如果这样做，Promise 仍将被异步地决议，兑现或拒绝。</p>

<p>仅仅阅读一下很难理解传递给构造函数的函数，但是希望有一些例子可以使这一点变得清楚。这是在本章前面的各种示例中使用的基于 Promise 的 wait() 函数的编写方法：</p>

<pre><code class="language-javascript">function wait(duration) {
    // Create and return a new Promise
    return new Promise((resolve, reject) =&gt; { // These control the Promise
        // If the argument is invalid, reject the Promise
        if (duration &lt; 0) {
            reject(new Error(&quot;Time travel not yet implemented&quot;));
        }
        // Otherwise, wait asynchronously and then resolve the Promise.
        // setTimeout will invoke resolve() with no arguments, which means
        // that the Promise will fulfill with the undefined value.
        setTimeout(resolve, duration);
    });
}
</code></pre>

<p>请注意，用于控制由 Promise() 构造函数创建的 Promise 命运的一对函数分别命名为 resolve() 和 reject()，而不是 fulfill() 和 reject()。如果传递一个 Promise 给 resolve()，则返回的 Promise 将决议于该新的 Promise。但是，通常会传递一个非 Promise 值，返回的 Promise 会兑现这个值。</p>

<p>示例 13-1 是使用 Promise() 构造函数的另一个示例。这一节实现了 Node 中在未内置 fetch() API 使用的 getJSON() 函数。请记住，本章开始时讨论了异步回调和事件。此示例同时使用了回调和事件处理程序，因此很好地演示了如何在其他风格的异步编程之上实现基于 Promise 的 API。</p>

<p>示例 13-1 异步 getJSON() 函数</p>

<pre><code class="language-javascript">const http = require(&quot;http&quot;);

function getJSON(url) {
    // Create and return a new Promise
    return new Promise((resolve, reject) =&gt; {
        // Start an HTTP GET request for the specified URL
        request = http.get(url, response =&gt; { // called when response starts
            // Reject the Promise if the HTTP status is wrong
            if (response.statusCode !== 200) {
                reject(new Error(`HTTP status ${response.statusCode}`));
                response.resume();  // so we don&#39;t leak memory
            }
            // And reject if the response headers are wrong
            else if (response.headers[&quot;content-type&quot;] !== &quot;application/json&quot;) {
                reject(new Error(&quot;Invalid content-type&quot;));
                response.resume();  // don&#39;t leak memory
            }
            else {
                // Otherwise, register events to read the body of the response
                let body = &quot;&quot;;
                response.setEncoding(&quot;utf-8&quot;);
                response.on(&quot;data&quot;, chunk =&gt; { body += chunk; });
                response.on(&quot;end&quot;, () =&gt; {
                    // When the response body is complete, try to parse it
                    try {
                        let parsed = JSON.parse(body);
                        // If it parsed successfully, fulfill the Promise
                        resolve(parsed);
                    } catch(e) {
                        // If parsing failed, reject the Promise
                        reject(e);
                    }
                });
            }
        });
        // We also reject the Promise if the request fails before we
        // even get a response (such as when the network is down)
        request.on(&quot;error&quot;, error =&gt; {
            reject(error);
        });
    });
}
</code></pre>

<h3 id="toc_19">13.2.7 连续的 Promise</h3>

<p>Promise.all() 使得并行运行任意数量的 Promise 变得容易。Promise 链使表达固定数量的 Promise 序列变得容易。但是，依次执行任意数量的 Promise 会比较棘手。例如，假设您要获取一组 URL，但是为了避免网络过载，希望一次获取一个 URL。如果数组的长度是任意的且内容未知，则无法提前写出 Promise 链，因此需要使用以下代码动态构建一个：</p>

<pre><code class="language-javascript">function fetchSequentially(urls) {
    // We&#39;ll store the URL bodies here as we fetch them
    const bodies = [];

    // Here&#39;s a Promise-returning function that fetches one body
    function fetchOne(url) {
        return fetch(url)
            .then(response =&gt; response.text())
            .then(body =&gt; {
                // We save the body to the array, and we&#39;re purposely
                // omitting a return value here (returning undefined)
                bodies.push(body);
            });
    }

    // Start with a Promise that will fulfill right away (with value undefined)
    let p = Promise.resolve(undefined);

    // Now loop through the desired URLs, building a Promise chain
    // of arbitrary length, fetching one URL at each stage of the chain
    for(url of urls) {
        p = p.then(() =&gt; fetchOne(url));
    }

    // When the last Promise in that chain is fulfilled, then the
    // bodies array is ready. So let&#39;s return a Promise for that
    // bodies array. Note that we don&#39;t include any error handlers:
    // we want to allow errors to propagate to the caller.
    return p.then(() =&gt; bodies);
}
</code></pre>

<p>定义了这个 fetchSequentially() 函数之后，我们可以用一个代码一次来获取多个 URL，就像我们之前用来演示 Promise.all() 的并行获取代码一样：</p>

<pre><code class="language-javascript">fetchSequentially(urls)
    .then(bodies =&gt; { /* do something with the array of strings */ })
    .catch(e =&gt; console.error(e));
</code></pre>

<p>fetchSequentially() 函数首先创建一个 Promise，该 Promise 将在返回后立即兑现。然后，它从该初始 Promise 构建一个长的线性 Promise 链，并返回链中的最后一个 Promise。这就像设置一排多米诺骨牌，然后将第一个多米诺骨牌撞倒一样。</p>

<p>我们可以采用另一种方法（可能更优雅）。除了提前创建 Promise 外，我们还可以为每个 Promise 创建回调，并返回下一个 Promise。也就是说，我们没有创建和链接一堆 Promise，而是创建了决议于其他承诺的承诺。与其创建类似多米诺骨牌的 Promise 链，不如创建一系列彼此嵌套在一起的 Promise 序列，就像俄罗斯套娃一样。使用这种方法，我们的代码可以知道第一个（最外面的）Promise 最终将兑现（或拒绝！），使其返回序列中最后一个（最里面的）Promise 相同的值。后面是通用的 promiseSequence() 函数，并不特定于 URL 提取。因为它很复杂，所以将它放在我们对 Promise 的讨论的结尾。但是，如果仔细阅读了本章，希望能理解它的工作原理。特别要注意的是，promiseSequence() 中的嵌套函数类似递归地调用自身，但是由于“递归”调用是通过 then() 方法进行的，因此实际上没有发生任何传统的递归：</p>

<pre><code class="language-javascript">// This function takes an array of input values and a &quot;promiseMaker&quot; function.
// For any input value x in the array, promiseMaker(x) should return a Promise
// that will fulfill to an output value. This function returns a Promise
// that fulfills to an array of the computed output values.
//
// Rather than creating the Promises all at once and letting them run in
// parallel, however, promiseSequence() only runs one Promise at a time
// and does not call promiseMaker() for a value until the previous Promise
// has fulfilled.
function promiseSequence(inputs, promiseMaker) {
    // Make a private copy of the array that we can modify
    inputs = [...inputs];

    // Here&#39;s the function that we&#39;ll use as a Promise callback
    // This is the pseudorecursive magic that makes this all work.
    function handleNextInput(outputs) {
        if (inputs.length === 0) {
            // If there are no more inputs left, then return the array
            // of outputs, finally fulfilling this Promise and all the
            // previous resolved-but-not-fulfilled Promises.
            return outputs;
        } else {
            // If there are still input values to process, then we&#39;ll
            // return a Promise object, resolving the current Promise
            // with the future value from a new Promise.
            let nextInput = inputs.shift(); // Get the next input value,
            return promiseMaker(nextInput)  // compute the next output value,
                // Then create a new outputs array with the new output value
                .then(output =&gt; outputs.concat(output))
                // Then &quot;recurse&quot;, passing the new, longer, outputs array
                .then(handleNextInput);
        }
    }

    // Start with a Promise that fulfills to an empty array and use
    // the function above as its callback.
    return Promise.resolve([]).then(handleNextInput);
}
</code></pre>

<p>promiseSequence() 函数是通用的。我们可以使用它通过以下代码来获取 URL：</p>

<pre><code class="language-javascript">// Given a URL, return a Promise that fulfills to the URL body text
function fetchBody(url) { return fetch(url).then(r =&gt; r.text()); }
// Use it to sequentially fetch a bunch of URL bodies
promiseSequence(urls, fetchBody)
    .then(bodies =&gt; { /* do something with the array of strings */ })
    .catch(console.error);
</code></pre>

<h2 id="toc_20">13.3 async 和 await</h2>

<p>ES2017 引入了两个新的关键字（async 和 await）描述异步 JavaScript 编程中的模式转变。这些新关键字极大地简化了 Promises 的使用，使我们能够编写基于 Promise 的异步代码看起来像是等待网络响应或其他异步事件而阻塞的同步代码。尽管了解 Promises 的工作原理仍然很重要，但是当将它们与 async 和 await 一起使用时，它们的大部分复杂性（有时甚至是它们的存在！）就消失了。 </p>

<p>如本章前面所述，异步代码无法像常规同步代码那样返回值或引发异常。这就是为什么 Promise 如此设计的原因。已兑现的 Promise 的值类似于同步函数的返回值。而且已拒绝的 Promise 的值就像同步函数抛出的值。后者通过类似的 .catch() 方法命名，使得表述更清晰。async 和 await 使用高效的、基于 Promise 的代码并隐藏 Promise，以便异步代码可以像低效、阻塞、同步代码一样容易阅读和推理。 </p>

<h3 id="toc_21">13.3.1 await 表达式</h3>

<p>关键字 await 接受一个 Promise，并将其转换为返回值或引发的异常。给定一个 Promise 对象 p，表达式 await p 等待直到 p 敲定。如果 p 兑现，则等待 p 的值就是 p 的兑现值。另一方面，如果 p 被拒绝，则 await p 表达式将抛出 p 的拒绝值。我们通常不将 await 与保存 Promise 的变量一起使用；相反，我们在调用返回 Promise 的函数之前使用它：</p>

<pre><code class="language-javascript">let response = await fetch(&quot;/api/user/profile&quot;);
let profile = await response.json();
</code></pre>

<p>立即了解至关重要的一点是，在指定的 Promise 敲定之前，await 关键字不会导致程序阻塞，并且实际上什么也不做。代码保持异步，并且 await 只是掩盖了这一事实。这意味着使用 await 的任何代码本身都是异步的。 </p>

<h3 id="toc_22">13.3.2 async 函数</h3>

<p>因为任何使用 await 的代码都是异步的，所以有一个关键规则：只能在使用 async 关键字声明的函数中使用 await 关键字。下面是本章前面的 getHighScore() 函数的一个版本，使用 async 和 await 重写：</p>

<pre><code class="language-javascript">async function getHighScore() {
    let response = await fetch(&quot;/api/user/profile&quot;);
    let profile = await response.json();
    return profile.highScore;
}
</code></pre>

<p>异步声明函数意味着函数的返回值将是一个 Promise，即使函数体中没有出现与 Promise 相关的代码。如果异步函数看起来正常返回，那么作为函数实际返回值的 Promise 对象将决议为该返回值。如果一个异步函数出现抛出异常，那么它返回的 Promise 对象将被那个异常拒绝。</p>

<p>getHighScore() 函数被声明为异步，因此它返回一个承诺。因为它返回一个承诺，所以我们可以使用 await 关键字：</p>

<pre><code class="language-javascript">displayHighScore(await getHighScore());
</code></pre>

<p>但是请记住，只有在另一个异步函数中，该行代码才有效！可以根据需要在异步函数中嵌套任何层 await 表达式。但是，如果处于最高级别 <sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup> 或由于某种原因而处于不异步的函数内，那么您无法使用 await 并且必须以常规方式处理返回的 Promise： </p>

<pre><code class="language-javascript">getHighScore().then(displayHighScore).catch(console.error);
</code></pre>

<p>可以将 async 关键字与任何函数一起使用。它用作于 function 关键字作为语句或表达式。它可与箭头函数以及类和对象字面量中的速记方法方式一起使用。（有关如何编写函数的各种方法，请参见第 8 章。） </p>

<h3 id="toc_23">13.3.3 等待多个 Promise</h3>

<p>假设我们已经使用 async 编写了 getJSON() 函数： </p>

<pre><code class="language-javascript">async function getJSON(url) {
    let response = await fetch(url);
    let body = await response.json();
    return body;
}
</code></pre>

<p>并且现在假设我们要用这个方法获取两个 JSON 值：</p>

<pre><code class="language-javascript">let value1 = await getJSON(url1);
let value2 = await getJSON(url2);
</code></pre>

<p>此代码的问题在于，它不必要地是连续的：第二个 URL 的获取要等到第一次获取完成后才能开始。如果第二个 URL 不依赖于从第一个 URL 获得的值，那么我们可能应该尝试同时获取两个值。这是基于 Promise 的异步函数本质的一种情况。为了等待一组并发执行的异步函数，我们使用 Promise.all() 就像直接使用 Promise 一样： </p>

<pre><code class="language-javascript">let [value1, value2] = await Promise.all([getJSON(url1), getJSON(url2)]);
</code></pre>

<h3 id="toc_24">13.3.4 实现详细</h3>

<p>最后，为了了解异步功能是如何工作的，考虑一下幕后发生了什么可能会有所帮助。</p>

<p>假设写这样的一个异步函数：</p>

<pre><code class="language-javascript">async function f(x) { /* body */ }
</code></pre>

<p>可以将其视为包装原始函数主体的 Promise 返回函数：</p>

<pre><code class="language-javascript">function f(x) {
    return new Promise(function(resolve, reject) {
        try {
            resolve((function(x) { /* body */ })(x));
        }
        catch(e) {
            reject(e);
        }
    });
}
</code></pre>

<p>用像这样的语法转换来表达 await 关键字比较困难。但是，将 await 关键字视为将函数主体分解为单独的同步块的标记。ES2017 解释器可以将函数主体分解为一系列单独的子函数，每个子函数都传递给位于其前面 await 标记的 Promise 的 then() 方法。</p>

<h2 id="toc_25">13.4 异步迭代</h2>

<p>在本章的开头我们讨论了基于回调和基于事件的异步，当我们介绍 Promise 时，我们注意到它们对于单次异步计算很有用，但不适用于重复性异步事件的代码，例如 setInterval()，网络浏览器中的“click”事件或 Node 流上的“data”事件。因为单个 Promise 不适用于异步事件序列，所以我们也不能对这些事物使用常规的异步函数和 await 语句。</p>

<p>但是 ES2018 提供了一个解决方案。异步迭代器类似于第 12 章中描述的迭代器，但是它们基于 Promise，并且打算与 for/of 循环一起使用的新形式：for/await。</p>

<h3 id="toc_26">13.4.1 for/await 循环</h3>

<p>Node 12 使其可读流可以异步迭代。这意味着可以使用如下所示的 for/await 循环从流中读取连续的数据块：</p>

<pre><code class="language-javascript">const fs = require(&quot;fs&quot;);

async function parseFile(filename) {
    let stream = fs.createReadStream(filename, { encoding: &quot;utf-8&quot;});
    for await (let chunk of stream) {
        parseChunk(chunk); // Assume parseChunk() is defined elsewhere
    }
}
</code></pre>

<p>像普通的 await 表达式一样，for/await 循环是基于 promise 的。粗略地说，异步迭代器产生一个 Promise，for/await 循环等待该 Promise 兑现，将兑现值分配给循环变量，然后运行循环的主体。然后重新开始，从迭代器中获得另一个 Promise，然后等待该新 Promise 兑现。</p>

<p>假设有一个 URL 数组：</p>

<pre><code class="language-javascript">const urls = [url1, url2, url3];
</code></pre>

<p>可以在每个 URL 上调用 fetch() 以获取一个 promise 数组：</p>

<pre><code class="language-javascript">const promises = urls.map(url =&gt; fetch(url));
</code></pre>

<p>我们在本章的前面已经看到，我们现在可以使用 Promise.all() 等待数组中的所有 promise 都已兌現。但是，假设我们希望第一个提取的结果尽快可用，并且不想等待所有 URL 都被获取。（当然，第一次获取可能比其他任何获取都要花费更长的时间，因此不一定比使用 Promise.all() 更快。）数组是可迭代的，因此我们可以使用常规的 for/of 对数组进行遍历：</p>

<pre><code class="language-javascript">for(const promise of promises) {
    response = await promise;
    handle(response);
}
</code></pre>

<p>此示例代码使用 for/of 循环遍历常规迭代器。但是因为此迭代器返回 Promise，所以我们还可以将新的 for/await 稍微简化下代码：</p>

<pre><code class="language-javascript">for await (const response of promises) {
    handle(response);
}
</code></pre>

<p>在这种情况下，for/await 循环仅将 await 调用构建到循环中，并使我们的代码稍微紧凑一些，但是两个示例的作用完全相同。重要的是，这两个示例只有在声明为异步的函数中时才起作用。for/await 循环与常规 await 表达式没有什么不同。</p>

<p>但是，重要的是要意识到，在此示例中，我们正在使用 for/wait 作用于常规迭代器的。作用于完全异步的迭代器使事情变得更加有趣。</p>

<h3 id="toc_27">13.4.2 异步迭代器</h3>

<p>让我们回顾一下第 12 章中的一些术语。可迭代对象是可以与 for/of 循环一起使用的对象。它定义了一个名称为 Symbol.iterator 的方法。此方法返回一个迭代器对象。迭代器对象具有 next() 方法，可以重复调用该方法以获得可迭代对象的值。迭代器对象的 next() 方法返回迭代结果对象。迭代结果对象具有 value 属性和或或 done 属性。</p>

<p>异步迭代器与常规迭代器非常相似，但是有两个重要的区别。 首先，一个异步可迭代对象以符号名称 Symbol.asyncIterator 而不是 Symbol.iterator 实现一个方法。（如前所述，for/await 与常规可迭代对象兼容，但是它更喜欢异步可迭代对象，并在尝试 Symbol.iterator 方法之前先尝试使用 Symbol.asyncIterator 方法。）其次，异步迭代器的 next() 方法返回解析为迭代器结果对象的 Promise，而不是直接返回迭代器结果对象。</p>

<p><strong>注意</strong></p>

<p>在上一节中，当我们在常规的、同步可迭代的 Promise 数组上使用 for/await 时，我们正在使用同步迭代器结果对象，其中 value 属性是 Promise 对象，但 done 属性是同步的。真正的异步迭代器为迭代结果对象返回 Promise，并且 value 和 done 属性都是异步的。这是一个微妙的区别：使用异步迭代器，可以异步选择何时结束迭代。</p>

<h3 id="toc_28">13.4.3 异步生成器</h3>

<p>正如我们在第 12 章中看到的那样，实现迭代器的最简单方法通常是使用生成器。异步迭代器也是如此，我们可以使用声明为异步的生成器函数来实现。异步生成器具有异步特性和生成器特性：可以像在常规异步函数中一样使用 await，并且可以像在常规生成器中一样使用 yield。但是，产生的值会自动包装在 Promise 中。甚至异步生成器的语法也是一个组合：异步函数和 function* 组合为 async function*。这是一个示例，描述如何使用异步生成器和 for/await 循环代替 setInterval() 回调函数以固定的间隔重复运行代码：</p>

<pre><code class="language-javascript">// A Promise-based wrapper around setTimeout() that we can use await with.
// Returns a Promise that fulfills in the specified number of milliseconds
function elapsedTime(ms) {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

// An async generator function that increments a counter and yields it
// a specified (or infinite) number of times at a specified interval.
async function* clock(interval, max=Infinity) {
    for(let count = 1; count &lt;= max; count++) { // regular for loop
        await elapsedTime(interval);            // wait for time to pass
        yield count;                            // yield the counter
    }
}

// A test function that uses the async generator with for/await
async function test() {                       // Async so we can use for/await
    for await (let tick of clock(300, 100)) { // Loop 100 times every 300ms
        console.log(tick);
    }
}
</code></pre>

<h3 id="toc_29">13.4.4 实现异步迭代器</h3>

<p>除了使用异步生成器来实现异步迭代器外，还可以通过使用 Symbol.asyncIterator() 方法定义一个对象来直接实现它们，而 Symbol.asyncIterator() 方法将返回一个对象，而 next() 方法将返回一个决议为迭代器结果对象的 Promise。在下面的代码中，我们重新实现了上一个示例中的 clock() 函数，因此它不是生成器，而仅是返回一个异步可迭代的对象。请注意，此示例中的 next() 方法未明确返回 Promise；相反，我们只声明 next() 是异步的：</p>

<pre><code class="language-javascript">function clock(interval, max=Infinity) {
    // A Promise-ified version of setTimeout that we can use await with.
    // Note that this takes an absolute time instead of an interval.
    function until(time) {
        return new Promise(resolve =&gt; setTimeout(resolve, time - Date.now()));
    }

    // Return an asynchronously iterable object
    return {
        startTime: Date.now(),  // Remember when we started
        count: 1,               // Remember which iteration we&#39;re on
        async next() {          // The next() method makes this an iterator
            if (this.count &gt; max) {     // Are we done?
                return { done: true };  // Iteration result indicating done
            }
            // Figure out when the next iteration should begin,
            let targetTime = this.startTime + this.count * interval;
            // wait until that time,
            await until(targetTime);
            // and return the count value in an iteration result object.
            return { value: this.count++ };
        },
        // This method means that this iterator object is also an iterable.
        [Symbol.asyncIterator]() { return this; }
    };
}
</code></pre>

<p>这个基于迭代器版本的 clock() 函数修复了基于生成器版本中的一个缺陷。请注意，在此代码中，我们在每次迭代开始时设置了绝对目标时间，并将其与当前时间的差值作为间隔传递给 setTimeout()。如果我们将 clock() 与 for/await 循环一起使用，则此版本将在指定的时间间隔内更精确地运行循环迭代，因为它考虑了实际运行循环主体所需的时间。但是，此修补程序不仅涉及定时精度。for/await 循环始终在开始下一次迭代之前等待一次迭代返回的 Promise 被兑现。但是，如果使用不带 for/await 循环的异步迭代器，则没有什么可以阻止在需要时调用 next() 方法。使用基于生成器的 clock() 版本，如果依次调用 next() 方法三遍，将获得三个 Promise，这些 Promise 几乎都在同一时间完成，这可能不是想要的结果。我们在这里实现的基于迭代器的版本没有这个问题。</p>

<p>异步迭代器的好处在于，它们允许我们表示异步事件或数据流。前面讨论的 clock() 函数编写起来非常简单，因为异步源是我们自己进行的 setTimeout() 调用。但是，当我们尝试与其他异步源一起使用时，例如事件处理程序的触发，实现异步迭代器的难度将大大提高————我们通常只有一个事件处理程序函数来响应事件，但是每次调用迭代器的 next() 方法一定返回一个不同的 Promise 对象，并且在第一个 Promise 决议之前，可能会多次调用 next()。这意味着，任何异步迭代器方法都必须能够维护一个内部的 Promise 队列，该队列将在响应异步事件时按顺序进行决议。如果我们将此 Promise 有序列的行为封装到 AsyncQueue 类中，那么基于 AsyncQueue 编写异步迭代器将变得更加容易。 <sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup></p>

<p>正如期望的那样，后面的 AsyncQueue 类具有 enqueue() 和 dequeue() 方法。但是，dequeue() 方法返回 Promise 而不是实际值，这意味着可以在调用 enqueue() 之前调用 dequeue()。AsyncQueue 类也是一个异步迭代器，旨在与 for/await 循环一起使用，该循环的主体在每次将新值异步排队时都运行一次。（AsyncQueue 有一个 close() 方法。一旦被调用，就不能将更多的值加入队列。当关闭的队列为空时，for/await 循环将停止遍历。）</p>

<p>请注意，AsyncQueue 的实现不使用异步或等待，而是直接与 Promise 一起使用。该代码有些复杂，可以使用它来测试对本长篇文章所涉及内容的理解。即使您不完全了解 AsyncQueue 的实现，也请看一下它后面的简短示例：它在 AsyncQueue 之上实现了一个简单但非常有趣的异步迭代器。</p>

<pre><code class="language-javascript">/**
 * An asynchronously iterable queue class. Add values with enqueue()
 * and remove them with dequeue(). dequeue() returns a Promise, which
 * means that values can be dequeued before they are enqueued. The
 * class implements [Symbol.asyncIterator] and next() so that it can
 * be used with the for/await loop (which will not terminate until
 * the close() method is called.)
 */
class AsyncQueue {
    constructor() {
        // Values that have been queued but not dequeued yet are stored here
        this.values = [];
        // When Promises are dequeued before their corresponding values are
        // queued, the resolve methods for those Promises are stored here.
        this.resolvers = [];
        // Once closed, no more values can be enqueued, and no more unfulfilled
        // Promises returned.
        this.closed = false;
    }

    enqueue(value) {
        if (this.closed) {
            throw new Error(&quot;AsyncQueue closed&quot;);
        }
        if (this.resolvers.length &gt; 0) {
            // If this value has already been promised, resolve that Promise
            const resolve = this.resolvers.shift();
            resolve(value);
        }
        else {
            // Otherwise, queue it up
            this.values.push(value);
        }
    }

    dequeue() {
        if (this.values.length &gt; 0) {
            // If there is a queued value, return a resolved Promise for it
            const value = this.values.shift();
            return Promise.resolve(value);
        }
        else if (this.closed) {
            // If no queued values and we&#39;re closed, return a resolved
            // Promise for the &quot;end-of-stream&quot; marker
            return Promise.resolve(AsyncQueue.EOS);
        }
        else {
            // Otherwise, return an unresolved Promise,
            // queuing the resolver function for later use
            return new Promise((resolve) =&gt; { this.resolvers.push(resolve); });
        }
    }

    close() {
        // Once the queue is closed, no more values will be enqueued.
        // So resolve any pending Promises with the end-of-stream marker
        while(this.resolvers.length &gt; 0) {
            this.resolvers.shift()(AsyncQueue.EOS);
        }
        this.closed = true;
    }

    // Define the method that makes this class asynchronously iterable
    [Symbol.asyncIterator]() { return this; }

    // Define the method that makes this an asynchronous iterator. The
    // dequeue() Promise resolves to a value or the EOS sentinel if we&#39;re
    // closed. Here, we need to return a Promise that resolves to an
    // iterator result object.
    next() {
        return this.dequeue().then(value =&gt; (value === AsyncQueue.EOS)
                                   ? { value: undefined, done: true }
                                   : { value: value, done: false });
    }
}

// A sentinel value returned by dequeue() to mark &quot;end of stream&quot; when closed
AsyncQueue.EOS = Symbol(&quot;end-of-stream&quot;);
</code></pre>

<p>因为 AsyncQueue 类定义了异步迭代基础，所以我们可以简单地通过异步排队值来创建更有趣的自定义异步迭代器。这是一个使用 AsyncQueue 生成可通过 for/await 循环处理的 web 浏览器事件流的示例：</p>

<pre><code class="language-javascript">// Push events of the specified type on the specified document element
// onto an AsyncQueue object, and return the queue for use as an event stream
function eventStream(elt, type) {
    const q = new AsyncQueue();                  // Create a queue
    elt.addEventListener(type, e=&gt;q.enqueue(e)); // Enqueue events
    return q;
}

async function handleKeys() {
    // Get a stream of keypress events and loop once for each one
    for await (const event of eventStream(document, &quot;keypress&quot;)) {
        console.log(event.key);
    }
}
</code></pre>

<h2 id="toc_30">13.5 Summary</h2>

<p>在本章中，您学习了：</p>

<p>大多数真实的 JavaScript 程序都是异步的。</p>

<p>传统上，异步是通过事件和回调函数来处理的。但是，这可能会变得复杂，因为最终可能会嵌套在其他回调中嵌套的多个级别的回调，并且因为很难进行可靠的异常处理。</p>

<p>Promise 提供了构造回调函数的新方法。如果正确使用（不幸的是，Promise 易于错误使用），它们可以将异步代码转换为嵌套在调用 then() 的线性链中的代码，一个计算的异步步骤跟随在其他之后。而且，Promise 允许将异常处理代码集中到一个 then() 调用链末尾的单个 catch() 调用中。</p>

<p>async 和 await 关键字允许我们编写异步代码，该代码基于 Promise，但看起来像同步代码。这使代码更易于理解和推理。如果一个函数被声明为 async，它将隐式返回一个 Promise。在异步函数内部，可以 await Promise（或返回 Promise 的函数），就像 Promise 值是同步计算的一样。</p>

<p>异步可迭代的对象可以与 for/await 循环一起使用。可以通过实现 [Symbol.asyncIterator]() 方法或调用 async function* 生成器函数来创建异步可迭代对象。异步迭代器为 Node 中流的“data”事件提供了一种替代方法，可用于表示客户端 JavaScript 中的用户输入事件的流。</p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>XMLHttpRequest 类与 XML 无关。在现代的客户端 JavaScript 中，它已被 fetch() API 取代，该 API 已在 §15.11.1 中进行了介绍。此处显示的代码示例是本书中最后一个基于 XMLHttpRequest 的示例。 &nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>通常，可以在浏览器的开发人员控制台的顶层使用 await。还有一个悬而未决的建议，允许在将来的 JavaScript 版本中进行顶级 await。 &nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>我从 Dr. Axel Rauschmayer 的博客<a href="">https://2ality.com</a>中了解了这种异步迭代方法。&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
</feed>
