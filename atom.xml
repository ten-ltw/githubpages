<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[十]]></title>
  <link href="blog.2019919.top/atom.xml" rel="self"/>
  <link href="blog.2019919.top/"/>
  <updated>2020-12-23T21:01:51+08:00</updated>
  <id>blog.2019919.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[努力了三个月的总结]]></title>
    <link href="blog.2019919.top/16084764191221.html"/>
    <updated>2020-12-20T23:00:19+08:00</updated>
    <id>blog.2019919.top/16084764191221.html</id>
    <content type="html"><![CDATA[
<p>今年是个灾难年，疫情让大家都不是太好受，但是年初的疫情期间，我想一定有很多人抓住了这段空闲时期努力学习，而这些人一般都是一些比别人更加优秀的人，这几个月他们再次拉开了和我的距离，而我到了8月中旬的夏休长假后才意识到这一点，此时此刻距离我<strong>30岁</strong>还剩1个月。</p>

<h2 id="toc_0">第一次落实到笔纸上的执行计划</h2>

<p>第一次的计划起于我的夏休，夏休期间因为电脑更换了新配置，旧件废物利用做家庭服务器，研究多个NAS操作系统和软路由，在不断的失败中了解了好多操作系统都是基于Linux，再加上公司最近的项目都是在Linux中开发，觉得熟练Linux命令行对今后的作业有一定的帮助，在NAS草草的选择了WINDOWS之后有了这一路线。</p>

<ol>
<li>centOS</li>
<li>git</li>
<li>开发环境（原设想windows开发，通过CLI让Linux服务器同步代码编译并发布）</li>
<li>angular</li>
<li>postgreSQL</li>
<li>dotnet core</li>
<li>ngnix</li>
<li>docker</li>
<li>软路由</li>
</ol>

<h3 id="toc_1">想法初衷</h3>

<p>整体目标是通过工作中应用的语言和技术来实现一个blog，然后将我的软件硬件爬坑的经历给记录下来，123三点进行开发环境学习，4为前端，56是DB和后端api，789是部署服务器相关内容。<br/>
整个流程走下来应该可以将我想要的博客搭建起来，今后更好的记录未来工作中遇到的问题，便于回顾，而开发过程中也是一个学习的过程，毕竟在项目中没有完全一个人从无到有的实施。</p>

<h3 id="toc_2">实施结果</h3>

<p>经过两个月的学习做一个小总结，<strong>以下都是垃圾</strong>：</p>

<blockquote>
<p>centOS学习了一些基本指令，什么文件处理啊权限用户处理啊，这些简单的能用的到的，跟了一波视频，自己也做了一些笔记。<br/>
git和开发环境，嗯设想的并没有去实现，感觉怪怪得，明明docker就是为了多平台，打个镜像就完事了我干啥做这么奇葩，所以最后熟悉了下git的一些常用命令行，从此脱离vsCode的图形化界面操作。<br/>
关于angular，不得不说还真是有一些提高，尤其是在路由（包括后期部署的坑）这一块，还真是有了一定的提高，再就是结构指令，真正的不是纸上谈兵真正的动手操作了一番。前端这一部分最耽误时间的应该就是在选择一个富文本编辑器，最后应用的是tinymce，不用额外的资源文件，也比较美观功能齐全。<br/>
后端因为一直不是我的侧重点，仅仅是为了API的实现浅浅的完成了前端的需求，不过在tinymce图片文件交互这里也稍微下了一点功夫。<br/>
最后的部署环境首先是在IIS中完成了前后端部署，毕竟电脑还是都是windows的，然后docker也是撸了一遍视频，简单的完成了部署。<br/>
公网IP也申请了，还傻傻的去备案了，至今还是下面这个状态<br/>
<img src="media/16084764191221/16086441905741.jpg" alt="" style="width:943px;"/></p>
</blockquote>

<p><strong>以上灰色部分都是垃圾！</strong><br/>
到此为止，我总结下我的状态，我发现我没留下什么，除了github上多了几行代码电脑多了几个软件安装包之外，我觉得我一无所获，于是就在次沉浸在迷茫之中。我为什么就无法提升，我也没有在闲着，而且效率明显比之前提高了，学习时间也增加了，我的未来呢。</p>

<h2 id="toc_3">奇遇➡️心得</h2>

<p>好在我迷茫但是没有堕落，有一天在学习浏览器原理时，看到别人博客的引用文献中除了一些书和别人的博文，还有一些课程，而这个课程的介绍就有意思了。</p>

<blockquote>
<p>前端学习是一条先块后慢的曲线。在快速入门之后，大多数人都会感觉：自己仅仅停留在会用的阶段，后面的学习之路似乎越来越陡峭，每前进一步都十分艰难。<br/>
其实是你没有意识到，你在自学的过程中走了太多弯路。</p>
</blockquote>

<p>后面还有一些，我觉得这些完全说到了我的心坎，还是有大牛懂得菜鸟的心的，而其课程目录正含有我在自学的浏览器原理，我觉得我碰到知己了啊，赶紧买过来课啃，上下班一起啃。<br/>
这样坚持了大概～～好吧6天，我成功服输了。就有种刚接触人工智能AI，人家提了一个名词我去查，最后一直查到了高中数学，而且这知识早就忘了。<br/>
好在赶上了这个老师的直播，这个课程原来是面向阿里P5P6水平如何上P7的一个指导，通过他的直播我确切的找到了差距，要知道这些大牛也不过30到35左右，甚至可能是我同届的毕业生，我八年的对日经验真的是提前养老了，而脑子也养老了，但是我真的不愿意这样认输，我唯一的目标就是不希望到我40岁的时候活得跟周围这些40岁老大哥一样，满嘴都是没法学习的借口。<br/>
带着迷茫悲哀和不服的心态继续浏览着知乎，<a href="https://zhuanlan.zhihu.com/p/27662828">JavaScript入门的5条建议</a>救世的贴出现了，这个贴发写于2017年。我总结下对我最有用的亮点：</p>

<ol>
<li>写代码 &gt; 看视频 &gt; 看书 三个部分时间配比</li>
<li>不可盲目追新技术</li>
</ol>

<p>第一点新鸟老鸟都懂，但是我经常看视频简单就不动手了，讲的东西我知道我会，但是落实到键盘上发现就总也写不对。<br/>
第二点他的描述很有趣：</p>

<blockquote>
<p>react，vue，angular,和你没关系<br/>
node，express，koa，和你没关系<br/>
grunt，gulp，webpack，和你没关系</p>
</blockquote>

<p>这确实是我的问题，做dotnet出身，因typescript后端程序员很容易接纳，而基本上没有什么基础直接开始了angularJs到angular的开发，html样式能做，然而说不清楚，一切都靠搜索大家记录的bug来辅助我完成工作，真的做到了老师说的会用而已，而跟不上老师的课原因就是没有基础，一个曾经让我们看不起的前端程序员所需要的基础知识梁是我根本不了解的。虽然心理上不接受，但是不得不说，我这八年工作经验可能赶不上大厂p4的新手。<br/>
以上心理活动和经历再加上睡觉，大概经历了18个小时，之后我重新操起了《JavaScript权威指南》，一本传说中最不适合初学者学习的书，而恰巧，这本书上次读到了类型转换。对象类型的转换也就是装箱拆箱这一块，读完了也理解了老师当时讲的拆箱转换 valueOf() 方法和 toString() 方法的执行顺序，而这时我发现，原来像听了天书的一节课程，我竟然用读《JavaScript权威指南》不到两个小时就全部消化了。<br/>
内心汹涌澎湃，至此我觉得我得到的不仅仅是一课的知识，还得到的是对这个学习方向的肯定，找到了能前进一步的路线。</p>

<h2 id="toc_4">直播其他所得</h2>

<p>winter老师直播的主要围绕是面试，而今年我也仅仅参加了一次面试，这一次就让我知道了差距，那总结老师所说的案例性问题：</p>

<ul>
<li>css布局</li>
<li>dom api</li>
<li>原型</li>
<li>闭包</li>
</ul>

<p>后两个问题对日至今也没有被问过，通过这次直播也找到了原因。</p>

<blockquote>
<p>考原型闭包是为了考架构能力<br/>
原型是考面向对象<br/>
考闭包是为了考函数式编程</p>
</blockquote>

<p>所以对日外包真的是并不需要呢。</p>

<h2 id="toc_5">最新计划</h2>

<ul>
<li>《JavaScript权威指南》</li>
<li>《JavaScript函数式编程》</li>
<li>《重学前端》--JS部分</li>
<li>css布局</li>
<li>浏览器原理及API</li>
</ul>

<p>新的计划很简单，抓好基础，不甘堕落。争取明年七月完成这些目标。</p>

<h2 id="toc_6">今年的最后总结</h2>

<p>这三个月也是今年最后的三个月了，那也就基本是今年的总结了，也是我开始真的努力坚持写博客的第一次总结。<br/>
今年上半年虽然没学习技术，好在磨练了下心性，读书是人类走向心智成熟的最佳捷径。在上半年中除了名人传记金融和技术相关方面的书之外，我觉得心理上的书最让我受益匪浅，这里不仅仅是类似《论语》的《人性的弱点》这类书，只讲表象，《少有人走的路》这一套书从心理上讲解了我们一些人性上的弱点的起因以及自己努力掩盖这些弱点的行为，而起初发现这本书只是我想寻求一些在自律上的帮助，却获得了更大的回报，真的是太幸运了。今年读书让我得到的最大最受用的两大改变：</p>

<ol>
<li>控制焦躁的心，可以做到不争吵并且坚决拒绝否定别人。</li>
<li>正式面对自己的善恶和伪善，不以恶小而为之，不以善小而不为。</li>
</ol>

<p>在不断的读书和知识的学习中，我的谈吐也在发生改变，无论跟同事朋友还是亲人，说话越来越调理清晰了。<br/>
我是个喜欢完善环境的人，开发环境我会去找各种各样的插件来辅助编程，这次的学习环境也有了很大的投入，买了两份前端课程，买了一个英语外教课程，买了一个苹果一体机，买了一个新pad，买了niz键盘，买了妙控板。嗯这些都花在了11月底12月初，也就是说我有了个明确的目标，我希望到我31岁的时候就能获得丰厚的30岁进行自我投资的知识回报，并在不久的将来进行变现。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新认识下熟悉的浏览器]]></title>
    <link href="blog.2019919.top/16076922632055.html"/>
    <updated>2020-12-11T21:11:03+08:00</updated>
    <id>blog.2019919.top/16076922632055.html</id>
    <content type="html"><![CDATA[
<p>前端程序员每天都在抠代码，各种各样的技术，千变万化的框架，但最后组装压缩在一起，就是为了伺候操作系统的一个软件————浏览器。这一次，在阅读了三天各大博主的精华后，就chrome浏览器来做一下自己的整理记录。<br/>
双击桌面chrome浏览器发生了什么呢：</p>

<blockquote>
<p>系统创建了一个chrome的进程。</p>

<blockquote>
<p>从多标签页app的开始，一个chrome进程中有了多个子tab进程。</p>

<blockquote>
<p>每个tab进程内有下面这些进程：<br/>
<a href="#toc_0">渲染引擎</a><br/>
<a href="#toc_1">JS引擎</a><br/>
<a href="#toc_2">用户界面</a><br/>
<a href="#toc_3">存储</a></p>
</blockquote>
</blockquote>
</blockquote>

<h2 id="toc_0">渲染引擎</h2>

<p>最初渲染引擎和JS引擎并没有分家，在一起统称为浏览器内核，后来JS引擎越来越独立，内核就完全倾向于渲染引擎。chrome原来使用的就是webkit引擎，后来为了不受制于苹果，基于webkit改编了blink，将其内置于chrome中。</p>

<h2 id="toc_1">JS引擎</h2>

<h2 id="toc_2">用户界面</h2>

<h2 id="toc_3">存储</h2>

<h2 id="toc_4">感受</h2>

<p>现在对学习的感觉是即入迷又无力，学到这里的时候回想一下，我最开始只是看到了一篇短文，浅谈JS事件的原理，而当时的那篇文章真的是比较浅，我现在已经忘了内容是什么了，但是在我不断深入的时候，每每看到一个强大的人的博客的时候就会发现一些新内容，当我为了弄懂其中一个小名词的时候又会引出无数的子节点，真的是树无处不在，越来越入迷，也越来越吃力。虽然我不知道整个树有多大，但是当学到末梢节点的时候回头来总结一下，看看我捋顺的健壮的树枝，真的是振奋人心。</p>

<h2 id="toc_5">参考</h2>

<p><a href="https://segmentfault.com/a/1190000018806562">webkit引擎和v8引擎工作原理</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript类型转换]]></title>
    <link href="blog.2019919.top/16087263047458.html"/>
    <updated>2020-12-23T20:25:04+08:00</updated>
    <id>blog.2019919.top/16087263047458.html</id>
    <content type="html"><![CDATA[
<p>《JavaScript权威指南》的这一章节就是让我确定了我学习路线的一节，这一节的掌握与老师讲拆包转换的时候内容一致，只是描述名词略有变化，也就是说还是要从基础抓起。</p>

<h2 id="toc_0"> 不注意会出错的类型转换</h2>

<h3 id="toc_1"> 转数值型</h3>

<table>
<thead>
<tr>
<th>原类型</th>
<th>转换后类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>0</td>
</tr>
<tr>
<td>非空非数字字符串</td>
<td>NaN</td>
</tr>
</tbody>
</table>

<blockquote>
<p>NaN（Not a Number，非数）<br/>
NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。<br/>
isNaN() 全局函数来判断一个值是否是 NaN 值。</p>
</blockquote>

<pre><code class="language-javascript">    Number.NaN === NaN
    // false
    Number.NaN == NaN
    // false
    isNaN(NaN)
    // true
</code></pre>

<h3 id="toc_2"> 转布尔型</h3>

<table>
<thead>
<tr>
<th>原类型</th>
<th>转换后类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>&quot;&quot;</td>
<td>false</td>
</tr>
<tr>
<td>0,-0,NaN</td>
<td>false</td>
</tr>
<tr>
<td>Infinity,-Infinity,非零数</td>
<td>true</td>
</tr>
</tbody>
</table>

<p>NaN空串null和undefined都为false，所以常用ture,false判断对象是否可以使用。</p>

<h2 id="toc_3"> 转换</h2>

<p>转换分为两种：</p>

<ul>
<li>显示转换</li>
<li>隐式转换</li>
</ul>

<h3 id="toc_4"> 显示转换</h3>

<p>最简单的方法就是使用Boolean（）、Number（）、String（）或Object（）函数。当不通过new运算符调用这些函数时，它们会作为类型转换函数。</p>

<p>除了null或undefined之外的任何值都具有toString（）方法，这个方法的执行结果通常和String（）方法的返回结果一致。</p>

<p>把null或undefined转换为对象抛出一个类型错误。</p>

<blockquote>
<p>为什么123.tostring()报错？</p>
</blockquote>

<p>JavaScript中还提供了专门的函数和方法来做显示转换。</p>

<ul>
<li>Number.toString（）方法可以接收表示转换基数（radix）。</li>
<li>Number.toFixed（）根据小数点后的指定位数将数字转换为字符串。</li>
<li>Number.toExponential（）使用指数记数法将数字转换为指数形式的字符串，其中小数点位数为参数。</li>
<li>Number，toPrecision（）根据指定的有效数字位数将数字转换成字符串。</li>
</ul>

<p>后三个方法都会进行四舍五入或填充0。</p>

<p>Number（）只能进行十进制转换。</p>

<p>全局函数parseInt（）和parseFloat（）会<strong>跳过任意数量的前导空格，结束于空格</strong>，尽可能多的解析数值字符，并忽略后面的内容。如果第一个为非空字符不是数字返回NaN。</p>

<pre><code class="language-javascript">    parseInt(&#39; 112 333&#39;)
    // 112
</code></pre>

<p>parseInt（）可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2～36。</p>

<blockquote>
<p>在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。<br/>
Number 是比 parseInt更好的选择。<br/>
这一段觉得老师说的有问题</p>
</blockquote>

<pre><code class="language-javascript">    parseInt(&#39;! 112 333&#39;)
    // NaN
    parseInt(&#39;0x 112 333&#39;)
    // NaN
</code></pre>

<h3 id="toc_5"> 隐式转换</h3>

<p>某些运算符会做隐式的类型转换，有时用于类型转换。</p>

<pre><code class="language-javascript">    x + &quot;&quot; // 等价于String(x)
    +x   // 等价于Number(x)
    !!x  // 等价于Boolean(x)
</code></pre>

<h2 id="toc_6"> 对象转换为原始值（拆箱转换）</h2>

<p>到布尔值转换，所有对象（包括数组和函数）都转换为true。</p>

<pre><code class="language-javascript">    Boolean(Boolean(false))
    // false
    Boolean(new Boolean(false))
    // true
</code></pre>

<p>对象到字符串和数字是通过两个不同的方法来转换的。<br/>
所有对象都继承了两个方法toString()和valueOf()。对象转化字符串先tostring()方法，如果不是原始值用valueof()方法，如果还不是原始值 抛类型错误。有任何原始值都用原始值进行toStirng()。<br/>
反之转数值型转换，先进行valueof()后进行tostring()。<br/>
案例：空数组转数值型等于0.</p>

<pre><code class="language-javascript">    Number([])
    // 0
    [].valueOf()
    // []
    [].toString()
    // &quot;&quot;
    Number(&quot;&quot;)
    // 0
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript全部的对象分类]]></title>
    <link href="blog.2019919.top/16085442753431.html"/>
    <updated>2020-12-21T17:51:15+08:00</updated>
    <id>blog.2019919.top/16085442753431.html</id>
    <content type="html"><![CDATA[
<p>之前讲解的对象只是特定的一部分，并不能涵盖全部的JavaScript对象。<br/>
比如无论怎样编写代码都没法绕开Array，实现一个跟原生数组行为一模一样的对象，因为原生数组底层实现了一个自动随着下标变化的length属性。并且也无法依靠JavaScript代码实现div对象，需要用document.createElement来创建。这也说明了JavaScript的对象机制并非简单的属性集合+原型。</p>

<h2 id="toc_0"> JavaScript中的对象分类</h2>

<p>* 宿主对象（host Objects）<br/>
由JavaScript宿主环境提供的对象，他们的行为完全由宿主环境决定。<br/>
* 内置对象（Built-in Objects）<br/>
由JavaScript语言提供的对象。<br/>
    - 固有对象（Intrinsic Objects）<br/>
    由便准规定，随着JavaScript运行时创建而自动创建的对象实例。<br/>
    - 原生对象（Native Objects）<br/>
    可以由用户通过Array、RegExp等内置构造器或者特殊语法创建的对象。<br/>
    - 普通对象（Ordinary Objects）<br/>
    由{}语法、Object构造器或者calss关键字定义类创建的对象，它能够被原型继承。</p>

<h2 id="toc_1"> 宿主对象</h2>

<p>前端最熟悉的就是浏览器环境中的宿主。在浏览器环境中全局对象是window，window上又有很多属性，如document。<br/>
实际上这个全局对象window上的属性一部分来自于JavaScript语言，一部分来自浏览器环境。</p>

<h2 id="toc_2"> 内置对象·固有对象</h2>

<p>固有对象是由标准规定，随着JavaScript运行时创建而自动创建的对象实例，类似基础库的角色。比如window、document等。</p>

<h2 id="toc_3"> 内置对象·原生对象</h2>

<p>能够通过语言本身的构造器创建的对象叫做原生对象。<br/>
老师将对象分成了如下五类：<br/>
通过这些构造器可以通过new运算创建新的对象，</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript的面向对象]]></title>
    <link href="blog.2019919.top/16085441443213.html"/>
    <updated>2020-12-21T17:49:04+08:00</updated>
    <id>blog.2019919.top/16085441443213.html</id>
    <content type="html"><![CDATA[
<p>在不同的编程语言中，设计者也利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。而 JavaScript 早年却选择了一个更为冷门的方式：原型。<br/>
这节课了解一下 JavaScript 是如何设计对象模型的。</p>

<h2 id="toc_0"> JavaScript对象的特征</h2>

<p>* 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。<br/>
* 对象有状态：对象具有状态，同一对象可能处于不同状态之下。<br/>
* 对象具有行为：即对象的状态，可能因为他的行为产生变迁。<br/>
一般而言，各语言对象唯一标识性都是用内存地址来体现。</p>

<pre><code class="language-javascript">    var o1 = { a: 1 };
    var o2 = { a: 1 };
    console.log(o1 == o2); // false
</code></pre>

<p>两个一模一样的对象，但是打印结果是false，两个对象并不是同一个对象。<br/>
“状态和行为”在不同语言中会使用不同的术语来描述他们，C++中是“成员变量和成员函数”，Java中则称为“属性和方法”。在JavaScript中，将状态和行为统一抽象为“属性”。</p>

<pre><code class="language-javascript">    var o = { 
        d: 1,
        f() {
            console.log(this.d);
            }    
        };
</code></pre>

<p>o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。<br/>
JavaScript 中对象独有的特色是：<strong>对象具有高度的动态性</strong>，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</p>

<pre><code class="language-javascript">    var o = { a: 1 };
    o.b = 2;
    console.log(o.a, o.b); //1 2
</code></pre>

<h2 id="toc_1"> JavaScript对象的两类属性</h2>

<h3 id="toc_2"> 第一类属性数据属性</h3>

<p>数据属性接近于其他语言的属性概念，具有四个特征：<br/>
* value：就是属性的值。<br/>
* writable：决定属性是否能被赋值。<br/>
* enumerable：决定for in 能否枚举该属性。<br/>
* configurable：决定该属性能否被删除或者改变特征值。</p>

<h3 id="toc_3"> 第二类属性访问器属性（getter/setter）</h3>

<p>访问器属性也有四个特征：<br/>
* getter：函数或undefined，在取属性值时被调用。<br/>
* setter：函数或undefined，在设置属性值时被调用。<br/>
* enumerable：决定for in 能否枚举该属性。<br/>
* configurable：决定该属性能否被删除或者改变特征值。</p>

<h2 id="toc_4"> 总结</h2>

<p>实际上 JavaScript 对象的运行时是一个“属性的集合”。</p>

<blockquote>
<p> 属性key：字符串或者 Symbol<br/>
 值value：数据属性特征值或者访问器属性特征值<br/>
对象是一个属性的索引结构（索引结构是一类常见的数据结构，可以把它理解为一个能够以比较快的速度用 key 来查找 value 的字典）。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript中的类型]]></title>
    <link href="blog.2019919.top/16083847578374.html"/>
    <updated>2020-12-19T21:32:37+08:00</updated>
    <id>blog.2019919.top/16083847578374.html</id>
    <content type="html"><![CDATA[
<p>根据最新的语言标准，javascript规定了7种语言类型：</p>

<ul>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Symbol</li>
<li>Object</li>
</ul>

<blockquote>
<p>但是在MDN中是这样描述的：<br/>
基本类型（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：string，number，bigint，boolean，null，undefined，symbol  (ECMAScript 2016新增)。</p>
</blockquote>

<h2 id="toc_0">Undefined</h2>

<p>void运算把任意一个表达式变成undefined。</p>

<pre><code class="language-markup">&lt;a href=&quot;javascript: void(0)&quot;&gt;&lt;/a&gt;
</code></pre>

<p>常用以上代码来描述一个没有锚点的死链接。<br/>
往往应用void 0来做undefined使用的原因是<strong>Javascript中undefined是一个变量，并非关键字，可以被篡改</strong>。</p>

<h2 id="toc_1">Null</h2>

<p>null是关键字，可以放心使用null关键字获取null的值。</p>

<h2 id="toc_2">Boolean</h2>

<p>true 和 false。</p>

<h2 id="toc_3">String</h2>

<p>String并非“字符串”，而是字符串的UTF16编码，所以charAt、charCodeAt、length等方法都是针对UTF16编码。所以字符串的最大长度实际上是受字符串的编码长度影响的,String 有最大长度是 2<sup>53</sup> - 1是指编码长度，并不是字符数。</p>

<blockquote>
<p><strong>Unicode</strong> <br/>
Unicode（又称统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。Unicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。<br/>
UTF是Unicode的编码格式，<br/>
他具体定义 了 Unicode 字符在计算机中存取方法。<br/>
常见的就是UTF-16和UTF-8 <br/>
UTF-16用两个字节表示一个Unicode转化格式，定长两个字节16bit，所以是UTF-16。<br/>
UTF-8因为很大一部分字符用一个字节就可以表示现在要的两个字节表示，UTF-8采用了一种变长的技术，每个编码区域有不同的字码长度，不同类型的字符可以是由1~6个字节组成，看前两字节的值来确定是什么类型的字符。</p>
</blockquote>

<p><strong>string是不可变的引用类型。</strong>他拥有值类型的特性。</p>

<h2 id="toc_4">Number</h2>

<p><strong>NAN</strong>编码中很少直接使用。通常都是在计算失败时，作为 Math 的某个方法的返回值出现的，比较NAN必须使用 Number.isNaN() 或 isNaN() 函数。<br/>
但是，请注意isNaN（）和Number.isNaN（）之间的区别：如果当前值是NaN，或者将其强制转换为数字后将是NaN，则前者将返回true。<br/>
<strong>Infinity</strong> 无穷大<br/>
<strong>-Infinity</strong> 负无穷大<br/>
-0和0在进行除法作为除数的时候符号带入计算。</p>

<p>经典问题0.1+0.2不能等于0.3，浮点数运算的精度问题导致等式左右不是严格相等，而是相差了个微小的值。<br/>
正确的比较方法是：</p>

<pre><code class="language-javascript">console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);
</code></pre>

<p><strong>检查等式两边的差值是否小于最小精度</strong>才是正确比较浮点数的方法。</p>

<h2 id="toc_5">Symbol</h2>

<p>这个英文单词就是象征和符号的意思,它是一切非字符串的对象key的集合。一个symbol值能作为对象属性的标识符,这是该数据类型仅有的目的。<br/>
Symbol() 函数会返回Symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的Symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：&quot;new Symbol()&quot;。</p>

<pre><code class="language-javascript">var mySymbol = Symbol(&quot;my symbol&quot;);
</code></pre>

<p>每个从Symbol()返回的symbol值都是唯一的。</p>

<pre><code class="language-javascript">console.log(Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;));
// expected output: false
</code></pre>

<h2 id="toc_6">Object</h2>

<p>在JavaScript中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是key-value结构，key可以是字符串或者Symbol类型。<br/>
JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：</p>

<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol</li>
</ul>

<p>所以3与new Number(3)是完全不同的值，一个是Number类型，一个是对象类型。<br/>
日常代码中可以把对象的方法在基本类型上使用</p>

<pre><code class="language-javascript">console.log(&quot;abc&quot;.charAt(0)); //a
</code></pre>

<p>而往常常理解为String类型有charAt方法，看来这个理解是错误的。<br/>
甚至可以在基本类型的亲戚对象的原型中添加方法，这样任何相同基本类型的变量都可以调用这个方法。</p>

<pre><code class="language-javascript">    Symbol.prototype.hello = () =&gt; console.log(&quot;hello&quot;);

    var a = Symbol(&quot;a&quot;);
    console.log(typeof a); //symbol，a并非对象
    a.hello(); //hello，有效
</code></pre>

<p>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能够在基础类型上条用对应对象的方法。（感觉类似一个原型链的应用）</p>

<blockquote>
<p>值类型给引用类型叫装箱<br/>
引用类型给值类型叫拆箱<br/>
给我的理解是将多个属性打包成对象就是装箱，将对象的属性独立出来就是拆箱。</p>
</blockquote>

<h2 id="toc_7">类型转换</h2>

<p>==运算很臭，应该是没有意义去记住他的比较结果，只需要记住只用===来比较。</p>

<h3 id="toc_8">StringToNumber</h3>

<p>字符串到数字的类型转换支持十进制、二进制、八进制和十六进制,还包括正负号科学计数法，可以使用大写或者小写的 e 来表示。<br/>
parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀“0x”，而且会忽略非数字字符，也不支持科学计数法。在一些古老的浏览器环境中，parseInt 还支持 0 开头的数字作为 8 进制前缀，这是很多错误的来源。所以在任何环境下，都建议传入 parseInt 的第二个参数，而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何的其他进制。<br/>
<strong>Number</strong> 是比 parseInt 和 parseFloat 更好的选择。</p>

<h3 id="toc_9">NumberToString</h3>

<p>当Number绝对值较大或者较小时，字符串为了保证不会过长会用科学记数法表示。</p>

<h3 id="toc_10">装箱转换</h3>

<p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。<br/>
Symbole函数无法使用new来调用，可以利用call方法来强迫装箱。</p>

<pre><code class="language-javascript">    var symbolObject = (function(){ return this; }).call(Symbol(&quot;a&quot;));

    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true
</code></pre>

<p>我们可以用 console.log 看一下 symbolObject 的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象，这里再次应用了js原型。<br/>
装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。<br/>
使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p>

<pre><code class="language-javascript">    var symbolObject = Object(Symbol(&quot;a&quot;));

    console.log(typeof symbolObject); //object
    console.log(symbolObject instanceof Symbol); //true
    console.log(symbolObject.constructor == Symbol); //true
</code></pre>

<h3 id="toc_11">拆箱转换</h3>

<p>在 JavaScript 标准中，规定了 ToPrimitive 函数，它是对象类型到基本类型的转换（即，拆箱转换）<a href="https://juejin.cn/post/6844903555548053511">JavaScript 对象转换到基本类型值算法 ToPrimitive</a>。对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p>

<pre><code class="language-javascript">    var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }

    o * 2
    // valueOf
    // toString
    // TypeError
</code></pre>

<p>进行 o*2 这个运算的时候，先执行了 valueOf，接下来是 toString，最后抛出了一个TypeError，拆箱转换失败了。</p>

<pre><code class="language-javascript">    var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }

   String(o)
    // toString
    // valueOf
    // TypeError
</code></pre>

<p>到 String 的拆箱转换会优先调用 toString。</p>

<blockquote>
<p>在 ES6 之后，还允许对象通过显式指定 @@toPrimitive Symbol 来覆盖原有的行为.</p>

<pre><code class="language-javascript">var o = {
        valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},
        toString : () =&gt; {console.log(&quot;toString&quot;); return {}}
    }
   
o[Symbol.toPrimitive] = () =&gt; {console.log(&quot;toPrimitive&quot;); return &quot;hello&quot;}
    console.log(o + &quot;&quot;)
    // toPrimitive
    // hello
</code></pre>
</blockquote>

<h2 id="toc_12">补充</h2>

<p>除了这七种语言类型，还有一些语言的实现者更关心的规范类型。</p>

<ul>
<li>List 和 Record： 用于描述函数传参过程。</li>
<li>Set：主要用于解释字符集等。</li>
<li>Completion Record：用于描述异常、跳出等语句执行过程。</li>
<li>Reference：用于描述对象属性访问、delete 等。</li>
<li>Property Descriptor：用于描述对象的属性。</li>
<li>Lexical Environment 和 Environment Record：用于描述变量和作用域。</li>
<li>Data Block：用于描述二进制数据。</li>
</ul>

<p>标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。<br/>
<img src="media/16083847578374/16084396239357.jpg" alt="" style="width:305px;"/><br/>
JavaScript 之父本人也在多个场合表示过，typeof 的设计是有缺陷的，只是现在已经错过了修正它的时机。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript原型和原型链]]></title>
    <link href="blog.2019919.top/16080322533005.html"/>
    <updated>2020-12-15T19:37:33+08:00</updated>
    <id>blog.2019919.top/16080322533005.html</id>
    <content type="html"><![CDATA[
<p>今天刚开始学习【重学前端】的课程，讲到装箱转换的时候提到了函数的<code>call</code>方法，而<code>call</code>方法在我的印象中就只有<code>call</code>约等于<code>apply</code>，然后就再没有然后了。在我想深入了解下<code>call</code>方法的时候又发现了有人在同时讲解原型，而于此同时我看到了知乎上的一个贴<a href="https://www.zhihu.com/question/60165921">面试一个5年的前端，却连原型链也搞不清楚，满口都是Vue，React之类的实现，这样的人该用吗？</a>，这我不看内容我就惊呆了，这标题不就是在说我吗。带着各种心情赶紧学习下到底什么是原型和原型链。</p>

<h2 id="toc_0">原型</h2>

<pre><code class="language-text">prototype  [ˈproʊtətaɪp]  原型
</code></pre>

<p>OK完了😊！</p>

<p>下面这个图很多大神都有画过，下面记录下我自己的理解和实验。</p>

<p><img src="media/16080322533005/16080400429560.jpg" alt="" style="width:450px;"/></p>

<h3 id="toc_1">构造函数视角</h3>

<p>函数可以用来做构造器，也就是constructor，而构造器也可以称为类。<br/>
通过构造器<code>Apple</code>来创建一个对象对象<code>apple</code>。</p>

<p><img src="media/16080322533005/16080397593797.jpg" alt="" style="width:198px;"/></p>

<p><strong>构造函数创建了实例对象</strong>，这是构造函数与实例对象的关系。</p>

<hr/>

<p><strong>构造函数有一个属性叫做propotype,他指向了原型对象。</strong></p>

<p><img src="media/16080322533005/16080405364424.jpg" alt="" style="width:299px;"/></p>

<p>这里的原型对象有些大神也写做<code>[[propotype]]</code>，这里我猜测是为了区分propotype的属性。</p>

<h3 id="toc_2">原型对象视角</h3>

<p><strong>原型对象的constructor属性指向了构造函数</strong>。</p>

<p><img src="media/16080322533005/16080407735350.jpg" alt="" style="width:382px;"/></p>

<p>这里用构造器的原型对象的constructor方法来创建一个<code>badApple</code>，会发现它和<code>apple</code>的类型是相等的。</p>

<h3 id="toc_3">实例对象视角</h3>

<p>对象也有一个属性__propo__，这是一个隐式属性，<strong>对象的__propo__指向了他的构造函数的原型对象。</strong><br/>
也就是说<code>Apple</code>的propotype属性和<code>apple</code>、<code>badApple</code>的__propo__指向了同一个地址。</p>

<p><img src="media/16080322533005/16080419126552.jpg" alt="" style="width:318px;"/></p>

<h3 id="toc_4">由函数引出原型链</h3>

<p>函数是JS中的第一类对象，在Javascript中，对象所拥有的函数也同样拥有，也就是说构造函数<code>Apple</code>也同样会有__propo__属性去指向他的父类的原型对象，为了理清这乱七八糟的关系，就有了下面【对象-函数-构造函数-实例对象】这样的一个关系图，也就是原型链图。</p>

<h2 id="toc_5">原型链</h2>

<p><img src="media/16080322533005/16080423510561.jpg" alt=""/></p>

<p>这张图理解了上面的内容之后就感觉容易多了，总结一下有以下几点需要注意。</p>

<ul>
<li>任何函数的父类都是Function函数，也就是任何函数的__proto__指向Function的原型对象,这里同样包含了Function函数自己。</li>
<li>Object函数的__proto__指向Function的原型对象
<code>TODO</code></li>
</ul>

<h2 id="toc_6"> ES6中的类</h2>

<p>类的写法也是由原型运行时来承载的，逻辑上JavaScript认为每个类是有共同原型的一组对象，类中定义的方法和属性会被卸载原型对象之上。此外最重要的是类提供了继承能力。</p>

<pre><code class="language-javascript">class Animal { 
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(this.name + &#39; makes a noise.&#39;);
  }
}
class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }
  speak() {
    console.log(this.name + &#39; barks.&#39;);
  }
}
let d = new Dog(&#39;Mitzie&#39;);
d.speak(); // Mitzie barks.
</code></pre>

<p>以上代码创造了 Animal 类，并且通过 extends 关键字让 Dog 继承了它，展示了最终调用子类的 speak 方法获取了父类的 name。比起早期的原型模拟方式，使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p>

<blockquote>
<p>super关键字用于访问和调用一个对象的父对象上的函数。<br/>
在构造函数中使用时，super关键字将单独出现，并且必须在使用this关键字之前使用。</p>

<pre><code class="language-javascript">super([arguments]);
// 调用 父对象/父类 的构造函数
super.functionOnParent([arguments]);
// 调用 父对象/父类 上的方法
</code></pre>
</blockquote>

<h2 id="toc_7">最后</h2>

<p>在我继续学习这个课程之后，发现老师讲了什么是原型。。。尴尬！先过一遍全部课程，再回过头来自己输出一遍。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[angular mock的使用]]></title>
    <link href="blog.2019919.top/16073237309370.html"/>
    <updated>2020-12-07T14:48:50+08:00</updated>
    <id>blog.2019919.top/16073237309370.html</id>
    <content type="html"><![CDATA[
<p>在现在公司中，并没有真的前后端分离，往往是前后端一同疏通测试，美其名曰节省时间全面发展。因此至今没有单独写过mock进行前端自己的单体测试。这一次调查下mock的使用。</p>

<h2 id="toc_0">Angular的environments文件</h2>

<p><img src="media/16073237309370/16073245939102.jpg" alt="" style="width:746px;"/></p>

<p>environments文件分别是每个环境对应的配置。<br/>
每个文件与环境的对应关系存放于<code>angular.json</code>中。</p>

<p><img src="media/16073237309370/16073266078090.jpg" alt="" style="width:555px;"/></p>

<p>这个设定指定了cli在进行<code>production build</code>的时候将<code>environment.ts</code>替换成<code>environment.prod.ts</code>，即将开发环境的环境配置替换成生产环境的开发配置。<br/>
在这里设置isMock属性，让mock在生产环境中自动启动，开发环境~~~~中自动关闭。</p>

<h2 id="toc_1">Angular的main.ts文件</h2>

<p><img src="media/16073237309370/16073284745167.jpg" alt="" style="width:555px;"/></p>

<p>同样在cli中webpack的入口程序被设置为<code>src/main.ts</code>，也就是说<code>main.ts</code>是我们整个angualr的入口程序。我们在这里判断当前环境是否引入mock服务。</p>

<p><img src="media/16073237309370/16073286403589.jpg" alt="" style="width:566px;"/></p>

<h2 id="toc_2">mock服务的实现</h2>

<h3 id="toc_3">1.选择自己的包管理器添加mock的指令安装mock</h3>

<pre><code class="language-text">npm install mockjs --save
</code></pre>

<pre><code class="language-text">yarn add mockjs
</code></pre>

<h3 id="toc_4">2.创建mock文件，并添加到打包配置文件中</h3>

<p>又是<code>angualr.json</code>，在scripts中添加自己的mock文件路径，让webpack打包angular时同时打包我们的mock文件。<br/>
<img src="media/16073237309370/16073291483432.jpg" alt="" style="width:541px;"/></p>

<h3 id="toc_5">3.编写mock服务</h3>

<ul>
<li><p>首先导入mockjs。</p>
<pre><code class="language-typescript">import * as Mock from &#39;mockjs&#39;;
</code></pre></li>
<li><p>然后拦截请求，返回假数据</p>
<pre><code class="language-typescript">Mock.mock(&#39;http://localhost:9080/list&#39;, {
message: &#39;调用成功&#39;,<br/>
&#39;data|10&#39;: [{<br/>
&#39;id|+1&#39;: 1,<br/>
title: &#39;This is a title&#39;,<br/>
tags: [<br/>
  {<br/>
    id: 1,<br/>
    name: &#39;aaaa&#39;,<br/>
    color: &#39;red&#39;<br/>
  }<br/>
],<br/>
&#39;note|100&#39;: &#39;There are notes!&#39;<br/>
}]<br/>
});
</code></pre></li>
</ul>

<h2 id="toc_6">最后鼓励下自己</h2>

<p>angular中如何加载mock服务就到这，mock中的精髓是通过代码来生成数据，一行代码就可以生成千万条带有逻辑的数据，这些还需要细读一下API。这次记录是通过编译打包时的顺序来记录mock的使用方法，今后需要更深入的理解angular要多多从这个方向调查问题。</p>

]]></content>
  </entry>
  
</feed>
