<!doctype html>
<html class="no-js" lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>
    
    通过函数声明和调用掌握函数的 this 值 - 十
    
  </title>
  <meta name="description" content="">
  <link href="atom.xml" rel="alternate" title="十" type="application/atom+xml">
  <link rel="stylesheet" href="asset/css/foundation.min.css" />
  <link rel="stylesheet" href="asset/css/docs.css" />
  <script src="asset/js/vendor/modernizr.js"></script>
  <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>
    hljs.initHighlightingOnLoad();
  </script>
</head>

<body class="antialiased hide-extras">
  <div class="marketing off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">
      <nav class="top-bar docs-bar hide-for-small" data-topbar>
        <div id="header">
          <h3><a href="index.html">十的对称 十的完美</a></h1>
        </div>
      </nav>
      <nav class="tab-bar show-for-small">
        <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
          <span> &nbsp;</span>
        </a>
        <div id="header">
          <h3><a href="index.html">十的对称 十的完美</a></h1>
        </div>
      </nav>
      <aside class="left-off-canvas-menu">
        <ul class="off-canvas-list">
          <li><a href="index.html">关于我</a></li>
          
          <li class="divider"></li>
          <li><label>Angular</label></li>
          
          <li><a title="Angular 中 RXJS 的应用" href="16178761821381.html">Angular 中 RXJS 的应用</a></li>
          
          <li><a title="ng-fundamentals 基础内容查缺补漏" href="16175910817779.html">ng-fundamentals 基础内容查缺补漏</a></li>
          
          <li><a title="Angular 中的 DI" href="16166681233612.html">Angular 中的 DI</a></li>
          
          <li><a title="Angular 变更检测——它到底是如何工作的？" href="16164996860696.html">Angular 变更检测——它到底是如何工作的？</a></li>
          
          
          <li class="divider"></li>
          <li><label>JavaScript</label></li>
          
          <li><a title="States and Fates" href="16129618605374.html">States and Fates</a></li>
          
          <li><a title="JavaScript 深浅拷贝" href="16124460113427.html">JavaScript 深浅拷贝</a></li>
          
          <li><a title="函数中的展开运算符和解构" href="16108495213063.html">函数中的展开运算符和解构</a></li>
          
          <li><a title="通过函数声明和调用掌握函数的 this 值" href="16107633205948.html">通过函数声明和调用掌握函数的 this 值</a></li>
          
          <li><a title="通过变量作用域深入了解 undefined" href="16088182648987.html">通过变量作用域深入了解 undefined</a></li>
          
          <li><a title="JavaScript 原型和原型链" href="16080322533005.html">JavaScript 原型和原型链</a></li>
          
          
          <li class="divider"></li>
          <li><label>JavaScript权威指南第七版</label></li>
          
          <li><a title="第 6 章 对象" href="16113218396407.html">第 6 章 对象</a></li>
          
          <li><a title="第 7 章 数组" href="16124375850406.html">第 7 章 数组</a></li>
          
          <li><a title="第 8 章 函数" href="16106664265983.html">第 8 章 函数</a></li>
          
          <li><a title="第 9 章 类" href="16118386693796.html">第 9 章 类</a></li>
          
          <li><a title="第 10 章 模块" href="16130963383709.html">第 10 章 模块</a></li>
          
          <li><a title="第 12 章 迭代器和生成器" href="16135261093456.html">第 12 章 迭代器和生成器</a></li>
          
          <li><a title="第 13 章 异步 JavaScript" href="16130963623880.html">第 13 章 异步 JavaScript</a></li>
          
          
        </ul>
      </aside>
      <a class="exit-off-canvas" href="#"></a>
      <section id="main-content" role="main" class="scroll-container">
        <div class="row">
          <div class="large-9 medium-9 columns">
  <div class="markdown-body">
  <div class="markdown-inside">
    <h1>通过函数声明和调用掌握函数的 this 值</h1>
    <time class="article-date" datetime="2021-01-16T10:15:20+08:00">发布于2021/01/16</time>
    <p>函数的 this 对于基础薄弱的前端程序员一直是一个比较头疼的问题，在对 ES6 的模糊和对 ES6 之前的函数作用域不理解双重打击下，往往无法区分 this 值到底是什么，因而在编写程序时常常需要通过测试当前作用域的 this 是什么，再去使用，甚至是某些公司严格规定哪种方式去实现。</p>

<p>细细的看完了权威指南的第七版受益颇多，但是作者并没有拿出一个章节专门将相关内容进行汇总，这里就通过函数的声明和调用来总结下函数 this 值的几种情况。</p>

<h2 id="toc_0"> 函数定义</h2>

<p>函数的定义有多种方式来适应不同的使用场景：</p>

<ul>
<li>函数声明语句</li>
<li>函数表达式</li>
<li>箭头函数</li>
<li>嵌套函数</li>
<li>应用函数的构造函数 Function()</li>
</ul>

<h3 id="toc_1"> 函数声明语句</h3>

<p>与大多数声明语句一样，以关键字 + 名称的形式来进行声明，函数用关键字 function 来声明：</p>

<pre><code class="language-javascript">function testOutPut(){
    console.log(&#39;Hello world!&#39;);        
}
</code></pre>

<p>函数声明语句是函数名变成一个变量，这个变量的值是函数本身。这里实际上是声明了一个 testOutPut 变量，并讲函数对象赋值给 testOutPut。在 JavaScript 的运行时中，函数对象创建于该函数所在作用域的代码开始执行之前，也就是说，在同一个上下文中，可以先执行函数调用再进行函数语句声明。只是第一个函数作为值的概念的应用场景。</p>

<h3 id="toc_2"> 函数表达式</h3>

<p>函数表达式是一个赋值语句，将一个函数赋值给一个变量或常量。感觉函数表达式跟函数声明语句的运行时一样，但是如果先进行函数调用再进行函数表达式来定义函数将会异常。因为函数表达式在没有执行前并没有将函数赋值给变量，所以它也就不能被引用。</p>

<pre><code class="language-javascript">beforeDefined();
let beforeDefined = function(){console.log(1);}
// Uncaught ReferenceError: beforeDefined is not defined
</code></pre>

<p>函数表达式的函数名称是可选项，如果给函数表达式添加一个函数名，那这个函数的<em>局部函数作用域内</em>会包含该属性的函数名的对象，其值绑定的是该函数：</p>

<pre><code class="language-javascript">const f = function fact(x) {
    if (x &lt;= 1) return 1;
    else return x*fact(x-1);
};
</code></pre>

<p>只有在函数局部作用域内会有这个对象，有点闭包的感觉。</p>

<h3 id="toc_3"> 箭头函数</h3>

<p>箭头函数是 ES6 的新特性，在实际生产中非常常用。它支持很多简洁语法：</p>

<pre><code class="language-javascript">const sum = (x, y) =&gt; { return x + y; };
const sum = (x, y) =&gt; x + y;
const polynomial = x =&gt; x*x + 2*x + 3;
const constantFunc = () =&gt; 42;
</code></pre>

<p>注意参数和箭头之间不能换行，否则会引起歧义。<br/>
除此之外，它最大的特性就是它继承定义它环境的 this 值，我理解添加箭头函数的目的就是为了解决方法的嵌套函数 this 值为全局对象（严格模式下是 undefined）的缺陷：</p>

<pre><code class="language-javascript">let o = {
    a:1,
    m:function(){
        let self = this;
        console.log(this === o);
        f();
        function f(){
            console.log(this === o);
            console.log(self === o);
            console.log(this);
        }
    }
}
o.m();
// true
// flase
// true
// Window{...}
</code></pre>

<p>在 ES6 之前，我们需要通过闭包将 this 值保存在变量中使用，而有了箭头函数，可以直接继承 m 方法的 this 值：</p>

<pre><code class="language-javascript">o = {
    a:1,
    m:function(){
        let self = this;
        console.log(this === o);
        const f = () =&gt; {
            console.log(this === o);
            console.log(self === o);
            console.log(this);
        }
        f();
    }
}
o.m();
// true
// true
// true
// {a: 1, m: ƒ}
</code></pre>

<h3 id="toc_4"> 嵌套函数</h3>

<p>函数可以嵌套在其他函数内。嵌套函数可以访问包含它们函数的变量和参数（闭包）：</p>

<pre><code class="language-javascript">function first(){
    let strFirst = &quot;first&quot;;
    second();
    function second(){
        let strSecond = &quot;second&quot;;
        third();
        function third(){
            console.log(strFirst);
            console.log(strSecond);
        }
    }
}
first();
// first
// second
</code></pre>

<h3 id="toc_5"> Function() 构造函数创建函数</h3>

<p>Function() 函数的实参都是字符串，最后一个实参是函数体。</p>

<pre><code class="language-javascript">const f = new Function(&quot;x&quot;, &quot;y&quot;, &quot;return x*y;&quot;);
</code></pre>

<p>这里想到一个情况，当函数名相同时是否会报错：</p>

<pre><code class="language-javascript">const f1 = new Function(&quot;x&quot;, &quot;x&quot;, &quot;return x;&quot;);
f1(1,2);
// 2
</code></pre>

<p>实际情况并没有，再次测试一下直接函数声明语句使用两个相同的参数，也没有报错：</p>

<pre><code class="language-javascript">function f2(x,x,y){return x*y};
f2(1,2,2);
// 4
</code></pre>

<p>这样看实际上跟函数外部用 var 声明的变量在函数中再次声明一个效果：</p>

<pre><code class="language-javascript">var x = 1;
function test(){let x = 2;console.log(x)};
console.log(x);
test();
// 1
// 2
</code></pre>

<p>函数变量声明多个相相同的变量名时，传递的实参值将反复覆盖同名参数。<br/>
Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，看书上的一个例子：</p>

<pre><code class="language-javascript">let scope = &quot;global&quot;;
function constructFunction() {
    let scope = &quot;local&quot;;
    return new Function(&quot;return scope&quot;);  // Doesn&#39;t capture local scope!
}
constructFunction()(); 
// &quot;global&quot;
</code></pre>

<h2 id="toc_6"> 函数调用</h2>

<p>函数调用和方法调用很常见就不再赘述，这里有三种很少使用的调用方式：</p>

<ul>
<li>构造函数调用</li>
<li>间接调用</li>
<li>隐式调用</li>
</ul>

<h3 id="toc_7"> 构造函数调用</h3>

<pre><code class="language-javascript">function CreatObj(){
    this[&#39;p&#39;] = &quot;property&quot;;    
}
o = new CreatObj();
// CreatObj {p: &quot;property&quot;}
</code></pre>

<p>构造函数创建一个新对象，并将这个对象作为它的上下文，也就是说构造函数中的 this 值是新创建的对象。<br/>
构造函数通常没有 return 语句，当显示的用 return 语句返回一个对象时，构造函数创建的对象将变成它 return 的对象，其他情况当没有返回值或返回一个原始值时，返回值都被忽略，返回它新创建的对象。</p>

<h3 id="toc_8">间接调用</h3>

<p>JavaScript 万物接对象，对象就有自己的属性和方法。同理，函数也是对象，也有自己的方法和属性，而 call() 和 apply() 方法也可以用来间接调用函数。</p>

<h4 id="toc_9">call() 方法</h4>

<p>MDN 中对于 call() 的解释已经很明了了：</p>

<blockquote>
<p>The call() method calls a function with a given this value and arguments provided individually.</p>
</blockquote>

<pre><code class="language-javascript">f.call(o, 1, 2);
</code></pre>

<p>这里不过是将 o 对象作为函数 f 调用的上下文，并传入两个实参 1 和 2 作为实参列表，也就是说它等同与下面的代码：</p>

<pre><code class="language-javascript">o.m = f;
o.m(1, 2);
delete o.m;
</code></pre>

<p>这里注意 delete 语句，目的就是说函数在使用 call 方法时只是临时将 o 作为 f 的上下文并调用。而函数还有个不涉及调用的方法 bind() 它可以返回一个新的函数对象，<code>f.bind(o);</code>，而这个对象将一直绑定 o 为函数 f 的 this 值。</p>

<h4 id="toc_10">apply() 方法</h4>

<blockquote>
<p>The apply() method calls a function with a given this value, and arguments provided as an array (or an array-like object).</p>
</blockquote>

<p>不难看出 apply() 和 call() 基本一致，只是实参以数组或者类似数组的对象进行传递。这里对类似数组的对象进行测试：</p>

<pre><code class="language-javascript">function test(...args){
    console.log(this);
    for(item in args) console.log(item);
}
let o = {a:1};
let likeArr = {p1:1,p2:2};
likeArr.length = 2;    
let unLikeArr = {p1:1,p2:2};
test.apply(o,likeArr);
// {a: 1}
// 0
// 1
test.apply(o,unLikeArr);
// {a: 1}
</code></pre>

<p>可见有了 length 的对象就被当作是类似数组的对象。</p>

<h4 id="toc_11">this 值</h4>

<p>可见当 call() 和 apply() 调用函数时给函数绑定了一个上下文 this 值，但是箭头函数是个特例，它从它定义的位置的上下文继承 this 值。也就是说当给箭头函数定义的函数使用这两个方法时，第一个参数将被忽略：</p>

<pre><code class="language-javascript">let o = {
    a: 1,
    f: function(){
        const oBind = {b:1};
        const test = ()=&gt; console.log(this);
        test.apply(oBind);
    }
}
o.f();
// {a: 1, f: ƒ}
</code></pre>

<h3 id="toc_12">隐式调用</h3>

<ul>
<li>getter 和 setter 方法在获取或者设置它的属性时可能被隐式调用。</li>
<li>在对象进行字符串或者数值型和 BigInt 类型转换时，会隐式调用 toString() 和 valueOf() 方法。</li>
<li>循环可迭代对象的元素时会产生很多方法调用。</li>
<li>模板字符串可以调用函数。</li>
<li>Proxy 对象的任何一个操作都会导致函数调用。</li>
</ul>

<h2 id="toc_13"> 关于函数 this 值的总结</h2>

<p>函数 this 值有以下几种情况：</p>

<ul>
<li>函数声明语句和函数表达式定义的函数，在非严格模式下 this 值永远是 global，严格模式下是 undefined。</li>
<li>apply() call() bind() 方法用在非箭头函数时，第一个参数作为函数运行时的 this 值。</li>
<li>箭头函数的 this 值永远继承于它所定义的位置的 this 值。</li>
<li>对象的方法中 this 值是该对象的引用，嵌套在该对象中的函数不为方法，所以遵循函数的 this 值（global 或者 undefined）。</li>
<li>构造函数的 this 值是新创建的对象。</li>
</ul>

<p>闭包只是参数和变量作用域的引用，与 this 值无关。</p>

  </div>
</div>
<br /><br />
<hr />
<div class="row clearfix">
  <div class="large-6 columns">
    <div class="text-left" style="padding:15px 0px;">
      
      <a href="16108495213063.html" title="Previous Post: 函数中的展开运算符和解构">&laquo;
        函数中的展开运算符和解构</a>
      
    </div>
  </div>
  <div class="large-6 columns">
    <div class="text-right" style="padding:15px 0px;">
      
      <a href="16088182648987.html" title="Next Post: 通过变量作用域深入了解 undefined">通过变量作用域深入了解 undefined &raquo;</a>
      
    </div>
  </div>
</div>
<div class="row">
  <div style="padding:0px 0.93em;" class="share-comments">
    
  </div>
</div>
<script type="text/javascript">
  $(function () {
    var currentURL = '16107633205948.html';
    $('#side-nav a').each(function () {
      if ($(this).attr('href') == currentURL) {
        $(this).parent().addClass('active');
      }
    });
  });
</script>  
          </div>
          <div class="large-3 medium-3 columns">
            <div class="hide-for-small">
              <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">
                    
                    <li class="side-title"><span>Angular</span></li>
                    
                    <li>
                      <a title="Angular 中 RXJS 的应用" href="16178761821381.html">Angular 中 RXJS 的应用</a>
                    </li>
                    
                    <li>
                      <a title="ng-fundamentals 基础内容查缺补漏" href="16175910817779.html">ng-fundamentals 基础内容查缺补漏</a>
                    </li>
                    
                    <li>
                      <a title="Angular 中的 DI" href="16166681233612.html">Angular 中的 DI</a>
                    </li>
                    
                    <li>
                      <a title="Angular 变更检测——它到底是如何工作的？" href="16164996860696.html">Angular 变更检测——它到底是如何工作的？</a>
                    </li>
                    
                    
                    <li class="side-title"><span>JavaScript</span></li>
                    
                    <li>
                      <a title="States and Fates" href="16129618605374.html">States and Fates</a>
                    </li>
                    
                    <li>
                      <a title="JavaScript 深浅拷贝" href="16124460113427.html">JavaScript 深浅拷贝</a>
                    </li>
                    
                    <li>
                      <a title="函数中的展开运算符和解构" href="16108495213063.html">函数中的展开运算符和解构</a>
                    </li>
                    
                    <li>
                      <a title="通过函数声明和调用掌握函数的 this 值" href="16107633205948.html">通过函数声明和调用掌握函数的 this 值</a>
                    </li>
                    
                    <li>
                      <a title="通过变量作用域深入了解 undefined" href="16088182648987.html">通过变量作用域深入了解 undefined</a>
                    </li>
                    
                    <li>
                      <a title="JavaScript 原型和原型链" href="16080322533005.html">JavaScript 原型和原型链</a>
                    </li>
                    
                    
                    <li class="side-title"><span>JavaScript权威指南第七版</span></li>
                    
                    <li>
                      <a title="第 6 章 对象" href="16113218396407.html">第 6 章 对象</a>
                    </li>
                    
                    <li>
                      <a title="第 7 章 数组" href="16124375850406.html">第 7 章 数组</a>
                    </li>
                    
                    <li>
                      <a title="第 8 章 函数" href="16106664265983.html">第 8 章 函数</a>
                    </li>
                    
                    <li>
                      <a title="第 9 章 类" href="16118386693796.html">第 9 章 类</a>
                    </li>
                    
                    <li>
                      <a title="第 10 章 模块" href="16130963383709.html">第 10 章 模块</a>
                    </li>
                    
                    <li>
                      <a title="第 12 章 迭代器和生成器" href="16135261093456.html">第 12 章 迭代器和生成器</a>
                    </li>
                    
                    <li>
                      <a title="第 13 章 异步 JavaScript" href="16130963623880.html">第 13 章 异步 JavaScript</a>
                    </li>
                    
                    
                  </ul>
                </nav>
              </div>
            </div>
          </div>
        </div>
        <div class="page-bottom">
          <div class="row">
            <hr />
            <div class="small-9 columns">
              <p class="copyright">Contact Me&nbsp;
                Tel: +86 18641188786,&nbsp;
                mail: 416376663@qq.com</p>
            </div>
            <div class="small-3 columns">
              <p class="copyright text-right"><a href="#top">TOP</a></p>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>
  <script src="asset/js/foundation.min.js"></script>
  <script src="asset/js/foundation/foundation.offcanvas.js"></script>
  <script>
    $(document).foundation();
  </script>
  
  
  
</body>

</html>